# 面试题
- 1.LAC（两个view的第一个公共父view） H
- 2.sum（n）H
- 3.K个一组反转链表
- 4.合并多个升序的数组为一个降序数组 H
- 5.属性redawrite，readonly，assign，retain，copy，nonatomic各有什么作用，在哪种情况下用？H
- 6.属性是否可以扩展，如何扩展 H
- 7.weak属性是否需要在dealloc中置nil，底层实现怎么样的？ H
- 8.autorelease实现逻辑 H
- 9.Runloop和线程有什么关系 H
- 10.runloop各种状态处理了那些事 H
- 11.OC中的类方法和实例方法有什么区别和联系？ H
- 12.使用block时什么情况会发生引用循环，如何处理；H
- 13.一个block捕获到了一个局部变量，一个block捕获到了两个局部变量，这两个block的类型是一样的吗？其内部布局相同吗？如果类型想同，内存布局不同的话，为什么类型相同的实例，其内存布局不同？ H
- 14.Runtime如何通过selector找到对应的IMP地址？H
- 15.Method Swizzling，Method Swizzie是发如何确保安全的替换方法的？如何确保替换的不是父类的方法？H
- 16.A是父类，B和C同时继承于A,在B里面对父类方法进行交换，对C是否有影响  H
- 17.简述内存分区情况 H
- 18.方法缓存，为什么需要方法缓存，什么情况下会有问题；H
- 19.多线程，设计一个读写锁 H
- 20.并行同步和串行异步区别 H
- 21.栅栏函数，dispatch_barries_async有什么作用，有什么使用场景？H
- 22.请举出5个以上iOS中被称为黑魔法的编译宏，并解释其作用 H
- 23.请描述9种软件设计的原则，并分别描述你在设计一个SDK的时候是如果运用这些原则的 H
- 24.面向协议编程特点 H
- 25.如何捕获iOS的Crash？如果捕获C++的Crash？如果捕获Switch的Crash？前端如何捕获JS的Crsh？Flutter如何捕获Crash？ H
- 26.Swift如果调用C代码
- 27.Swift如何调用方法？C++如何调用方法？和OC的Runtime有什么区别？
- 28.WKWebView都有那些坑
- 29.iOS中的WebView如何优化
- 30.小程序是如何实现的
- 31.JSPatch是如何实现的 H
- 32.请描述23种设计模式在iOS中的例子
- 33.在设计插件的时候，应该如何运用23中设计模式？
- 34.如何保证iOS App的安全
- 35.如何做iOS逆向
- 36.请列举Unix信号
- 37.请列举Swift常用的关键字和用法（比如final、lazy等）


# 面试题
### 1.LAC（两个view的第一个公共父view） H

- 一个 UIViewController 中的所有 view 之间的关系其实可以看成一颗树，UIViewController 的 view 变量是这颗树的根节点，其它的 view 都是根节点的直接或间接子节点。

#### 两个for循环
- 时间复杂度为O(N^2)

```
- (void)viewDidLoad {
    [super viewDidLoad];
    Class commonClass1 = [self commonClass1:[ViewA class] andClass:[ViewC class]];
    NSLog(@"%@",commonClass1);
    // 输出：2018-03-22 17:36:01.868966+0800 两个UIView的最近公共父类[84288:2458900] ViewD
}
// 获取所有父类
- (NSArray *)superClasses:(Class)class {
    if (class == nil) {
        return @[];
    }
    NSMutableArray *result = [NSMutableArray array];
    while (class != nil) {
        [result addObject:class];
        class = [class superclass];
    }
    return [result copy];
}

- (Class)commonClass1:(Class)classA andClass:(Class)classB {
    NSArray *arr1 = [self superClasses:classA];
    NSArray *arr2 = [self superClasses:classB];
    for (NSUInteger i = 0; i < arr1.count; ++i) {
        Class targetClass = arr1[i];
        for (NSUInteger j = 0; j < arr2.count; ++j) {
            if (targetClass == arr2[j]) {
                return targetClass;
            }
        }
    }
    return nil;
}
```

#### 哈希集合
- 判断两个链表是否相交，可以使用哈希集合存储链表节点。
- 首先遍历viewA，并将viewA中的每个父view作为节点加入哈希集合中。然后遍历viewB，对于遍历到的每个父view作为节点，判断该节点是否在哈希集合中：
    * 如果当前节点不在哈希集合中，则继续遍历下一个节点；
    * 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都是两个链表的公共节点，因此在viewB中遍历到的第一个在哈希集合中的节点就是两个链表的第一个公共节点，返回该节点。
    * 如果viewB中的所有节点都不在哈希集合中，则两个链表不相交，返回null。
- 复杂度分析
    * 时间复杂度：O(m+n)O(m+n)，其中 m 和 n 是分别是链表headA和headB的长度。需要遍历两个链表各一次。
    * 空间复杂度：O(m)O(m)，其中 m 是链表headA 的长度。需要使用哈希集合存储链表headA中的全部节点。

```
- (NSArray *)superCalsses:(UIView *)class{
    if (!class) {
        return @[];
    }
    NSMutableArray * result = [NSMutableArray array];
    while (class) {
        [result addObject:class];
        class = [class superview];
    }
    return [result copy];
}
/**
 *基于两个view的父视图链条长度来判断 时间复杂度O(N) 空间复杂度O(1)
 **/
- (UIView *)commonClass1:(UIView *)classA andClass:(UIView *)classB{
    NSArray* arr1 = [self superCalsses:classA];
    NSArray* arr2 = [self superCalsses:classB];
    NSInteger count = arr1.count < arr2.count ? arr1.count : arr2.count;
    UIView * resultClass;
    for (int i = 0; i < count; ++i) {
        UIView * clA = arr1[arr1.count - i - 1];
        UIView * clB = arr2[arr2.count - i - 1];
        if (clA == clB) {
            resultClass = clA;
        }else{
            break;
        }
    }
    return resultClass;
} 
/**
 * 我们将一个路径中的所有点先放进 NSSet 中。因为 NSSet 的内部实现是一个 hash 表，所以查找元素的时间复杂度变成了 O（1），我们一共有 N 个节点，所以总时间复杂度优化到了 O（N）。
 *
 **/
- (UIView *)commonClass1_V2:(UIView *)classA andClass:(UIView *)classB{
    NSArray* arr1 = [self superCalsses:classA];
    NSArray* arr2 = [self superCalsses:classB];
    NSSet *set = [NSSet setWithArray:arr2];
    for (int i = 0; i < arr1.count; ++i) {
        UIView *targetView = arr1[i];
        if ([set containsObject:targetView]) {
            return targetView;
        }
    }
    return nil;
}
/**
 * 除了使用 NSSet 外，我们还可以使用类似归并排序的思想，用两个「指针」，分别指向两个路径的根节点，然后从根节点开始，找第一个不同的节点，第一个不同节点的上一个公共节点，就是我们的答案。
 * O(N)
 */
- (UIView *)commonClass1_V3:(UIView *)classA andClass:(UIView *)classB{
    NSArray* arr1 = [self superCalsses:classA];
    NSArray* arr2 = [self superCalsses:classB];
    NSInteger p1 = arr1.count - 1;
    NSInteger p2 = arr2.count - 1;
    UIView *answer = nil;
    while (p1 >=0 && p2 >= 0) {
        if (arr1[p1] == arr2[p2]) {
            answer = arr1[p1];
        }
        p1--;
        p2--;
    }
    return answer;
}
```
### 2.sum（n）H

#### n和数的和：（n+1）n/2
#### 判断数组中是否有两个数字之和等于目标值
##### 双指针
```
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int n = numbers.size();
        int i = 0, j = n-1;
        while(i < j){
            while(numbers[i] + numbers[j] > target)
                --j;
            if(numbers[i] + numbers[j] == target)
                return {i, j};
            ++i;
        }
        return {};
    }
};
```
- 如果每次选中一个数，然后遍历整个数组，判断是否有另一个数使两者之和满足条件。这种时间复杂度为O(n^2)
- 在遍历数组的过程中，利用集合保存遍历的当前值。若集合中存在目标值减去当前值的差值，说明数组中一定有一个数与当前值之和等于目标值。这种时间复杂度为O(n)，

### 3.K个一组反转链表
```
class Solution:
    # 翻转一个子链表，并且返回新的头与尾
    def reverse(self, head: ListNode, tail: ListNode):
        prev = tail.next
        p = head
        while prev != tail:
            nex = p.next
            p.next = prev
            prev = p
            p = nex
        return tail, head
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        hair = ListNode(0)
        hair.next = head
        pre = hair
        while head:
            tail = pre
            # 查看剩余部分长度是否大于等于 k
            for i in range(k):
                tail = tail.next
                if not tail:
                    return hair.next
            nex = tail.next
            head, tail = self.reverse(head, tail)
            # 把子链表重新接回原链表
            pre.next = head
            tail.next = nex
            pre = tail
            head = tail.next
        return hair.next
```

### 4.合并多个升序的数组为一个降序数组 H
- 暴力解决for循环
- 利用优先级队列进行节点排序
```
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists.length == 0) return null;
        //虚拟头节点
        ListNode dummy = new ListNode(-1);
        ListNode p = dummy;
        //优先级队列-最小堆
        PriorityQueue<ListNode> pq = new PriorityQueue<>(
            lists.length, (a, b)->(a.val - b.val));
        //将K个链表的头节点加入最小堆
        for（ListNode head : lists）{
            if (head != null)
            pq.add(head);
        }
        while (!pq.isEmpty()) {
            //获取最小节点，到结果链表中
            ListNode node = pq.poll();
            p.next = node;
            if (node.next != null) {
                pq.add(node.next);
            }
            //p指针不断前进
            p = p.next;
        }
        return dummy.next;
    }
}

```

### 5.属性redawrite，readonly，assign，retain，copy，nonatomic各有什么作用，在哪种情况下用？H
- readwrite：可读可写特性,需要生成setter和getter方法时使用, 可被外界读取和修改；
- readonly：只读特性,只会生成getter方法,只可被外界读取, 不能修改；
- assign：赋值特性,作用于非OC对象的赋值,setter方法将参数传给变量；主要用于修饰对象和基本数据类型，例如NSInteger，CGFloat，int，遵循先进后出的原则，存储在栈中，内存不用程序员管理。assign是可以修饰对象的，但是会出现问题。问题是：
    * - weak生成的成员变量是用__weak修饰的，assign生成的成员变量是用__unsafe_unretained修饰的；
    * 对象开辟的空间是在堆空间，指针开辟的空间是在栈上，使用assign修饰，当对象销毁时并不会将指针置为nil。所以当堆空间的对象销毁时指向对象的指针仍然存在，会造成野指针，当访问该对象时会crash报错EXC_BAD_ACCESS。因为基本数据类型的空间开辟也在栈空间，同样由系统进行销毁，所以不存在野指针的情况。使用weak修饰对象时当对象销毁时指针也会被置为nil，所以用weak不会造成野指针。
- retain：持有特性,他的setter方法会释放旧址,然后引用住新值, 并且将新值的引用计数+1,只能作用于OC对象(基本数据类型和CoreFoundation对象没有引用计数的概念, 因此不能用retain)
- Strong：表示指向并持有该对象，其修饰对象的引用计数会加1。该对象只要引用计数不为0就不会被销毁。当然可以通过将变量强制赋值 nil 来进行销毁。
- weak：指向但是并不持有该对象，引用计数也不会加1。在 Runtime 中对该属性进行了相关操作，无需处理，可以自动销毁。weak用来修饰对象，多用于避免循环引用的地方。weak 不可以修饰基本数据类型。
- copy
    * 复制特性,此属性只对遵守了NSCopying协议的对象类型有效,一般作用于NSString,NSArray,NSDictionary等有可变类型的对象
    * 如果copy的是不可变类型,就不会开辟新的内存空间, 并且为指针拷贝, 指向同一个内存地址:浅拷贝
    * 如果copy的是可变类型, 就会开辟新的内存空间, 并且将内容copy下来单独保存: 深拷贝
    * 注意: 如果在系统中创建内容相同的不可变字符串, 系统会自动做出优化, 指向同一块内存空间
- nonatomic
    * 非原子性,即非线程安全的,不给变量提供线程锁保护, 这样会提高性能
    * 系统自动生成的getter/setter方法不会进行加锁操作；但速度会更快；
    * 在iOS的移动端,一般不会出现多线程访问同一个属性的情况,就算发生情况,atomic也不能完美的保证安全, 并且还需要手动增加线程锁,因此对于变量都应该使用nonatomic
- atomic
    * atomic会给属性加上一个自旋锁,系统自动生成的getter/setter方法会进行加锁操作；可以理解过读写锁，可以保证读写安全；较耗时；这是为了防止多线程同时访问属性出现异常需要添加的属性,但是这样会增加额外的内存开销并且在变编程习惯中,我们都应该避免多线程访问统一资源
    * 即便是使用atomic,在多线程时也无法完全保证线程安全, 往往是需要手动添加线程锁
- __unsafe_unretain：类似于weak，但是当对象被释放后，指针已然保存着之前的地址，被释放后的地址变为僵尸对象，访问被释放的地址就会出问题，所以说他是不安全的。
- __autoreleasing：将对象赋值给附有__autoreleasing修饰的变量等同于 ARC 无效时调用对象的autorelease方法,实质就是扔进了自动释放池。

### 6.属性是否可以扩展，如何扩展 H
- 可以
- 类扩展:能为某个类添加成员变量,属性,方法;
- 分类：增加属性的时候，由于只声明了set和get方法，并没有实现，可以用关联对象的方法增加；

### 7.weak属性是否需要在dealloc中置nil，底层实现怎么样的？ H

#### 不需要
- 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理
- 即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：
- 我们模拟下 weak 的 setter 方法，应该如下：

```
- (void)setObject:(NSObject *)object
{
   objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
   [object cyl_runAtDealloc:^{
       _object = nil;
   }];
}
```
- 也即:在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。

#### weak属性需要在dealloc中置nil底层原理
- 当对象引用计数为0时，运行时会调用_objc_rootDealloc；
- _objc_rootDealloc调用的rootDealloc方法
- 这时候会判断是否可以被释放，判断的依据主要有5个，判断是否有以上五种情况：对象采用了优化的isa计数方式，对象没有被weak引用，没有关联对象，没有自定义的C++析构方法，没有用到sideTable来做引用计数；如果都没有就调用free（）函数释放；
- 如果有上述5种中的一种，就调用object_dispose，在这个函数里面remove掉或者是clean掉，再调用free（）函数

#### 底层实现
- 我们日常开发中经常是使用weak关键字来解决循环引用的问题，原因是被weak引用的对象它的引用计数不会增加，而且在这个对象被释放的时候被weak修饰的变量会自动置空，不会造成野指针的问题，相对来说比较安全。
- weak表其实是一个hash（哈希）表(字典也是hash表)，Key是所指对象的地址，Value是weak指针的地址集合。
- weak相关的数据结构有四个SideTables、SideTable、weak_table_t、weak_entry_t，他们是总分关系，整个结构是一个三级哈希表，之所以设计的这么复杂是因为SideTable不仅用于弱引用，还需要它辅助存储对象的引用计数，而weak_table_t、weak_entry_t则完全用于存储弱引用的相关信息
- 对象每增加一个弱引用，运行时就会调用objc_initWeak-> storeWeak方法将weak指针的地址存储到对象对应的weak_entry_t的数组中，key是对象的地址
- 我们通过打断点查看汇编的方式来查看weak底层的调用原理，我们通过查看汇编发现weak底层调用的是objc_initWeak，给objc_initWeak打上符号断点重新运行，发现objc_initWeak存在于libobjc.A.dylib的动态库中。

#### objc_initWeak
- 我们在libobjc.A.dylib的开源代码中查找并定位到objc_initWeak函数。

```
id
objc_initWeak(id *location, id newObj)
{
    if (!newObj) {
        *location = nil;
        return nil;
    }

    return storeWeak<DontHaveOld, DoHaveNew, DoCrashIfDeallocating>
        (location, (objc_object*)newObj);
}
```
- 其中包含：前置条件判断，执行storeWeak的存储操作。

#### storeWeak
- 前置条件判断，声明新旧两个SideTable。

```
assert(haveOld  ||  haveNew);
if (!haveNew) assert(newObj == nil);

Class previouslyInitializedClass = nil;
id oldObj;
SideTable *oldTable;
SideTable *newTable;
```
- 根据新值和旧值分别获取全局的SideTables表，分别赋值给oldTable，newTable。

```
if (haveOld) {
    oldObj = *location;
    oldTable = &SideTables()[oldObj];
} else {
    oldTable = nil;
}
if (haveNew) {
    newTable = &SideTables()[newObj];
} else {
    newTable = nil;
}
```
- 防止弱引用机制和初始化出现死锁，在弱引用之前，要确保对象已经成功初始化。

```
if (haveNew  &&  newObj) {
    Class cls = newObj->getIsa();
    if (cls != previouslyInitializedClass  &&
        !((objc_class *)cls)->isInitialized())
    {
        SideTable::unlockTwo<haveOld, haveNew>(oldTable, newTable);
        class_initialize(cls, (id)newObj);

        // If this class is finished with +initialize then we're good.
        // If this class is still running +initialize on this thread
        // (i.e. +initialize called storeWeak on an instance of itself)
        // then we may proceed but it will appear initializing and
        // not yet initialized to the check above.
        // Instead set previouslyInitializedClass to recognize it on retry.
        previouslyInitializedClass = cls;

        goto retry;
    }
}
```
- 清空旧值。

```
// Clean up old value, if any.
if (haveOld) {
    weak_unregister_no_lock(&oldTable->weak_table, oldObj, location);
}
```
- 存储新值（weak_register_no_lock函数执行真正的存储逻辑）。

```
// Assign new value, if any.
if (haveNew) {
    newObj = (objc_object *)
        weak_register_no_lock(&newTable->weak_table, (id)newObj, location,
                              crashIfDeallocating);
    // weak_register_no_lock returns nil if weak store should be rejected

    // Set is-weakly-referenced bit in refcount table.
    if (newObj  &&  !newObj->isTaggedPointer()) {
        newObj->setWeaklyReferenced_nolock();
    }

    // Do not set *location anywhere else. That would introduce a race.
    *location = (id)newObj;
}
else {
    // No new value. The storage is not changed.
}
```

#### weak_register_no_lock
- 参数解释
    * weak_table 全局的弱引用表。
    * referent 若引用对象的指针。
    * referrer weak指针的地址。
    * 声明一个weak_entry_t *entry;结构体，这里保存了被若引用对象的指针，和weak指针的地址。
    * 根据弱引用对象的指针从全局的weak_table中查找entry，如果找到了entry则执行插入操作。
    * 通过直接操作数组中的元素来达到修改数值的目的，weak_entry_for_referent返回的是数组中元素的指针。
    * 如果没有找到则新建一个weak_entry_t结构体数组，直接将这个weak_entry_t结构体数组插入到weak_table中。
- 相关代码：
```
// now remember it and where it is being stored
weak_entry_t *entry;
if ((entry = weak_entry_for_referent(weak_table, referent))) {
    append_referrer(entry, referrer);
}
else {
    // 创建了这个数组 - 插入weak_table
    weak_entry_t new_entry(referent, referrer);
    weak_grow_maybe(weak_table);
    weak_entry_insert(weak_table, &new_entry);
}
```
- 总结：
    * 通过SideTable找到我们的weak_table
    * weak_table 根据referent 找到或者创建 weak_entry_t
    * 然后append_referrer(entry, referrer)将我的新弱引用的对象加进去entry
    * 最后weak_entry_insert 把entry加入到我们的weak_table

### 8.autorelease实现逻辑 H
- autorelease就是自动释放，会像C语言的自动变量那样来对待对象实例。当超出作用于时，对象实例的release实例方法被调用。

#### 具体实现：
- 当我们调用autorelease时，其实质就是把自己追加到正在使用的NSAutoreleasePool 对象中的数组里

```
- (id) autorelease {
  [NSAutoreleasePool addObject:self];
}
```
- autorelease的具体使用方法如下：
    * 生产并持有NSAutoreleasePool对象；
    * 调用分配对象的autorelease实例方法；
    * 废弃NSAutoreleasePool对象。



### 9.Runloop和线程有什么关系 H
- RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象。
- run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分，
- 主线程的run loop默认是启动的。
- 原因：iOS的应用程序里面，程序启动后会有一个如下的main()函数，重点是UIApplicationMain()函数，这里会创建一个主线程，用于UI处理，为了让程序可以一直运行，所以在主线程中开启一个runloop，让主线程常驻。

### 10.runloop各种状态处理了那些事 H
- kCFRunLoopEntry：RunLoop准备启动
- kCFRunLoopBeforeTimers：RunLoop将要处理一些Timer相关事件
- kCFRunLoopBeforeSources：RunLoop将要处理一些Source事件
- kCFRunLoopBeforeWaiting：RunLoop将要进行休眠状态,即将由用户态切换到内核态
- kCFRunLoopAfterWaiting：RunLoop被唤醒，即从内核态切换到用户态后
- kCFRunLoopExit：RunLoop退出
- kCFRunLoopAllActivities：监听所有状态

### 11.OC中的类方法和实例方法有什么区别和联系？ H
- 类方法：
    * 类方法是属于类对象的
    * 类方法只能通过类对象调用
    * 类方法中的self是类对象
    * 类方法可以调用其他的类方法
    * 类方法中不能访问成员变量
    * 类方法中不能直接调用对象方法
- 实例方法：
    * 实例方法是属于实例对象的
    * 实例方法只能通过实例对象调用
    * 实例方法中的self是实例对象
    * 实例方法中可以访问成员变量
    * 实例方法中直接调用实例方法
    * 实例方法中也可以调用类方法(通过类名)

### 12.使用block时什么情况会发生引用循环，如何处理；H
- 循环引用就是当self 拥有一个block的时候，在block 又调用self的方法。形成你中有我，我中有你，谁都无法将谁释放的困局。其实就是一个对象中强引用了block，在block中又强引用了该对象，就会发生循环引用。
- 解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用。
    * id weak weakSelf = self; 或者 weak __typeof(&*self)weakSelf = self该方法可以设置宏
    * id __block weakSelf = self;
    * 或者将其中一方强制制空 xxx = nil。

### 13.一个block捕获到了一个局部变量，一个block捕获到了两个局部变量，这两个block的类型是一样的吗？其内部布局相同吗？如果类型想同，内存布局不同的话，为什么类型相同的实例，其内存布局不同？ H

- Block有三种类型:
    * __NSGlobalBlock,
    * __NSStackBlock,
    * __NSMallocBlock
- 类型是一样的，内存的话一个存了一个，一个存了两个；

### 14.Runtime如何通过selector找到对应的IMP地址？H
- 每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.

### 15.Method Swizzling，Method Swizzie是发如何确保安全的替换方法的？如何确保替换的不是父类的方法？H
#### Method Swizzling
- 关联对象的的api就只有三个

```
// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象;
  objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,
                         id _Nullable value, objc_AssociationPolicy policy)

// 用于获取关联对象                        
  objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)

// 移除所有的关联对象
  objc_removeAssociatedObjects(id _Nonnull object)
```
- 注: objc_removeAssociatedObjects 函数我们一般是用不上的, 因为这个函数会移除一个对象的所有关联对象, 将该对象恢复成“原始”状态. 这样做就很有可能把别人添加的关联对象也一并移除, 这并不是我们所希望的. 所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象. 不过我猜测对象析构时系统会直接调用这个移除所有关联对象.

##### objc_setAssociatedObject
- AssociationsManager 是顶级管理者,维护了一个从 spinlock_t 锁到 AssociationsHashMap 哈希表的单例键值对映射;
- AssociationsHashMap 是一个无序的哈希表, 维护了从对象地址到 ObjectAssociationMap 的映射; ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key 到 ObjcAssociation 的映射，即关联记录;
- ObjcAssociation 是一个 C++ 的类,表示一个具体的关联结构, 主要包括两个实例变量, _policy 表示关联策略, _value表示关联对象.
- 每一个对象地址对应一个 ObjecAssociationMap 对象，而一个 ObjectAssociationMap 对象保存着这个对象的若干个关联记录ObjectAssociation, 每个 ObjectAssociation 则保存了被关联的对象和关联策略.

##### objc_getAssociatedObject
- objc_getAssociatedObject 函数对我们来说就是小菜一碟了.这个函数先根据对象地址在 AssociationsHashMap 中查找其对应的 ObjectAssociationMap 对象, 如果能找到则进一步根据 key 在 ObjectAssociationMap 对象中查找这个 key 所对应的关联结构 ObjcAssociation ,如果能找到则返回 ObjcAssociation 对象的 value 值，否则返回 nil .

##### objc_removeAssociatedObjects
- 这个函数负责移除一个对象的所有关联对象, 具体实现也是先根据对象的地址获取其对应的 ObjectAssociationMap 对象，然后将所有的关联结构保存到一个 vector 中, 最终释放 vector 中保存的所有关联对象.

#### Method Swizzie是发如何确保安全的替换方法的？如何确保替换的不是父类的方法
- 方法交换实际就是互相替换方法的实现。以下是方法Method的底层结构：

```
struct method_t {
    SEL name;
    IMP imp;
    const char *types;
}
```
- 在Objective-C的runtime特性中，调用一个对象的方法就是给这个对象发送消息。是通过查找接收消息对象的方法列表，从方法列表中查找对应的SEL，这个SEL对应着一个IMP（一个IMP可以对应多个SEL），通过这个IMP找到对应的方法调用。
- 方法交换在使用过程中应该注意的一些问题：

##### 子类方法和父类方法替换导致父类调用异常
- 自定义一个类Animal和继承自Animal的子类Dog。父类有个实例方法parentInstanceMethod，子类有个方法childInstanceMethod，对这两个方法进行替换，当运行的时候子类Dog调用parentInstanceMethod没有崩溃，父类Animal调用parentInstanceMethod崩溃了，
- 原因：首先因为Dog继承了Animal，所以相当于说Dog两个方法childInstanceMethod和parentInstanceMethod都有，但是Animal没有方法childInstanceMethod，所以在方法替换的时候，子类方法指向了父类方法parentInstanceMethod的实现，父类方法parentInstanceMethod指向了子类方法childInstanceMethod的实现，因此父类在调用parentInstanceMethod方法时，实际调用的是子类方法childInstanceMethod的实现，而此时子类中通过childInstanceMethod调用原先的父类方法，根据消息发送流程，实际上是向父类发送childInstanceMethod消息，但是父类方法列表中并没有childInstanceMethod方法，而在消息发送流程中，方法寻找过程是由子类向父类移动的，而方法childInstanceMethod存在于子类，所以就出现崩溃。
- 解决：方法交换前先尝试为当前类添加要被替换的方法，在方法交换前，我们先尝试添加一个新的方法，如果添加成功，则直接替换，如果添加不成功则交换。

##### 如何确保替换的不是父类的方法？
- 首先打印子类的方法列表，判断有没有，如果有的话就直接交换，如果没有的话就添加这个方法，这样就不用替换父类的方法；

### 16.A是父类，B和C同时继承于A,在B里面对父类方法进行交换，对C是否有影响  H
- 首先要看B是否对A的方法承载
- 如果B对A的方法做了承载，然后进行方法交换，对C就有影响，如果有新的属性声明，C调用的时候就会崩溃；
- 如果B对A的方法没有承载，然后进行方法交换，其实质就是A本身方法交换，对C就没有影响；

### 17.简述内存分区情况 H
- 栈区：存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等，内存地址从高到低分配。
- 堆区：堆区的地址是从低到高分配，通过程序员通过alloc手动分配。
- 全局区：包含两个部分，未初始化区，初始化区域。全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；
- 代码区存放于低地址，栈区存放于高地址。区与区之间并不是连续的。堆区的内存是应用程序共享的，堆中的内存分配是系统负责的；当引用计数为0的时候，系统会回收该内存。

### 18.方法缓存，为什么需要方法缓存，什么情况下会有问题；H
- 在OC里面调用一个方法的时候，其实就是消息发送；
- objc_msgSend（就arm平台而言）的消息分发分为以下几个步骤：
    * 判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象；
    * 从缓存里寻找，找到了则分发，否则方法去寻找selector
    * 如果支持GC，忽略掉非GC环境的方法（retain等）从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则
    * 寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则
    * 调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则
    * 转发这个selector，否则报错，抛出异常
- 从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。所以就需要方法缓存；
- 在iOS中，对象方法是存储在类对象的bits里面，类方法是存储在元类对象的bits里面。类对象和元类对象的本质都为objc_class类型的结构体。
- objc_class结构体里面有个cache。这个cache的用途就是，缓存我们调用过的方法。
- objc_cache，它包含了下面三个变量：
    * mask：可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1
    * occupied：被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目
    * buckets：用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存
- 问题：当容器扩容之后，前面存储的方法也会随之清空。

### 19.多线程，设计一个读写锁 H
- iOS中常见的一个就是同步任务加栅栏函数，同步读操作，栅栏函数写操作；另一个是pthread_rwlock：等待锁的线程会进入休眠
- 模拟的话有两把互斥锁加一个整数计数器，条件变量加互斥锁、整型计数器（表示正在读的个数）与布尔标志（表示正在写）来实现

#### pthread_rwlock

![image](https://www.freesion.com/images/307/105c563d2b9ca2580bdc6b55b8244d03.png)

#### 两把互斥锁
- 使用两把互斥锁与一个整数计数器实现。计数器condition跟踪被阻塞的读线程。互斥锁rlock保护condition，供读者使用。互斥锁wlock 确保写操作互斥。

```
#import "JKRWLock.h"
#import <pthread/pthread.h>

pthread_mutex_t rlock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t wlock = PTHREAD_MUTEX_INITIALIZER;

static int condition = 0;

@implementation JKRWLock
//读者加锁
- (void)rLock {
    pthread_mutex_lock(&rlock);
    condition++;
    if (condition == 1) {
        pthread_mutex_lock(&wlock);
    }
    pthread_mutex_unlock(&rlock);
}
//读者解锁
- (void)rUnlock {
    pthread_mutex_lock(&rlock);
    condition--;
    if (condition == 0) {
        pthread_mutex_unlock(&wlock);
    }
    pthread_mutex_unlock(&rlock);
}
//写者加锁
- (void)wLock {
    pthread_mutex_lock(&wlock);
    pthread_mutex_lock(&wlock);
}
//写者解锁
- (void)wUnlock {
    pthread_mutex_unlock(&wlock);
}
@end
```

#### 条件变量+互斥锁
- 可使用条件变量cond与普通的互斥锁rwlock、整型计数器readCount（表示正在读的个数）与布尔标志write（表示正在写）来实现读写锁。

```
#import "JKRWLock.h"
#import <pthread/pthread.h>

@interface JKRWLock ()
@property (nonatomic, assign) int readCount;
@property (nonatomic, assign, getter=isWriting) BOOL write;
@end
//读写锁
pthread_mutex_t rwlock = PTHREAD_MUTEX_INITIALIZER;
//条件变量
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

@implementation JKRWLock

//读者加锁
- (void)rLock {
    pthread_mutex_lock(&rwlock);
    while (self.isWriting) {
        pthread_cond_wait(&cond, &rwlock);
    }
    self.readCount++;
    pthread_mutex_unlock(&rwlock);
}
//读者解锁
- (void)rUnlock {
   pthread_mutex_lock(&rwlock);
    self.readCount--;
   if (self.readCount == 0) {
       //唤起一条写的线程
       pthread_cond_signal(&cond);
   }
   pthread_mutex_unlock(&rwlock);
}
//写者加锁
- (void)wLock {
    pthread_mutex_lock(&rwlock);
    while (self.isWriting || self.readCount > 0) {
        pthread_cond_wait(&cond, &rwlock);
    }
    self.write = YES;
    pthread_mutex_unlock(&rwlock);
}
//写者解锁
- (void)wUnlock {
    pthread_mutex_lock(&rwlock);
    self.write = NO;
    //唤起多个读的线程
    pthread_cond_broadcast(&cond);
    pthread_mutex_unlock(&rwlock);
}
@end
```

#### 同步任务+栅栏
- 读数据

```
- (id)objectForKey:(NSString *)key {
    __block id obj;
    // 同步读取指定数据:
    dispatch_sync(self.concurrent_queue, ^{
        obj = [self.dataCenterDic objectForKey:key];
    });
    return obj;
}
```
- 写数据

```
- (void)setObject:(id)obj forKey:(NSString *)key {
    // 异步栅栏调用设置数据:
    dispatch_barrier_async(self.concurrent_queue, ^{
        [self.dataCenterDic setObject:obj forKey:key];
    });
}
```

### 20.并行同步和串行异步区别 H


### 21.栅栏函数，dispatch_barries_async有什么作用，有什么使用场景？H
- dispatch_barrier_async/dispatch_barrier_sync（栅栏函数）
    * 作用：与并发队列结合，可以高效率的避免数据竞争的问题
    * 相同点：dispatch_barrier_sync和dispatch_barrier_async函数功能一样就是在并发队列中将此代码插入的地方上下隔开，如果栅栏一样，两部分不影响。只有上边的并发队列都执行结束之后，下边的并发队列才能够执行。
    * 不同点:dispatch_barrier_sync代码后边的任务直到dispatch_barrier_sync执行完才能被追加到队列中；dispatch_barrier_async不用代码执行完，后边的任务也会被追加到队列中。代码上的体现就是dispatch_barrier_sync后边的代码不会执行，dispatch_barrier_async后边的代码会执行，但是Block不会被执行。
    * dispatch_barrier_async
        * dispatch_async将指定的Block异步的追加到指定的Dispatch Queue中。dispatch_async函数不会做任何等待
        * dispatch_async代表异步任务，意思不是一定会生成一条线程。如果在MainQueue中执行，则不会生成线程；如果在Global Queue中有可能会生成。因为线程有一个线程池，会重用已经完成任务了的线程。
    * dispatch_barrier_sync
        * dispatch_sync将指定的Block同步的追加到指定的Dispatch Queue。此时dispatch_sync会一直等待Block执行结束之后，才会返回。线程才能接着继续执行其他代码。
        * 当前queue是串行队列。 当前queue上调用sync函数，并且sync函数中指定的queue也是当前queue。需要执行的block被放到当前queue的队尾等待执行，因为这是一个串行的queue，调用sync函数会阻塞当前队列,等待block执行 这个block永远没有机会执行sync函数不返回，所以当前队列就永远被阻塞了，这就造成了死锁。（这就是问题中在主线程调用sync函数，并且在sync函数中传入main_queue作为queue造成死锁的情况）
        * 当前queue是并行队列。 在并行的queue上面调用sync函数，同时传入当前queue作为参数，并不会造成死锁，因为block会马上被执行，所以sync函数也不会一直等待不返回造成死锁。（并且Block是在当前线程上执行。例如如果是在主线程上调用了dispatch_sync,则Block是在主线程上执行的）

### 22.请举出5个以上iOS中被称为黑魔法的编译宏，并解释其作用 H
- attribute是一套编译器指令，被GNU和LLVM编译器所支持，允许对于attribute增加一些参数，做一些高级检查和优化。
- attribute的语法是，在后面加两个括号，然后写属性列表，属性列表以逗号分隔。
#### objc_subclassing_restricted
- 表示被修饰的类不能被其他类继承，否则会报下面的错误。

```
错误信息：
Cannot subclass a class that was declared with the 'objc_subclassing_restricted' attribute
```
#### objc_requires_super
- 表示子类必须调用被修饰的方法super，否则报黄色警告。

```
- (void)test __attribute__((objc_requires_super));`
`警告信息：(不报错)
Method possibly missing a [super test] call
```
#### constructor / destructor
- constructor属性表示在main函数执行之前，可以执行一些操作。destructor属性表示在main函数执行之后做一些操作。constructor的执行时机是在所有load方法都执行完之后，才会执行所有constructor属性修饰的函数。

```
__attribute__((constructor)) static void beforeMain() {
    NSLog(@"main函数执行前执行");
}

__attribute__((destructor)) static void afterMain() {
    NSLog(@"main函数执行后执行");
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSLog(@"main函数执行时执行");
    }
    return 0;
}
执行结果：
debug-objc[23391:1143291] before main
debug-objc[23391:1143291] execute main
debug-objc[23391:1143291] after main
```
- 在有多个constructor或destructor属性修饰的函数时，可以通过设置优先级来指定执行顺序。格式是attribute((constructor(1)))的方式，在属性后面直接跟优先级。

```
__attribute__((constructor(3))) static void beforeMain3() {
    NSLog(@"after main 3");
}

__attribute__((constructor(1))) static void beforeMain1() {
    NSLog(@"after main 1");
}

__attribute__((constructor(2))) static void beforeMain2() {
    NSLog(@"after main 2");
}
```
- 在constructor中根据优先级越低，执行顺序越高。而destructor则相反，优先级越高则执行顺序越高。

#### overloadable
- 总所周知，oc中不像java,c++一样可以实现函数重载。overloadable属性允许定义多个同名但不同参数类型的函数，在调用时编译器会根据传入参数类型自动匹配函数。

```
NSString * __attribute__((overloadable)) mytest(NSString *x) {return @"aa";}
NSString * __attribute__((overloadable)) mytest(NSNumber *x) {return @"bb";}
NSString * __attribute__((overloadable)) mytest(NSDictionary *x) {return @"cc";}
NSString * __attribute__((overloadable)) mytest(int x) { return @"int"; }
NSString * __attribute__((overloadable)) mytest(double x) { return @"double"; }
NSString * __attribute__((overloadable)) mytest(long x) { return @"long"; }

  NSLog(@"%@",self.string);
    NSLog(@"%@",mytest(@(1)));
```

#### objc_runtime_name
- objc_runtime_name属性可以在编译时，将Class或Protocol指定为另一个名字，并且新名字不受命名规范制约，可以以数字开头
- 这个属性可以用来做代码混淆，例如写一个宏定义，宏定义内部实现混淆逻辑。

```
__attribute__((objc_runtime_name("123Object")))
@interface Object : NSObject
@end

NSLog(@"%@", NSStringFromClass([self class]));

执行结果：
123Object
```
#### cleanup
- 通过cleanup属性，可以指定给一个变量，当变量释放之前执行一个函数。指定的函数执行的时间，是在dealloc之前的。在指定的函数中，可以传入一个形参，参数就是cleanup修饰的变量，形参是一个地址。

```
#import <Foundation/Foundation.h>
static void releaseBefore(NSObject **object) {
    NSLog(@"%@", *object);
}

int main(int argc, const char * argv[]) {
    @autoreleasepool {
       NSObject *object __attribute__((cleanup(releaseBefore))) = [[NSObject alloc] init];
    }
    return 0;
}
```
- 如果遇到同一个代码块中，同时出现多个cleanup属性时，在代码块作用域结束时，会以添加的顺序进行调用

#### unused
- 还有一个属性很实用，在项目里经常会有未使用的变量，会报一个黄色警告。有时候可能会通过其他方式获取这个对象，所以不想出现这个警告，可以通过unused属性消除这个警告。

```
NSObject *object __attribute__((unused)) = [[NSObject alloc] init];
```
- 在系统里也大量使用了attribute关键字，只不过系统不会直接在外部使用attribute，一般都是将其定义为宏定义，以宏定义的形式出现在外面。

```
// NSLog
FOUNDATION_EXPORT void NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2) NS_NO_TAIL_CALL;
#define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))

// 必须调用父类的方法
#define NS_REQUIRES_SUPER __attribute__((objc_requires_super))

// 指定初始化方法，必须直接或间接调用修饰的方法
#define NS_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
```

### 23.请描述9种软件设计的原则，并分别描述你在设计一个SDK的时候是如果运用这些原则的 H
#### 单一职责原则
- 一个类，只做一件事。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责。这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。
- 例如：
    * CALayer：只做动画和视图的显示
    * UIView：只负责事件传递、事件响应
- 优点
    * 可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；
    * 可以提高类的可读性，提高系统的可维护性；
    * 变更引起的风险率降低，变更时必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。

#### 开闭原则
- 软件系统中包含的各种组件，例如模块、类以及功能等等，应该在不修改现有代码的基础上，引入新功能。开闭原则中“开”，是指对于组件功能的扩展是开放的，是允许对其进行功能扩展的；开闭原则中“闭”，是指对于原有代码的修改是封闭的，即不应该修改原有的代码。
- 新增功能用extension,category

#### 接口隔离原则
- 建立单一接口，不要建立臃肿庞大的接口。接口尽量细化，同时接口中的方法尽量少。
- 注意：
    * 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不争的事实，但是如果过小，则会造成接口数量过多，使设计复杂。所以一定要适度。
    * 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
    * 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。

#### 依赖倒置原则
- 依赖倒转原则就是要依赖于抽象，不要依赖于实现。也就是说应当使用接口和抽象类进行变量的类型声明、参数类型声明、方法返回类型说明，以及数据类型的转换等。
- 耦合（依赖）关系的种类
    * 零耦合关系：两个类没有耦合关系
    * 具体耦合关系：发生在两个具体的（可实例化的）类之间，经由一个类对另一个具体类的直接引用造成的。
    * 抽象耦合关系：发生在一个具体类和一个抽象类（或接口）之间，使两个必须发生关系的类之间存有最大的灵活性
- 应该尽可能的避免实现继承，原因如下:
    * 失去灵活性，使用具体类会给底层的修改带来麻烦。
    * 耦合问题，耦合是指两个实体相互依赖于对方的一个量度。程序员每天都在（有意识或者无意识地）做出影响耦合的决定：类耦合、API耦合、应用程序耦合等等。在一个用扩展的继承实现系统中，派生类是非常紧密的与基类耦合，而且这种紧密的连接可能是不被期望的。我们必须客观的评价耦合度，系统之间不可能总是松耦合的，那样肯定什么也做不了。
- 例如 
    * tableview 中的UITableviewDelegate ：含有的方法是UITableView的实例告知其代理一些点击事件的方法，即事件的传递，方向是从UITableView的实例到其代理。
    * tableview 中的 UITableViewDataSource：含有的方法是UITableView的代理传给UITableView一些必要数据供UITableView展示出来，即数据的传递，方向是从UITableView的代理到UITableView。

#### 里氏替换原则
- 里氏代换原则面向对象设计的基本原则之一。
- 父类可以被子类无缝替换且原有的功能不受任何影响
- 例：如KVO 的实现
- 4层含义
    * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
    * 子类中可以增加自己特有的方法。
    * 当子类的方法重载父类的方法时，方法的重置条件（即方法的形参）要比父类方法的输入参数更宽松。
    * 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更加严格。

#### 迪米特法则

- 一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块。一个类应该只和它的成员变量，方法的输入，返回参数中的类作交流，而不应该引入其他的类（间接交流）。扩展会相对容易。
- 这样对软件实体之间通信的限制。它要求限制软件实体之间通信的宽度和深度。
- 软件编程的总的原则：低耦合，高内聚。

#### 组合/聚合复用原则
- 要尽量的使用合成和聚合，而不是继承关系达到复用的目的。
- 该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。
- 组合/聚合复用优点
    * 新对象存取成分对象的唯一方法是通过成分对象的接口；
    * 这种复用是黑箱复用，因为成分对象的内部细节是新对象所看不到的；
    * 这种复用支持包装；
    * 这种复用所需的依赖较少；
    * 每一个新的类可以将焦点集中在一个任务上；
    * 这种复用可以在运行时动态进行，新对象可以使用合成/聚合关系将新的责任委派到合适的对象。
- 缺点
    * 通过这种方式复用建造的系统会有较多的对象需要管理

### 24.面向协议编程特点 H
- 即在程序设计中，不要以一个类开始设计，应该从一个协议开始，应抛弃之前OOP的对象设计理念，设计协议，这样不同的继承链之间也可以使用同一个协议。可以将协议看做一个组件，哪里需要哪里继承协议即可，而且协议是可以多继承的，iOS中的类只能单继承，这也是面向协议相对面向对象的一大优势。
- 我理解的OC和swift面向协议编程一个最大区别是OC的 Protocol 没有默认的实现，需要依赖具体的实现类实现协议定义的方法，而Swift2.0开始提供了Protocol + Extension，协议可以再 Extension中提供默认的实现，这样上层调用可以直接调用协议的默认实现。
- 严谨来说，OC不是一门面向协议编程的语言，因为 Protocol 只提供定义，而不提供实现，所以叫他 面向接口编程 更合适一些。

### 25.如何捕获iOS的Crash？如果捕获C++的Crash？如果捕获Switch的Crash？前端如何捕获JS的Crsh？Flutter如何捕获Crash？ H
#### iOS的Crash
- Crash的主要原因是你的应用收到了未处理的信号。未处理信号可能来源于三个地方：kernel、其他进程、以及App本身。
- crash异常也分为三种：
    * Mach异常：底层内核级异常。用户态的开发者可以直接通过Mach API设置thread，task，host的异常端口，来捕获Mach异常。
    * Unix信号：又称BSD信号。它是UNIX层的异常信号标准，通过方法threadsignal()将信号投递到出错线程。可以通过方法signal(x, SignalHandler)来捕获single。
    * NSException：应用级异常。它是未被捕获的Objective-C异常，导致程序向自身发送了SIGABRT信号而崩溃，对于未捕获的Objective-C异常，是可以通过try catch来捕获的，或者通过NSSetUncaughtExceptionHandler()机制来捕获。
- 三者的关系：
    * Mach异常是内核态的异常，属于底层异常。
    * 转换Unix信号是为了兼容更为流行的POSIX标准(SUS规范)，这样不必了解Mach内核也可以通过Unix信号的方式来兼容开发。
    * 因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用kill和pthread_kill)也首先沉下来被转换为Mach异常，再转换为Unix信号。
- Carsh传递流程：硬件产生信号或者kill或pthread_kill信号 --> Mach异常 --> Unix信号（SIGABRT）

##### Mach异常捕获
- 硬件处理器陷阱产生的信号被Mach层捕获
- Mach异常处理程序exception_triage()通过调用exception_deliver()首先尝试将异常抛给thread端口、然后尝试抛给task端口，最后再抛给host端口(默认端口),exception_deliver通过调用mach_exception_raise,触发异常；
- 异常在内核中以消息机制进行处理，通过task_set_exception_posrts()设置自定义的接收Mach异常消息的端口，相当于插入了一个exception处理程序。
- 实现：
    * mach异常以消息机制处理而不是通过函数调用，exception messages可以被转发到先前注册的Mach exception处理程序。这意味着你可以插入一个exception处理程序，而不干扰现有的无论是调试器或Apple's crash reporter。

##### Signal异常捕获
- Signal是Unix标准下的处理机制，让开发者不必关系底层内核相关。为了维护一个统一的机制，操作系统和用户尝试的信号首先被转换为Mach异常，然后再转换为信号(Signals)。
- Mach 异常在Mach层被捕获并抛出后，会在BSD层被catch_mach_exception_raise处理，并通过ux_exception()将异常转换为对应的UNIX信号，并通过threadsignal()将信号投递到出错线程，iOS中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的

##### NSException异常捕获
- NSException异常属于OC层异常。该异常在OC层如果有对应的NSException（OC异常），就转换成OC异常，OC异常可以在OC层得到处理；如果OC异常一直得不到处理，程序会强行发送SIGABRT信号中断程序。在OC层如果没有对应的NSException，就只能让Unix标准的signal机制来处理了。


### 26.Swift如果调用C代码
- swift通过工程的桥接文件，调用c的相关代码

### 27.Swift如何调用方法？C++如何调用方法？和OC的Runtime有什么区别？
- 区别：不是动态的编译就决定了

### 28.WKWebView都有那些坑
#### WKWebView 白屏问题
- 在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。
- 这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。
- 解决方案：
    * 借助 WKNavigtionDelegate
        * iOS 9以后 WKNavigtionDelegate 新增了一个回调函数：- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0));当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。
    * 检测 webView.title 是否为空
        * 可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。

#### WKWebView Cookie 问题
- WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。
- 目前的主要解决方案是：
    * WKWebView loadRequest 前，在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题；
    * 通过 document.cookie 设置 Cookie 解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题；但无法解决302请求的 Cookie 问题

#### WKWebView NSURLProtocol问题
- WKWebView 在独立于 app 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 WKWebView 上直接使用 NSURLProtocol 无法拦截请求。

#### WKWebView loadRequest 问题
- 在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：

#### WKWebView 页面样式问题
- 在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形，追踪后发现主要是H5页面高度值异常导致：
- 

#### WKWebView 截屏问题
- WKWebView 下通过 -[CALayer renderInContext:]实现截屏的方式失效，需要通过以下方式实现截屏功能：

```
@implementation UIView (ImageSnapshot) 
- (UIImage*)imageSnapshot { 
    UIGraphicsBeginImageContextWithOptions(self.bounds.size,YES,self.contentScaleFactor); 
    [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES]; 
    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext(); 
    UIGraphicsEndImageContext(); 
    return newImage; 
} 
@end
```
- 然而这种方式依然解决不了 webGL 页面的截屏问题，对webGL 页面的截屏结果不是空白就是纯黑图片。无奈之下，我们只能约定一个JS接口，让游戏开发商实现该接口，具体是通过 canvas getImageData()方法取得图片数据后返回 base64 格式的数据，客户端在需要截图的时候，调用这个JS接口获取 base64 String 并转换成 UIImage。

#### WKWebView crash问题
- 暂无

#### 视频自动播放
- WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。
- 
#### goBack API问题
- WKWebView 上调用 -[WKWebView goBack], 回退到上一个页面后不会触发window.onload()函数、不会执行JS。

#### 页面滚动速率
- WKWebView 需要通过scrollView delegate调整滚动速率：

```
- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView {
     scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;
}
```
参考：[WKWebView 那些坑](https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA)

### 29.iOS中的WebView如何优化
- 预加载
- 离线缓存

### 30.小程序是如何实现的
- 小程序的UI视图和逻辑处理是用多个webview实现的，逻辑处理的JS代码全部加载到一个Webview里面，称之为AppService，整个小程序只有一个，并且整个生命周期常驻内存，而所有的视图（wxml和wxss）都是单独的Webview来承载，称之为AppView。所以一个小程序打开至少就会有2个webview进程，正式因为每个视图都是一个独立的webview进程，考虑到性能消耗，小程序不允许打开超过5个层级的页面
- 通过 WKWebview的window.webkit.messageHandlers.NAME.postMessage实现微信navite代码里实现了两个handler消息处理器：
    * invokeHandler: 调用原生能力
    * publishHandler: 消息分发

#### AppService
- 可以理解AppService即一个简单的页面，主要功能是负责逻辑处理部分的执行

#### AppView
- 这里可以理解为h5的页面，提供UI渲染，底层提供一个WAWebview.js来提供底层的功能

### 31.JSPatch是如何实现的 H
- 热更新用到JSPatch的主要作用还是通过脚本修复一些线上bug，希望能够达到替换OC方法的目标。JSPatch的实现巧妙之处在于：利用了OC的消息转发机制。
- 直接通过OC代码去调用runtime的API，利用JS和OC两种语言的消息转发机制做了很优雅的实现，稍显不足的是JSPatch只能支持ios7及以上。
- OC的动态语言特性是在runtime system(全部用C实现，Apple维护了一份开源代码)上实现的，面向对象的Class和instance机制都是基于消息机制。我们平时认为的[object method]，正确的理解应该是[receiver sendMsg], 所有的消息发送会在编译阶段编译为runtime c函数的调用：_obj_sendMsg(id, SEL).
- 在JS运行环境中，需要解决两个问题，一个是OC类对象（objc_class）的获取，另一个就是使用对象提供的接口方法。
    * JSPatch在实现中是通过Require调用在JS环境下创建一个class同名对象（js形式），当向OC发送alloc接收消息之后，会将OC环境中创建的对象地址保存到这个这个js同名对象中，js本身并不完成任何对象的初始化。
    * JSPatch在JS环境中通过中心转发方式，所有OC方法的调用均是通过新增Object（js）原型方法_c(methodName)完成调用，在通过JavaScriptCore执行JS脚本之前，先将所有的方法调用字符替换
_c('method')的方式； 在_c函数中通过JSContex建立的桥接函数传入参数和返回参数即完成了调用；
- JS如何替换OC方法
    * JSPatch的主要作用还是通过脚本修复一些线上bug，希望能够达到替换OC方法的目标。JSPatch的实现巧妙之处在于：利用了OC的消息转发机制。
    * 替换原有selector的IMP实现为一个空的IMP实现，这样当objc_class接受到消息之后，就会进行消息转发, 另外需要将selector的初始实现进行保存；将替换的JS方法构造一个JPSelector及其IMP实现（根据返回参数构造），添加到当前class中，并通过cls＋selecotr全局缓存JS方法（全局缓存并没有多大用途，但是对于后面恢复现场比较有用）;
    * 然后改写每个替换方法类的forwadInvocation的实现进行拦截，如果拦截到的Invocation的selctor转化成JPSelector能够响应，说明是一个替换方法，则从Invocation中取参数后调用JPSelector的IMP；

### 32.请描述23种设计模式在iOS中的例子
#### 代理模式
- 为其他对象提供一种代理以控制对这个对象的访问。
- 场景：
    * 需要一个远程代理，为位于不同地址空间或网络中的对象提供本地代表。
    * 需要一个虚拟代理，来根据要求创建重型的对象。
    * 需要一个保护代理，来根据不同访问权限控制对原对象的访问。

#### 单例模式
- 保证一个类仅有一个实例，并提供一个访问他的全局访问点。
- 场景：
    * 类智能有一个实例，而且必须从一个为人熟知的访问点对其进行访问，比如工厂方法。
    * 这个唯一的实例只能通过自我进行扩展，而且扩展的对象不会破坏客户端代码。

#### 工厂模式
- 定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。
- 场景：
    * 编译时无法准确预期要创建的对象的类。
    * 类想要其子类决定在运行时创建什么。
    * 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。

#### 抽象工厂
- 提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。
- 抽象工厂对比工厂方法：
    * 抽象工厂通过对象组合创建抽象产品；创建多系列产品；必须修改父类的接口才能支持新的产品。
    * 工厂方法通过类继承创建抽象产品；创建一种产品；自泪花创建者并重载工厂方法以创建新产品。

#### 观察者模式
- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都将得到通知并被自动更新。
- 场景：
    * 有两个对象相互依赖。将它们封装在各自的对象中，就可以对它们单独进行改变和复用。
    * 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
    * 一个对象必须通知其他对象，而它又不需要知道其他对象是什么。

#### 中介者模式
- 用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
- 场景：
    * 对象间的交互虽定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解。
    * 因为对象引用了许多其他对象并与其通讯，导致对象难以复用。
    * 想要定制一个分布正在多个类中的逻辑或行为，又不想生成太多子类。

#### 建造者模式
- 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现。
- 场景：
    * 需要创建涉及各种总部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见例子是构建组合对象。
    * 构建过程需要以不同的方式构建对象。

#### 访问者模式
- 表示一个作用于某对象结构中的各元素的操作。它让我们可以再不改变各元素的类的前提下定义作用于这些元素的新操作。
- 场景：
    * 一个复杂的对象结构包含很多其他对象，他们有不同的接口（比如组合体），但是想对这些对象实施一些依赖于其具体类型的操作。
    * 需要对一个组合结构中的对象进行很多不相关的操作，但是不想让这些操作“污染”这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。
    * 定义复杂结构的类很少作修改，但经常需要向其添加新的操作。

#### 原型模式：
- 使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。
- 场景：
    * 需要创建的对象应独立于其类型与创建方式。
    * 要实例化的类实在运行时决定的。
    * 不想要与产品层次相对应的工厂层次。
    * 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。
    * 类不容易创建，不如每个组件可以把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。

#### 外观模式
- 为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更易于使用。
- 场景：
    * 子系统正逐渐变得复杂。应用模式的过程中演化出许多类。可以使用外观这些子系统类提供一个较简单的接口。
    * 可以使用外观对子系统进行分层。每个子系统级别有一个外观作为入口点。让它们通过其外观进行通信，可以简化它们的依赖关系。

#### 装饰模式
- 动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。
- 场景：
    * 想要在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
    * 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行自泪花；或者，对类的每个行为的扩展，为支持每种功能组合，将产生大量的子类。
    * 对类的职责的扩展是可选的。

#### 模板方法模式
- 定义一个操作中算法的骨架，而将一些不周延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。
- 场景：
    * 需要一次性实现算法的不变部分，并将可变的行为留给子类来实现。
    * 子类的共同行为应该被提取出来放到公共类中，以避免代码重复。现有代码的差别应该被分离为新的操作。然后用一个调用这些新操作的模板方法来替换这些不同的代码。
    * 需要控制子类的扩展。
    * 对具体类或者客户端类的具体操作。
    * 对抽象类的具体操作。
    * 抽象操作。
    * 工厂方法。
    * 钩子操作。

#### 适配器模式
- 将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
- 场景：
    * 已有类的接口与需求不匹配。
    * 想要一个可复用的类，该类能够同可能带有不兼容接口的其他类协作。
    * 需要适配一个类的几个不同子类，可以让没一个子类去子类化一个类适配器又不现实。那个可以使用对象适配器（也叫委托）来适配其父类的接口。

#### 迭代器模式
- 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
- 场景：
    * 需要访问组合对象的内容，而又不暴露其内部表示。
    * 需要通过多种方式遍历组合对象。
    * 需要提供一个统一的接口，用来遍历各种类型的组合对象。

#### 解释器模式


#### 桥接模式
- 将抽象部分与它的实现部分分离，使他们都可以独立的变化。
- 场景：
    * 不想在抽象与其实现之间形成固定的绑定关系（这样就能在运行时切换实现）。
    * 抽象及其实现都应可以通过子类化独立进行扩展。
    * 对抽象的实现进行修改不应影响客户端代码。
    * 如果每个实现需要额外的子类以细化抽象，则说明又还要把他们分成两个部分。
    * 想在带有不同抽象接口的多个对象之间共享一个实现。

#### 组合模式
- 将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。
- 场景：
    * 想要获得对象抽象的树形标识（部分-整体层次结构）。
    * 想让客户端统一处理组合结构中的所有对象。

#### 策略模式
- 定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。本模式使得算法可独立于使用它的客户而变化。
- 场景：
    * 一个类在其操作中使用多个条件语句来定义许多行为。我们可以把相关的条件分支移到他们自己的策略类中。
    * 需要算法的各种变体。
    * 需要避免把复杂的、与算法相关的数据结构暴露给客户端。

#### 责任链模式
- 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将这些对象连城一条链，并沿着这条链传递请求，知道有一个对象处理它为止。
- 场景：
    * 有多个对象可以处理请求，而处理程序只有在运行时才能确定。
    * 向一组对象发出请求，而不想显示指定处理请求的特定处理程序。

#### 命令模式
- 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
- 场景：
    * 想让应用程序支持撤销与恢复。享用对象参数化一个动作以执行操作，并用不同命令对象来代替回收函数。
    * 想要在不同时刻对请求进行制定、排序和执行。
    * 想记录修改日志，这样在系统故障时，这些修改可在后来重做一遍。
    * 想让系统支持事务（transaction），事务封装了对数据的一系列修改。事务可以建模为命令对象。

#### 享元模式
- 运用共享技术有小弟支持大量细力度的对象。
- 场景：
    * 应用程序使用很多对象。
    * 在内存中保存对象会影响内存性能。
    * 对象的多数特有状态可以放到外部而轻量化。
    * 移除了外在状态之后，可以用较少的共享对象替代原来的那组对象应用程序不依赖于对象标识，因为共享对象不同提供唯一的标识。

#### 备忘录模式
- 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
- 场景：
    * 需要保存一个对象（或某部分）在某一个时刻的状态，这样以后就可以恢复到先前的状态。
    * 用于获取状态的接口会暴露实现的细节，需要将其隐藏起来。

#### 状态模式
- 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
- 场景：
    * 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。
    * 代码中包含大量与对象状态有关的条件语句。

### 33.在设计插件的时候，应该如何运用23中设计模式？

### 34.如何保证iOS App的安全
- 首先，我们可以通过iTunes 下载 AppStore的ipa文件(苹果 把开发者上传的ipa包 进行了加壳再放到AppStore中)，所以我们从AppStore下载的ipa都是加壳的，所以不能直接用来反编译。得到ipa文件 可以分析APP 里包含的一些资源，如：图片、plist文件、静态wap页、.bundle 等。所以不要 在plist文件、项目中的静态文件中 存储关键的信息，如果要保存，记得 对称加密（这样可以增加破解的难度）。如果是越狱的手机，从 手机上的PP助手下载的ipa包 都是 脱壳之后的，可以直接用来反编译。
- 我们可以用软件 查看 APP的沙盒，查看里面存储的 文件:sqlite、plist（NSUserdefault会存到Library下的Preferences中 的 plist文件中）、图片等，NSUserdefault 中不要保存关键信息，如果要保存，还是加密吧。。sqlite也是这样子的。iOS 8.3之前 不越狱的手机也可以 直接用MAC上的PP助手、iTool 来查看 任何APP的沙盒（系统APP除外）。iOS 8.3之后就不行了。越狱手机 都可以查看任意APP的沙盒，包括系统APP的沙盒。还有iOS的系统目录等。
- 越狱手机 直接用PP助手下载的就是 脱壳的ipa，所以不用再脱了。对AppStore下载的ipa包 可以用工具对加壳的ipa 进行脱壳，再用IDA、Hopper 进行反编译，进行分析 ，可以得到 近乎易懂的 伪代码。但是反编译后的代码 要 一个方法一个方法的去分析，类似面向过程编程。当然也有工具 去提取 项目中的所有.h文件。
- 所有的APP都是可以反编译的，所以 很关键的数据 最好通过接口获取。那么接口如何保证安全呢。首先用HTTPS，虽然HTTPS已经很安全了，但是数据也是有可能被破解的，这个后面会介绍。所以 接口一定要自己加密。非对称加密(RSA)现在 还是没有办法破解的，但是因为 非对称加密的效率低，所以很少有企业将所有的接口都用非对称加密。接口如果用对称加密，密钥 放到代码里 是能被反编译出来的。如果你的 APP的安全性很高，就不要把密钥 写到代码里。可以这样处理：先通过非对称加密的接口 获取密钥，然后 再在 后面的 接口通信中 用这个密钥进行加密。这样做 就类似 HTTPS 的简化版实现了。安全性很高。目前应该 是不能破解的。
- 根据APP的安全性，也可以把 关键数据 写在代码里，可以保存的是加密后的数据。比如，我给一个变量赋值：U2FsdGVkX1+rN+sgpLmOYTqoVhRRerZj9oobZAIPzjo=，你不知道 我这个字符串解密后是 123456，我只是使用的时候才解密处理用。这样也只是 增加了 黑客获取 关键数据的难度。
- 密钥要定期更换。
- 最好能 进行 代码混淆，能增加反编译的难度，当然只是增加了难度，还是能破解的。
- 接口返回的数据 最好也进行 加密。

### 35.如何做iOS逆向

### 36.请列举Unix信号
- SIGABRT：（sigabrt）由调用abort函数产生，进程非正常退出
- SIGALRM：（sigalrm）用alarm函数设置的timer超时或setitimer函数设置的interval timer超时
- SIGBUS：（sigbus）某种特定的硬件异常，通常由内存访问引起
- SIGCANCEL：（sigcancel）由Solaris Thread Library内部使用，通常不会使用
- SIGCHLD：（sigchld）进程Terminate或Stop的时候，SIGCHLD会发送给它的父进程。缺省情况下该Signal会被忽略
- SIGCONT：（sigcont）当被stop的进程恢复运行的时候，自动发送
- SIGEMT：（sigemt）和实现相关的硬件异常
- SIGFPE：（sigfpe）数学相关的异常，如被0除，浮点溢出，等等
- SIGFREEZE：（sigfreeze）Solaris专用，Hiberate或者Suspended时候发送
- IGHUP：（ighup）发送给具有Terminal的Controlling Process，当terminal被disconnect时候发送
- SIGILL：（sigill）非法指令异常
- SIGINFO：（siginfo）BSD signal。由Status Key产生，通常是CTRL+T。发送给所有Foreground Group的进程
- SIGINT：（sigint）由Interrupt Key产生，通常是CTRL+C或者DELETE。发送给所有ForeGround Group的进程
- SIGIO：（sigio）异步IO事件
- SIGIOT：（sigiot）实现相关的硬件异常，一般对应SIGABRT
- SIGKILL：（sigkill）无法处理和忽略。中止某个进程
- SIGLWP：（siglwp）由Solaris Thread Libray内部使用
- SIGPIPE：（sigpipe）在reader中止之后写Pipe的时候发送
- SIGPOLL：（sigpoll）当某个事件发送给Pollable Device的时候发送
- SIGPROF：（sigprofSetitimer）指定的Profiling Interval Timer所产生
- SIGPWR：（sigpwr）和系统相关。和UPS相关。
- SIGQUIT：（sigquit）输入Quit Key的时候（CTRL+\）发送给所有Foreground Group的进程
- SIGSEGV：（sigsegv）非法内存访问
- SIGSTKFLT：（sigstkfltLinux）专用，数学协处理器的栈异常
- SIGSTOP：（sigstop）中止进程。无法处理和忽略。
- SIGSYS：（sigsys）非法系统调用
- SIGTERM：sigterm请求中止进程，kill命令缺省发送
- SIGTHAW：（sigthaw）Solaris专用，从Suspend恢复时候发送
- SIGTRAP：（sigtrap）实现相关的硬件异常。一般是调试异常
- SIGTSTP：（sigtstp）Suspend Key，一般是Ctrl+Z。发送给所有Foreground Group的进程
- SIGTTIN：（sigttin）当Background Group的进程尝试读取Terminal的时候发送
- SIGTTOU：（sigttou）当Background Group的进程尝试写Terminal的时候发送
- SIGURG：（sigurg）当out-of-band data接收的时候可能发送
- SIGUSR1：（sigusr1）用户自定义signal 1
- SIGUSR2：（sigusr2）用户自定义signal 2
- SIGVTALRM：（sigvtalrm）setitimer函数设置的Virtual Interval Timer超时的时候
- SIGWAITING：（sigwaiting）Solaris Thread Library内部实现专用
- SIGWINCH：（sigwinch）当Terminal的窗口大小改变的时候，发送给Foreground Group的所有进程
- SIGXCPU：（sigxcpu）当CPU时间限制超时的时候
- SIGXFSZ：（sigxfsz）进程超过文件大小限制

### 37.请列举Swift常用的关键字和用法（比如final、lazy等）
- 用作声明的关键字：
    * let：声明静态变量，类似于const，用let声明的变量不可以再赋值，不然会报错；
    * var：声明变量，是可以改变值；
    * class：用来声明一个类；
    * enum：用来声明一个枚举；
    * func：用来定义函数
    * init：相对于类的构造方法的修饰；
    * deinit：属于析构函数。析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数，和OC中的dealloc 一样的
    * extension：扩展，类似于OC的categories
    * enum：枚举
    * import：导入头文件
    * protocol： 协议
    * static：声明静态变量或者函数
    * struct： 声明定义一个结构体
    * subscript：下标索引修饰.可以让class、struct、以及enum使用下标访问内部的值
    * typealias：为此类型声明一个别名.和 typedef类似.
    * override：如果我们要重写某个方法, 或者某个属性的话, 我们需要在重写的变量前增加一个override关键字
    * final：用来修饰 class、func、var。表示被修饰的对象无法被继承。
- 用作语句的关键字：
    * break：跳出循环.一般在控制流中使用,比如 for . while switch等语句
    * case：switch的选择分支.
- lazy：我们在变量属性前加lazy关键字来指定延迟加载。
- inout:inout作为函数声明时,引用传值的关键字。但是在调用的时候引用的是地址,所以在引用的时候要加上&