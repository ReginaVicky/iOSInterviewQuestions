# iOSInterviewQuestion
## 微博@Liberalisman面试知识点总结（附答案）
- 03《微博@Liberalisman面试知识点总结》，面试题来源是微博[@Liberalisman](https://weibo.com/1743643682/)的面试题知识点总结；
- 如有纰漏，请向微博[@爱吃兔兔的胡萝卜吖](https://weibo.com/6447187962/)反馈。

### 推荐书目
- 1.《Effective Objective-C 2.0》
- 2.《Objective-C 高级编程》
- 3.《程序员的自我修养》
- 4.《图解HTTP》
- 5.《高性能iOS应用开发》
- 6.《算法图解》
- 7.《剑指Offer》）

# 索引
## 数据结构及算法

## 数据结构
- 1.[数据结构](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1数据结构)
    * 1.[数据结构的存储一般常用的有几种？各有什么特点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1数据结构的存储一般常用的有几种各有什么特点)
    * 2.[集合结构 线性结构 树形结构 图形结构](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2集合结构-线性结构-树形结构-图形结构)
- 2.[数组](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2数组)
    * 1.[数组和链表的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1数组和链表的区别)
- 3.[字符串](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3字符串)
    * 1.[字符匹配 & 字符去重](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1字符匹配--字符去重)
- 4.[链表](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4链表)
    * 1.[单向链表 双向链表 循环链表](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1单向链表-双向链表-循环链表)
- 5.[树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5树)
    * [二叉树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#二叉树)
        * [基本概念](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#基本概念-1)
        * [分类](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#分类)
        * [存储结构](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#存储结构)
        * [二叉查找树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#二叉查找树)
        * [遍历顺序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#遍历顺序)
    * [二叉搜索树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#二叉搜索树)
        * 1.[输入一棵二叉树的根结点，求该树的深度？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1输入一棵二叉树的根结点求该树的深度)
        * 2.[输入一课二叉树的根结点，判断该树是不是平衡二叉树？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2输入一课二叉树的根结点判断该树是不是平衡二叉树)
    * [红黑树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#红黑树)
- 6.[栈](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6栈)
    * 1.[堆、栈和队列 分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1堆栈和队列-分别是什么)
- 7.[队列](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7队列)
- 8.[哈希表（有哪些功能是通过哈希表实现的）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8哈希表有哪些功能是通过哈希表实现的)



### 算法
#### 基本概念
- [时间复杂度](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#时间复杂度)
- [空间复杂度](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#空间复杂度)

#### 常见的摘要算法
- [HEX编码](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#hex编码/)
- [Base64](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#base64)
- [MD5](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#md5)
- [SHA1](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#sha1)
- [SHA256](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#sha256)
- [MAC算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#mac算法)

#### 常见对称加密算法
- [AES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#aes)
- [DES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#des)
- [3DES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3des)
- [Blowfish](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#--blowfish)

#### 常见的排序算法
- [插入排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#插入排序)
- [快速排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#快速排序)
- [堆排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#堆排序)
- [冒泡排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#冒泡排序)
- [选择排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#选择排序)
- [希尔排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#希尔排序)
- [归并排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#归并排序)
- [基数排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#基数排序)

#### 常见的字符编码方法
- [ASCII](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#ascii)
- [ISO-8859-1](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#iso-8859-1)
- [GB2312](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#gb2312)
- [GBK](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#gbk)
- [UTF-8](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#utf-8)
- [UTF-16](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#utf-16)
- [Unicode](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#unicode)

[推荐一个很好的算法总结](https://github.com/CyC2018/Interview-Notebook)

### 常考算法题
- 1.[字符串反转](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1字符串反转)
- 2.[链表反转](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2链表反转)
- 3.[有序数组合并](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3有序数组合并)
- 4.[假设某个数组中只有数字1和2，进行排序，使得数字 1位于数组前部分，数字2位于后部分](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4假设某个数组中只有数字1和2进行排序使得数字1位于数组前部分数字2位于后部分)
- 5.[查找第一个只出现一次的字符](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5查找第一个只出现一次的字符)
- 6.[查找两个子视图的共同父视图](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6查找两个子视图的共同父视图)
- 7.[无序数组中的中位数](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7无序数组中的中位数)
- 8.[两数之和为特定值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8两数之和为特定值)
- 9.[求出数组中连续数字的和值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9求出数组中连续数字的和值)
- 10.[白鼠与毒酒的算法问题](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10白鼠与毒酒的算法问题)
- 11.[背包问题](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11背包问题)
- 补充：[多重背包问题](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充多重背包问题)
- 补充：[完全背包问题](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充完全背包问题/)
- 12.[实现数组的随机排序（含洗牌算法）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12实现数组的随机排序含洗牌算法)
- [补充：洗牌算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充洗牌算法)
- 13.[在一个数组中找出前四个最大的数字](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13在一个数组中找出前四个最大的数字)
- 14.[最小的K个数，输入n个整数，找出其中最小的K个数](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14最小的k个数输入n个整数找出其中最小的k个数)
- 15.[找出数组中第 k 大的数字及其出现次数](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15找出数组中第-k-大的数字及其出现次数)
- 16.[假如有 10亿 条数据，每条数据的大小在 10k-100k 之间，我们有一台内存为4G的电脑，如何算出播放次数最多的一条微博？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16假如有-10亿-条数据每条数据的大小在-10k-100k-之间我们有一台内存为4g的电脑如何算出播放次数最多的一条微博)
- 17.[如何打印一个矩阵](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17如何打印一个矩阵)
- 18.[如何验证一个 IP 地址的有效性](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18如何验证一个-ip-地址的有效性)
- 19.[栈中储存着一组无序的数字，不用遍历的方式，如何找出最小值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19栈中储存着一组无序的数字不用遍历的方式如何找出最小值)
- 20.[二维数组查找一个值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20二维数组查找一个值)
- 21.[有一个很大的整形数据，转成二进制求1的个数](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21有一个很大的整形数据转成二进制求1的个数/)
- 22.[判断一个正数是否是2的乘方](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22判断一个正数是否是2的乘方)
- 23.[缓存淘汰算法 LRU 和 LFU](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23缓存淘汰算法-lru-和-lfu)
- 24.[LRU缓存机制](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24lru缓存机制)
- 25.[行间的换页算法有哪些](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25行间的换页算法有哪些)
- 26.[山脉数组找目标值(要求logN的时间复杂度)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26山脉数组找目标值要求logn的时间复杂度)
- 27.[给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27给定一个非空整数数组除了某个元素只出现一次以外其余每个元素均出现两次找出那个只出现了一次的元素)
- 补充：有一个a[1000]的数组，存放1-1000的数，现在有一个数重复了，用一个时间复杂度为N的算法找到重复的数值
- 28.[100层楼，扔两个鸡蛋，寻找使鸡蛋摔碎的楼层最快要扔多少次？（Google经典的面试题，有一个100层的楼，你手里现在有两个一模一样的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28100层楼扔两个鸡蛋寻找使鸡蛋摔碎的楼层最快要扔多少次google经典的面试题有一个100层的楼你手里现在有两个一模一样的鸡蛋它们有可能都在一楼就摔碎也可能从一百层楼摔下来没事要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置)
- 29.[数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。或者是问：给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29数组中有一个数字出现的次数超过数组长度的一半请找出这个数字例如输入一个长度为9的数组123222542由于数字2在数组中出现了5次超过数组长度的一半因此输出2如果不存在则输出0或者是问给定一个大小为n的数组找到其中的众数众数是指在数组中出现次数大于--n2--的元素)
- 30.[怎么判断一条链表有环](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#30怎么判断一条链表有环)
- 31.[求数组的最长子数组](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#31求数组的最长子数组)
- 32.[回文算法，最长回文子串之 Manacher 算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#32回文算法最长回文子串之-manacher-算法)
- 33.[判断一个字符串是不是对称的字符串，比如 abba 或者 aba 这样的就是对称的。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#33判断一个字符串是不是对称的字符串比如-abba-或者-aba-这样的就是对称的)
- 34.[hash 算法的原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#34hash-算法的原理)
- 35.[二叉树逐层打印](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#35二叉树逐层打印)
- 36.[找出一个页面中漏出部分面积最大的试图，重合的部分按照最上层的面积算漏出](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#36找出一个页面中漏出部分面积最大的试图重合的部分按照最上层的面积算漏出)
- 37.[一个坦克从一个空间的起点到终点，中间在某些位置上有阻隔的情况下，判断从起点到终点是否有可行路径。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#37一个坦克从一个空间的起点到终点中间在某些位置上有阻隔的情况下判断从起点到终点是否有可行路径)
- 38.[二叉树翻转，将二叉树的两个孩子换位置，即左变右，右变左。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#38二叉树翻转将二叉树的两个孩子换位置即左变右右变左)


## UIKit
- 1.[UIView 和 CALayer 是什么关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1uiview-和-calayer-是什么关系)
- 2.[Bounds 和 Frame 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2bounds-和-frame-的区别)
- 3.[TableViewCell 如何根据 UILabel 内容长度自动调整高度?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3tableviewcell如何根据uilabel内容长度自动调整高度)
- 4.[LoadView方法了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4loadview方法了解吗)
- 5.[UIButton 的父类是什么？UILabel 的父类又是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5uibutton-的父类是什么uilabel-的父类又是什么)
- [补充：UIButton防止多次点击](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充uibutton防止多次点击)
- 6.[IBOutlet连出来的视图属性为什么可以被设置成weak?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6iboutlet连出来的视图属性为什么可以被设置成weak)
- 7.[IB中User Defined Runtime Attributes如何使用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7ib中user-defined-runtime-attributes如何使用)
- 8.[实现一个控件，可以浮在任意界面的上层并支持拖动？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8实现一个控件可以浮在任意界面的上层并支持拖动)
- 9.[说一下控制器View的生命周期，一旦收到内存警告会如何处理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9说一下控制器view的生命周期一旦收到内存警告会如何处理)
- 10.[说一下 UIView 的生命周期？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10说一下-uiview-的生命周期)
- 11.[说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11说一下appdelegate的几个方法从后台到前台调用了哪些方法第一次启动调用了哪些方法从前台到后台调用了哪些方法)
- 12.[如何暂停一个 UIView 中正在播放的动画？暂停后如何恢复？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12如何暂停一个-uiview-中正在播放的动画暂停后如何恢复)
- 13.[如何以通用的方法找到当前显示的ViewController?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13如何以通用的方法找到当前显示的viewcontroller)
- 14.[如何在多次presentViewController后直接返回到指定层](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14如何在多次presentviewcontroller后直接返回到指定层)
- 15.[如何通过视图(view)获取该视图所在的控制器(viewController)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15如何通过视图view获取该视图所在的控制器viewcontroller)
- 16.[setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16setneedsdisplay-和-layoutifneeded-两者是什么关系)
- 17.[什么情况下会调用layoutSubviews ？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17什么情况下会调用layoutsubviews-)
- 18.[什么情况会调用draw rect方法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18什么情况会调用draw-rect方法)
- 19.[多个类型的cell如何优雅加载？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19多个类型的cell如何优雅加载)
- 20.[UICollectionView自定义layout如何实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20uicollectionview自定义layout如何实现)
- 21.[用StoryBoard开发界面有什么弊端？如何避免？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21用storyboard开发界面有什么弊端如何避免)
- 22.iOS滑块验证
- 23.控件的点击事件和添加在上边的手势谁先响应，并说明原因
- CoreAnimation 和 CoreGraphic 的区别



## Foundation
- 1.[nil`、`NIL`、`NSNULL` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1nilnilnsnull-有什么区别)
- 2.[如何实现一个线程安全的 `NSMutableArray`?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2如何实现一个线程安全的-nsmutablearray)
- 3.[如何定义一台 iOS 设备的唯一性?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3如何定义一台-ios-设备的唯一性)
- 4.[atomic` 修饰的属性是绝对安全的吗？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4atomic-修饰的属性是绝对安全的吗为什么)
- 5.[实现 `isEqual` 和 `hash` 方法时要注意什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5实现-isequal-和-hash-方法时要注意什么)
- 6.[`id` 和 `instanceType` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6id-和-instancetype-有什么区别)
- 7.[简述事件传递、事件响应机制。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7简述事件传递事件响应机制)
- 8.[说一下对 `Super` 关键字的理解。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8说一下对-super-关键字的理解)
- 9.[了解 逆变 和 协变 吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9了解-逆变-和-协变-吗)
- 10.[`@synthesize` 和 `@dynamic` 分别有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10synthesize-和-dynamic-分别有什么作用)
- 11.[Obj-C 中的反射机制了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11obj-c-中的反射机制了解吗)
- 12.[`typeof` 和 `__typeof`，`typeof` 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12typeof-和-__typeoftypeof-的区别)
- [补充：self + weakSelf + strongSelf ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充self--weakself--strongself-)
- 13.[头文件导入的方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13头文件导入的方式)
- 14.[如何将 Obj-C 代码改变为 C++/C 的代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14如何将-obj-c-代码改变为-cc-的代码)
- 15.[知不知道在哪里下载苹果的源代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15知不知道在哪里下载苹果的源代码)
- 16.[objc_getClass()、object_getClass()、Class 这三个方法用来获取类对象有什么不同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16objc_getclassobject_getclassclass-这三个方法用来获取类对象有什么不同)
- 17.[NSCache优于NSDictionary的几点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17nscache优于nsdictionary的几点)
- [补充：NSCache，NSDictionary，NSArray的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充nscachensdictionarynsarray的区别)
- 18.[知不知道DesignatedInitializer？使用它的时候有什么需要注意的问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18知不知道designatedinitializer使用它的时候有什么需要注意的问题)
- 19.[实现description方法能取到什么效果？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19实现description方法能取到什么效果)


## iOS 内存管理
- [补充：为什么说Objective-C是一门动态的语言？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充为什么说objective-c是一门动态的语言)
- 1.[说一下对 retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下对-retaincopyassignweak_unsafe_unretain-关键字的理解)
- 2.[简述下列属性的作用：readwrite、readonly、assign、retain、copy、nonatomic、weak、strong](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2简述下列属性的作用readwritereadonlyassignretaincopynonatomicweakstrong)
- 补充：assign 修饰对象可能存在的问题
- 3.[automic的实现机制；](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3automic的实现机制)
- 4.[atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4atomic是绝对的线程安全么为什么如果不是那应该如何实现)
- 5.[@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5property-的本质是什么ivargettersetter-是如何生成并添加到这个类中的)
- 6.[@property 后面可以有哪些修饰符？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6property-后面可以有哪些修饰符)
- 7.[@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7property中有哪些属性关键字-property-后面可以有哪些修饰符)
- 8.[什么情况使用 weak 关键字，相比 assign 有什么不同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8什么情况使用-weak-关键字相比-assign-有什么不同)
- 9.[@protocol 和 category 中如何使用 @property](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9protocol-和-category-中如何使用-property)
- 10.[__weak 和 _Unsafe_Unretain 的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10__weak-和-_unsafe_unretain-的区别)
- 11.[_weak 属性修饰的变量，如何实现在变量没有强引用后自动置为 nil](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11_weak-属性修饰的变量如何实现在变量没有强引用后自动置为-nil)
- 12.[runtime如何实现weak变量的自动置nil？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12runtime如何实现weak变量的自动置nil)
- 13.[weak属性需要在dealloc中置nil么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13weak属性需要在dealloc中置nil么)
- 14.[runtime 如何实现 weak 属性](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14runtime-如何实现-weak-属性)
- 15.[怎么用 copy 关键字？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15怎么用-copy-关键字)
- 16.[如何令自己所写的对象具有拷贝功能?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16如何令自己所写的对象具有拷贝功能)
- 17.[这个写法会出什么问题： @property (copy) NSMutableArray *array;](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17这个写法会出什么问题-property-copy-nsmutablearray-array)
- 18.[用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18用property声明的nsstring或nsarraynsdictionary经常使用copy关键字为什么如果改用strong关键字可能造成什么问题)
- 19.[如何让自己的类用copy修饰符？如何重写带 copy 关键字的 setter？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19如何让自己的类用copy修饰符如何重写带-copy-关键字的-setter)
- 20.[是否了解深拷贝和浅拷贝的概念，集合类深拷贝如何实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20是否了解深拷贝和浅拷贝的概念集合类深拷贝如何实现)
- 21.[完全深拷贝和不完全深拷贝](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21完全深拷贝和不完全深拷贝)
- 22.[内存管理默认的关键字是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22内存管理默认的关键字是什么)
- 23.[内存中的5大区分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23内存中的5大区分别是什么)
- 24.[iOS程序内存的每个分区怎么存储（举例说明）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24ios程序内存的每个分区怎么存储举例说明)
- 25.[代码区存储的是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25代码区存储的是什么)
- 26.[什么是虚拟内存，虚拟内存和物理内存的关系和区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26什么是虚拟内存虚拟内存和物理内存的关系和区别)
- 27.[block一般存在哪里（分ARC和MRC）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27block一般存在哪里分arc和mrc)
- 28.[讲一下 `iOS` 内存管理的理解？(三种方案的结合)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28讲一下-ios-内存管理的理解三种方案的结合)
- [补充：对象引用计数放哪里？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充对象引用计数放哪里)
- 29.[使用自动引用计（ARC）数应该遵循的原则?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29使用自动引用计arc数应该遵循的原则)
- 30.[ARC 自动内存管理的原则?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#30arc-自动内存管理的原则)
- 31.[ARC 的 retainCount 怎么存储的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#31arc-的-retaincount-怎么存储的)
- 32.[ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#32arc下不显式指定任何属性关键字时默认的关键字都有哪些)
- 33.[ARC通过什么方式帮助开发者管理内存？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#33arc通过什么方式帮助开发者管理内存)
- 34.[ARC 在编译时做了哪些工作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#34arc-在编译时做了哪些工作)
- 35.[ARC 在运行时做了哪些工作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#35arc-在运行时做了哪些工作)
- 36.[简要说一下 @autoreleasePool 的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#36简要说一下-autoreleasepool-的数据结构)
- 37.[@autoreleasrPool 的释放时机？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#37autoreleasrpool-的释放时机)
- 38.[为什么已经有了 ARC ,但还是需要 @AutoreleasePool 的存在？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#38为什么已经有了-arc-但还是需要-autoreleasepool-的存在)
- 39.[函数返回一个对象时，会对对象 autorelease 么？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#39函数返回一个对象时会对对象-autorelease-么为什么)
- 40.[realease作用是什么和 autorelease 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#40realease作用是什么和-autorelease-有什么区别)
- 41.[不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#41不手动指定autoreleasepool的前提下一个autorealese对象在什么时刻释放比如在一个vc的viewdidload中创建)
- 42.[访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#42访问-__weak-修饰的变量是否已经被注册在了-autoreleasepool-中为什么)
- 43.[在OC里 alloc 和 retain 语义相反的方法是？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#43在oc里-alloc-和-retain-语义相反的方法是)
- 44.[retain、release 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#44retainrelease-的实现机制)
- 45.[能不能简述一下 Dealloc 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#45能不能简述一下-dealloc-的实现机制)
- 46.[在 MRC 下如何重写属性的 Setter 和 Getter?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#46在-mrc-下如何重写属性的-setter-和-getter)
- 47.[讲一下 @dynamic 关键字？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#47讲一下-dynamic-关键字)
- 48.[@synthesize和@dynamic分别有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#48synthesize和dynamic分别有什么作用)
- 49.[@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#49synthesize合成实例变量的规则是什么假如property名为foo存在一个名为_foo的实例变量那么还会自动合成新变量么)
- 50.[在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#50在有了自动合成属性实例变量之后synthesize还有哪些使用场景)
- 补充：说 @synchronized 锁的实现原理，并说明其中可能存在的问题。
- 51.[说一下什么是 悬垂指针？什么是 野指针?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#51说一下什么是-悬垂指针什么是-野指针)
- 52.[objc中向一个nil对象发送消息将会发生什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#52objc中向一个nil对象发送消息将会发生什么)
- 53.[objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#53objc中向一个对象发送消息obj-foo和objc_msgsend函数之间有什么关系)
- 54.[BAD_ACCESS 在什么情况下出现?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#54bad_access-在什么情况下出现)
- 55.[什么时候会报unrecognized selector的异常？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#55什么时候会报unrecognized-selector的异常)
- 56.[objc使用什么机制管理对象内存？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#56objc使用什么机制管理对象内存)
- 57.[一个objc对象如何进行内存布局？（考虑有父类的情况）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#57一个objc对象如何进行内存布局考虑有父类的情况)
- 58.[一个objc对象的isa的指针指向什么？有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#58一个objc对象的isa的指针指向什么有什么作用)
- 59.[能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#59能否向编译后得到的类中增加实例变量能否向运行时创建的类中添加实例变量为什么)
- 60.[在Obj-C中，如何检测内存泄漏？你知道哪些方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#60在obj-c中如何检测内存泄漏你知道哪些方式)

## Runtime
- 1.[实例对象的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1实例对象的数据结构)
- 2.[类对象的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2类对象的数据结构)
- 3.[元类对象的数据结构?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3元类对象的数据结构)
- 4.[Obj-C 对象、类的本质是通过什么数据结构实现的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4obj-c-对象类的本质是通过什么数据结构实现的)
- 5.[类方法和实例方法有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5类方法和实例方法有什么区别)
- 6.[Obj-C 中的类信息存放在哪里？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6obj-c-中的类信息存放在哪里)
- 7.[一个 NSObject 对象占用多少内存空间？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7一个-nsobject-对象占用多少内存空间)
- 8.[说一下对 class_rw_t 的理解？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8说一下对-class_rw_t-的理解)
- 9.[说一下对 class_ro_t 的理解？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9说一下对-class_ro_t-的理解)
- 10.[介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10介绍一下分类能用分类做什么内部是如何实现的它为什么会覆盖掉原来的方法)
- 11.[Category 的实现原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11category-的实现原理)
- 12.[如何给 Category 添加属性？关联对象以什么形式进行存储？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12如何给-category-添加属性关联对象以什么形式进行存储)
- 13.[Category 有哪些用途？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13category-有哪些用途)
- 14.[Category 中都可以添加哪些内容？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14category-中都可以添加哪些内容)
- 15.[Category的优缺点](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15category的优缺点)
- 16.[Category 和 Extension 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16category-和-extension-有什么区别)
- 17.[Category 可不可以添加实例对象？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17category-可不可以添加实例对象为什么)
- 18.[Category不能添加实例变量，那为什么能添加属性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18category不能添加实例变量那为什么能添加属性)
- 19.[Category 在编译过后，是在什么时机与原有的类合并到一起的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19category-在编译过后是在什么时机与原有的类合并到一起的)
- 20.[分类实现了类的initialize方法，那么类的方法initialize还会调用吗？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20分类实现了类的initialize方法那么类的方法initialize还会调用吗为什么)
- 21.[分类与类中同样方法，调用顺序？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21分类与类中同样方法调用顺序)
- 22.[分类的对象方法是如何添加到类对象方法列表中的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22分类的对象方法是如何添加到类对象方法列表中的)
- 23.[memmove和memcpy的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23memmove和memcpy的区别)
- 24.[分类和类拓展的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24分类和类拓展的区别)
- 25.[动态库和静态库的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25动态库和静态库的区别)
- 26.[category 中有load 方法吗？ load 方法什么时候调用？ load 方法能继承吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26category-中有load-方法吗-load-方法什么时候调用-load-方法能继承吗)
- 27.[+load 和 initialized方法的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27load-和-initialized方法的区别)
- 28.[+load的调用时机](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28load的调用时机)
- 29.[+load分类中的处理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29load分类中的处理)
- 30.[分类和类别的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#30分类和类别的区别)
- 31.[关联对象的原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#31关联对象的原理)
- 32.[说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#32说一下-method-swizzling-说一下在实际开发中你在什么场景下使用过)
- 33.[如何实现动态添加方法和属性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#33如何实现动态添加方法和属性)
- 34.[运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#34运行时能增加成员变量么能增加属性么如果能如何增加如果不能为什么)
- 35.[说一下对 isa 指针的理解， 对象的isa 指针指向哪里？isa 指针有哪两种类型？（注意区分不同对象）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#35说一下对-isa-指针的理解-对象的isa-指针指向哪里isa-指针有哪两种类型注意区分不同对象)
- 36.[objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#36objc中向一个nil对象发送消息将会发生什么返回值是对象是标量结构体)
- 37.[利用Runtime交换方法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#37利用runtime交换方法)
- 38.[说一下 Runtime 消息发送。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#38说一下-runtime-消息发送)
- 39.[说一下 Runtime 消息解析。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#39说一下-runtime-消息解析)
- 40.[说一下 Runtime 消息转发。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#40说一下-runtime-消息转发)
- 41.[如何运用 Runtime 字典转模型？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#41如何运用-runtime-字典转模型)
- 42.[如何运用 Runtime 进行模型的归解档？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#42如何运用-runtime-进行模型的归解档)
- 43.[在 Obj-C 中为什么叫发消息而不叫函数调用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#43在-obj-c-中为什么叫发消息而不叫函数调用)
- 44.[说一下对 runtime 的理解。（主要讲一下消息机制，是对上述的总结）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#44说一下对-runtime-的理解主要讲一下消息机制是对上述的总结)
- 45.[说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#45说一下-runtime-的方法缓存存储的形式数据结构以及查找的过程)
- 46.[是否了解 Type Encoding?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#46是否了解-type-encoding)
- 47.[Objective-C 如何实现多重继承？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#47objective-c-如何实现多重继承)
- 48.[runtime如何通过selector找到对应的IMP地址？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#48runtime如何通过selector找到对应的imp地址)
- 49.[runtime具体应用](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#49runtime具体应用)
- 50.[使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#50使用runtime-associate方法关联的对象需要在主对象dealloc的时候释放么)
- 51.[runtime如何实现weak变量的自动置nil？知道SideTable吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#51runtime如何实现weak变量的自动置nil知道sidetable吗)

## Runloop
- 1.[RunLoop概念](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1runloop概念)
- [补充：内核态和用户态](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充内核态和用户态)
- 2.[RunLoop的数据结构](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2runloop的数据结构)
- 3.[猜想runloop内部是如何实现的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3猜想runloop内部是如何实现的)
- 4.[runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4runloop是来做什么的runloop和线程有什么关系主线程默认开启了runloop么子线程呢)
- 5.[Runloop 和线程的关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5runloop-和线程的关系)
- 6.[讲一下 Runloop 的 Mode?(越详细越好)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6讲一下-runloop-的-mode越详细越好)
- 7.[讲一下 Observer ？（Mode中的重点）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7讲一下-observer-mode中的重点)
- 8.[讲一下 Runloop 的内部实现逻辑？（运行过程）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8讲一下-runloop-的内部实现逻辑运行过程)
- 9.[RunLoop实战使用](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9runloop实战使用)
- 10.[你所知的哪些三方框架使用了 Runloop?（AFNetworking、Texture 等）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10你所知的哪些三方框架使用了-runloopafnetworkingtexture-等)
- 11.[autoreleasePool 在何时被释放？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11autoreleasepool-在何时被释放)
- 12.[介绍UIResponder的继承链。然后说事件响应链。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12介绍uiresponder的继承链然后说事件响应链)
- 13.[解释一下 事件响应 的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13解释一下-事件响应-的过程)
- 14.[解释一下 手势识别 的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14解释一下-手势识别-的过程)
- 15.[解释一下 GCD 在 Runloop 中的使用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15解释一下-gcd-在-runloop-中的使用)
- 16.[解释一下 NSTimer，以及 NSTimer 的循环引用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16解释一下-nstimer以及-nstimer-的循环引用)
- 17.[NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17nstimer准吗谈谈你的看法如果不准该怎样实现一个精确的nstimer)
- 18.[AFNetworking 中如何运用 Runloop?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18afnetworking-中如何运用-runloop)
- 19.[AFN为什么添加一条常驻线程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19afn为什么添加一条常驻线程)
- 20.[PerformSelector 的实现原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20performselector-的实现原理)
- 21.[利用 runloop 解释一下页面的渲染的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21利用-runloop-解释一下页面的渲染的过程)
- 22.[如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22如何使用-runloop-实现一个常驻线程这种线程一般有什么作用)
- 23.[NSThread+runloop实现常驻线程](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23nsthreadrunloop实现常驻线程)
- 24.[为什么 NSTimer 有时候不好使？（不同类型的Mode）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24为什么-nstimer-有时候不好使不同类型的mode)
- 25.[滑动tableView时，定时器还会生效吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25滑动tableview时定时器还会生效吗)
- 26.[以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26以-scheduledtimerwithtimeinterval的方式触发的timer在滑动页面上的列表时timer会暂定回调为什么如何解决)
- 27.[PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27performselectorafterdelay这个方法在子线程中是否起作用为什么怎么解决)
- 28.[什么是异步绘制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28什么是异步绘制)
- 29.[如何检测 App 运行过程中是否卡顿？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29如何检测-app-运行过程中是否卡顿)

## 多线程
- 1.[进程和线程、多进程和多线程、任务和队列、并行与串行、同步和异步](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1进程和线程多进程和多线程任务和队列并行与串行同步和异步)
- 2.[iOS线程间怎么通信？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2ios线程间怎么通信)
- 3.[谈谈你对多线程开发的理解(多线程的好处，多线程的作用)？ios中有几种实现多线程的方法？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3谈谈你对多线程开发的理解多线程的好处多线程的作用ios中有几种实现多线程的方法)
- 4.[多线程容易出现的问题，怎么解决](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4多线程容易出现的问题怎么解决)
- [补充：多线程的安全隐患+11种同步解决方案](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充多线程的安全隐患11种同步解决方案)
- 5.[NSThread相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5nsthread相关知识)
- 6.[GCD 相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6gcd-相关知识)
- 7.[说一下 GCD 并发队列实现机制](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7说一下-gcd-并发队列实现机制)
- 8.[GCD的并行队列一定会开辟新的线程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8gcd的并行队列一定会开辟新的线程)
- 9.[如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图)
- 10.[GCD的一些常用的函数？（group，barrier，信号量，线程同步）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10gcd的一些常用的函数groupbarrier信号量线程同步)
- 11.[GCD的队列（dispatch_queue_t）分哪两种类型？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11gcd的队列dispatch_queue_t分哪两种类型)
- 12.[dispatch_barrier_async的作用是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12dispatch_barrier_async的作用是什么)
- 13.[苹果为什么要废弃dispatch_get_current_queue？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13苹果为什么要废弃dispatch_get_current_queue)
- 14.[NSOperation 和 NSOperationQueue相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14nsoperation-和-nsoperationqueue相关知识)
- 15.[如何自定义 NSOperation ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15如何自定义-nsoperation-)
- 16.[NSOperationQueue的优点](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16nsoperationqueue的优点)
- 17.[NSOperation与GCD的关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17nsoperation与gcd的关系)
- 18.[GCD 与 NSOperationQueue 有哪些异同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18gcd-与-nsoperationqueue-有哪些异同)
- 19.[你们项目中为什么多线程用GCD而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19你们项目中为什么多线程用gcd而不用nsoperation呢-你有没有发现国外的大牛他们多线程都是用nsoperation-你能告诉我他们这样做的理由吗)
- 20.[如何使用队列来避免资源抢夺？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20如何使用队列来避免资源抢夺)
- 21.[dispatch_sync 和 dispatch_async 区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21dispatch_sync-和-dispatch_async-区别)
- 22.[NSLock？是否会出现死锁？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22nslock是否会出现死锁)
- 23.[NSContion](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23nscontion)
- 24.[条件锁 - NSContionLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24条件锁---nscontionlock)
- 25.[递归锁 - NSRecursiveLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25递归锁---nsrecursivelock)
- 26.[同步锁 - Synchronized(self) {// code}](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26同步锁---synchronizedself--code)
- 27.[信号量 - dispatch_semaphore](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27信号量---dispatch_semaphore)
- 28.[自旋锁 - OSSpinLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28自旋锁---osspinlock)
- 29.[互斥锁](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29互斥锁)
- 30.[互斥锁和自旋锁区别及应用场景](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#30互斥锁和自旋锁区别及应用场景)
- 31.[多功能锁 - pthread_mutex](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#31多功能锁---pthread_mutex)
- 32.[分步锁 - NSDistributedLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#32分步锁---nsdistributedlock)
- 33.[如何确保线程安全？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#33如何确保线程安全)
- 34.[NSMutableArray、和 NSMutableDictionary是线程安全的吗？NSCache呢？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#34nsmutablearray和-nsmutabledictionary是线程安全的吗nscache呢)
- 35.[解释一下多线程中的死锁？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#35解释一下多线程中的死锁)
- 36.[列举几种进程的同步机制、进程的通信途径、死锁及死锁的处理方法。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#36列举几种进程的同步机制进程的通信途径死锁及死锁的处理方法)
- 37.[子线程是否会出现死锁？说一下场景？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#37子线程是否会出现死锁说一下场景)
- 38.[请说明同步请求与异步请求的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#38请说明同步请求与异步请求的区别)
- 39.[默认最大并发？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#39默认最大并发)
- [补充：FMDB如何保证线程安全](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充fmdb如何保证线程安全)
- 40.[dispatch_once如何实现一次性代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#40dispatch_once如何实现一次性代码)
- 41.[Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#41object-c中创建线程的方法是什么如果在主线程中执行代码方法是什么如果想延时执行代码方法又是什么)
- 42.[如何把异步线程转换成同步任务进行单元测试？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#42如何把异步线程转换成同步任务进行单元测试)
- 43.[如何实现线性编程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#43如何实现线性编程)


## 网络
- 1.[你了解的网络协议](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1你了解的网络协议)
- 2.[NSUrlConnect相关知识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2nsurlconnect相关知识)
- 3.[NSURLSession GET 请求方法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3nsurlsession-get-请求方法)
- 4.[NSUrlSession相关知识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4nsurlsession相关知识)
- 5.[NSURLSession POST请求方法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5nsurlsession-post请求方法)
- 6.[简要说一下http](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6简要说一下http)
- [补充：Http2.0如1.x的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充补充http20如1x的区别)
- 7.[说一下传输控制协议 - TCP ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7说一下传输控制协议---tcp-)
- 8.[说一下用户数据报协议 - UDP ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8说一下用户数据报协议---udp-)
- 9.[HTTP和TCP、UDP的联系](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9http和tcpudp的联系)
- [补充：TCP 协议如何保证可靠传输](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充tcp-协议如何保证可靠传输)
- [补充：说一下可靠数据传输、流量控制(滑动窗口)、拥塞控制](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充说一下可靠数据传输流量控制滑动窗口拥塞控制)
- [补充：TCP 的拥塞控制主要是四个算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充tcp-的拥塞控制主要是四个算法)
- 10.[简要说一下Https；](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10简要说一下https)
- 11.[HTTPS的原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11https的原理)
- [补充：服务器返回给客户端的证书跟它自己保留的证书一样吗](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充服务器返回给客户端的证书跟它自己保留的证书一样吗)
- [补充：https 单项认证 双向认证](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充https-单项认证-双向认证)
- 12.[简要说一下Socket](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12简要说一下socket)
- 13.[Http 和 Https 的区别？为什么更加安全？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13http-和-https-的区别为什么更加安全)
- 14.[Http的请求方式有哪些？Http 有什么特性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14http的请求方式有哪些http-有什么特性)
- 15.[解释一下 三次握手 和 四次挥手？解释一下为什么是三次握手 又为什么是 四次挥手？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15解释一下-三次握手-和-四次挥手解释一下为什么是三次握手-又为什么是-四次挥手)
- 16.[GET 和 POST 请求的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16get-和-post-请求的区别)
- 17.[GET请求参数一定是放在URL中的么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17get请求参数一定是放在url中的么)
- 18.[Post请求体有哪些格式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18post请求体有哪些格式)
- 19.[POST请求参数能放在URL中么为啥](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19post请求参数能放在url中么为啥)
- 20.[HTTP 请求报文 和 响应报文的结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20http-请求报文-和-响应报文的结构)
- 21.[在HTTPS建立连接的时候都用了哪些加密算法，为什么要这么设计](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21在https建立连接的时候都用了哪些加密算法为什么要这么设计)
- 22.[https的缓存问题。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22https的缓存问题)
- 23.[什么是 Mimetype ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23什么是-mimetype-)
- 24.[数据传输的加密过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24数据传输的加密过程)
- 25.[说一下 TCP/IP 五层模型的协议?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25说一下-tcpip-五层模型的协议)
- 26.[说一下 OSI 七层模型的协议?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26说一下-osi-七层模型的协议)
- 27.[大文件下载 的功能有什么注意点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27大文件下载-的功能有什么注意点)
- 28.[后台下载](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28后台下载)
- 29.[断点续传 功能该怎么实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29断点续传-功能该怎么实现)
- 30.[封装一个网络框架有哪些注意点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#30封装一个网络框架有哪些注意点)
- 31.[NSUrlProtocol用过吗？用在什么地方了？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#31nsurlprotocol用过吗用在什么地方了)
- 32.[如何在测试过程中 MOCK 各种网络环境？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#32如何在测试过程中-mock-各种网络环境)
- 33.[DNS 的解析过程？网络的 DNS 优化。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#33dns-的解析过程网络的-dns-优化)
- 34.[DNS劫持和预防](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#34dns劫持和预防)
- 35.[网络请求的状态码都大致代表什么意思？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#35网络请求的状态码都大致代表什么意思)
- 36.[说说为什么要设计304这个状态码](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#36说说为什么要设计304这个状态码)
- 补充：讲一下网络造成卡顿的原因
- 37.[Wireshark、Charles、Paw 等工具会使用吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#37wiresharkcharlespaw-等工具会使用吗)
- 38.[抓包软件 Charles 的原理是什么？说一下中间人攻击的过程。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#38抓包软件-charles-的原理是什么说一下中间人攻击的过程)
- 39.[你知道常见的网络攻击么](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#39你知道常见的网络攻击么)
- 40.[如何判断一个请求是否结束？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#40如何判断一个请求是否结束)
- [补充：用户需要上传和下载一个重要的资料文件，应该如何判断用户本次是否上传成功和下载成功了?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充用户需要上传和下载一个重要的资料文件应该如何判断用户本次是否上传成功和下载成功了)
- 41.[Web登录时怎么保持会话状态的](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#41web登录时怎么保持会话状态的)
- 42.[SSL 传输协议？说一下 SSL 验证过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#42ssl-传输协议说一下-ssl-验证过程)
- 43.[解释一下 Http 的持久连接？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#43解释一下-http-的持久连接)
- 44.[你知道cookie和session的区别么](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#44你知道cookie和session的区别么)
- 45.[发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#45发送网络请求的时候如果带宽-1m如何针对某些请求限制其流量)
- 46.[使用异步请求的方式抓取一个网站的内容，请考虑超时，状态码的异常情况（请用原生API或者Socket/Cocoa Socket）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#46使用异步请求的方式抓取一个网站的内容请考虑超时状态码的异常情况请用原生api或者socketcocoa-socket)
- 47.[在网络请求中，如何处理网络网速慢，网络中断、网络抖动等等网络问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#47在网络请求中如何处理网络网速慢网络中断网络抖动等等网络问题)
- 48.[说说点击一个按钮后打开一个web页面从发送网络请求到页面展示都做了啥](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#48说说点击一个按钮后打开一个web页面从发送网络请求到页面展示都做了啥)
- 49.[为什么能通过一个URL就能请求到对应的资源（域名解析等）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#49为什么能通过一个url就能请求到对应的资源域名解析等)
- 50.[如果客户端上有个按钮，点击会触发一次网络请求，在短时间内快速点击，怎么处理（从客户端以及服务端角度思考）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#50如果客户端上有个按钮点击会触发一次网络请求在短时间内快速点击怎么处理从客户端以及服务端角度思考)
- 51.[判断一个字符串是不是ipv6地址（要求尽全力的考虑所有异常的情况）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#51判断一个字符串是不是ipv6地址要求尽全力的考虑所有异常的情况)
- 52.[你平时怎么解决网络请求的依赖关系：当一个接口的请求需要依赖于另一个网络请求的结果](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#52你平时怎么解决网络请求的依赖关系当一个接口的请求需要依赖于另一个网络请求的结果)


## 消息传递的方式
- 1.[说一下 NSNotification 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下-nsnotification-的实现机制)
- 2.[说一下 NSNotification 的特点。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2说一下-nsnotification-的特点)
- 3.[简述 KVO 的实现机制。或者是KVO的使用？实现原理？（为什么要创建子类来实现）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3简述-kvo-的实现机制或者是kvo的使用实现原理为什么要创建子类来实现)
- 4.[KVO 在使用过程中有哪些注意点？有没有使用过其他优秀的 KVO 三方替代框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4kvo-在使用过程中有哪些注意点有没有使用过其他优秀的-kvo-三方替代框架)
- 5.[消息通知有几种？如何判断是否发送通知。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5消息通知有几种如何判断是否发送通知)
- 6.[简述 KVO 的注册依赖键是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6简述-kvo-的注册依赖键是什么)
- 7.[如何做到 KVO手动通知？，如何手动触发一个value的KVO](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7如何做到-kvo手动通知如何手动触发一个value的kvo)
- 8.[在什么情况下会触发 KVO?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8在什么情况下会触发-kvo)
- 9.[给实例变量赋值时，是否会触发 KVO?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9给实例变量赋值时是否会触发-kvo)
- 10.[Delegate通常用什么关键字修饰？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10delegate通常用什么关键字修饰为什么)
- 11.[通知 和 代理 有什么区别？各自适应的场景？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11通知-和-代理-有什么区别各自适应的场景)
- 12.[说一下什么是Block?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12说一下什么是block)
- 13.[Block 有几种类型？分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13block-有几种类型分别是什么)
- 14.[Block 用什么修饰？copy，assign，strong有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14block-用什么修饰copyassignstrong有什么区别)
- 15.[Block 后面携带参数的时候，有数量限制吗？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15block-后面携带参数的时候有数量限制吗为什么)
- 16.[__block 的解释以及在 ARC 和 MRC 下有什么不同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16__block-的解释以及在-arc-和-mrc-下有什么不同)
- [补充：在block内如何修改block外部变量?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充在block内如何修改block外部变量)
- 17.[Block 的内存管理。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17block-的内存管理)
- 18.[Block 自动截取变量。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18block-自动截取变量)
- 19.[Block 处理循环引用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19block-处理循环引用)
- 20.[使用block时什么情况会发生引用循环，如何解决？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20使用block时什么情况会发生引用循环如何解决)
- 21.[在block内如何修改block外部变量？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21在block内如何修改block外部变量)
- 22.[使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22使用系统的某些block-api如uiview的block版本写动画时是否也考虑引用循环问题)
- 23.[Dispatch_block_t这个有没有用过？解释一下？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23dispatch_block_t这个有没有用过解释一下)
- 24.[addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24addobserverforkeypathoptionscontext各个参数的作用分别是什么observer中需要实现哪个方法才能获得kvo回调)
- 25.[KVC和KVO的keyPath一定是属性么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25kvc和kvo的keypath一定是属性么)
- 26.[如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26如何关闭默认的kvo的默认实现并进入自定义的kvo实现)
- 27.[apple用什么方式实现对一个对象的KVO？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27apple用什么方式实现对一个对象的kvo)
- 28.[KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#28kvc的使用实现原理kvc拿到key以后是如何赋值的知不知道集合操作符能不能访问私有属性能不能直接访问_ivar)
- 29.[KVC的keyPath中的集合运算符如何使用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#29kvc的keypath中的集合运算符如何使用)

## 项目架构
- 1.[什么是 MVC?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1什么是-mvc)
- 2.[什么是 MVVM?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2什么是-mvvm)
- 3.[什么是 MVP?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3什么是-mvp)
- 4.[什么是 CDD?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4什么是-cdd)
- 5.[项目的组件化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5项目的组件化)
    * 1.[说一下你了解的项目组件化方案？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下你了解的项目组件化方案)
    * 2.[什么样的团队及项目适合采用组件化的形式进行开发？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2什么样的团队及项目适合采用组件化的形式进行开发)
    * 3.[组件之间的通信方式。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3组件之间的通信方式)
    * 4.[各组件之间的解耦。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4各组件之间的解耦)
- 6.[还了解哪些项目架构？你之前所在公司的架构师什么样的，简单说一下？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6还了解哪些项目架构你之前所在公司的架构师什么样的简单说一下)
- 7.[从宏观上来讲 App 可以分为哪些层？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7从宏观上来讲-app-可以分为哪些层)
- 8.[多工程连编之静态库](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8多工程连编之静态库)


## iOS设计模式
- 1.[编程中的六大设计原则？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1编程中的六大设计原则)
- 2.[如何设计一个图片缓存框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2如何设计一个图片缓存框架)
- 3.[如何设计一个时长统计框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3如何设计一个时长统计框架)
- 4.[如何实现 App 换肤（夜间模式）？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4如何实现-app-换肤夜间模式)
- 5.[外观模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5外观模式)
- 6.[中介者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6中介者模式)
- 7.[访问者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7访问者模式)
- 8.[装饰模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8装饰模式)
- 9.[观察者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9观察者模式)
- 10.[责任链模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10责任链模式)
- 11.[命令模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11命令模式)
- 12.[适配器模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12适配器模式)
- 13.[桥接模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13桥接模式)
- 14.[代理委托模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14代理委托模式)
- 15.[单例模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15单例模式)
- [补充：单例弊端？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充单例弊端)
- [16.类工厂模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16类工厂模式)


## 数据存储
- 1.[如何判断一个文件在沙盒中是否存在？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1如何判断一个文件在沙盒中是否存在)
- 2.[数据持久化的几个方案（fmdb用没用过）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2数据持久化的几个方案fmdb用没用过)
- 3.[简要介绍沙盘](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3简要介绍沙盘)
- 4.[Sqlite3](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4sqlite3)
    * 1.[简单说一下 Sqlite3](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1简单说一下-sqlite3)
    * 2.[Sqlite3 常用的执行语句](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2sqlite3-常用的执行语句)
    * 3.[Sqlite3 在不同版本的APP，数据库结构变化了，如何处理?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3sqlite3在不同版本的app数据库结构变化了如何处理)
- 5.[FMDB (Sqlite3 的封装)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5fmdb-sqlite3-的封装)
- 6.[Realm](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6realm)
- 7.[NSKeyArchieve](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7nskeyarchieve)
- 8.[Preperfence](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8preperfence)
- 9.[Plist](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9plist)
- 10.[CoreDate](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10coredate)
- 11.[Keychain](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11keychain)
- 12.[UIPasteBoard](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12uipasteboard)
- 13.[FoundationDB](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13foundationdb)
- 14.[LRU(最少最近使用)缓存](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14lru最少最近使用缓存)


## WebView
- 1.[说一下 JS 和 OC 互相调用的几种方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下-js-和-oc-互相调用的几种方式)
- 2.[在使用 WKWedView 时遇到过哪些问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2在使用-wkwedview-时遇到过哪些问题)
- 3.[是否了解 UIWebView 的插件化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3是否了解-uiwebview-的插件化)
- 4.[是否了解 SFSafariViewController ？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4是否了解-sfsafariviewcontroller-)


## 音频处理

## 视频处理
- 补充：AVFoundation原理


## 图像处理
- 1.[图像的压缩、解压。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1图像的压缩解压)
- 2.[一张物理体积20KB、分辨率为 200 * 300 的图片，在内存中占用多大的空间？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2一张物理体积20kb分辨率为-200--300-的图片在内存中占用多大的空间)
- 3.[GLSurfaceView的相关知识，OpenGL，Shader，绘制流程。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3glsurfaceview的相关知识openglshader绘制流程)


## iOS 动画
- 1.[简要说一下常用的动画库。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1简要说一下常用的动画库)
- 2.[请说一下对 CALayer 的认识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2请说一下对-calayer-的认识)
- 3.[解释一下 CALayer.contents 属性。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3解释一下-calayercontents-属性)
- 4.[在 iOS 中，动画有哪几种类型？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4在-ios-中动画有哪几种类型)
- 5.[隐式动画](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5隐式动画)
- 6.[显式动画](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6显式动画)

## 蓝牙

## ARKit

## Core ML

## 代码管理、持续集成、项目托管
- 1.[Git](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1git)
    * 1.[`git pull` 和 `git fetch` 的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1git-pull-和-git-fetch-的区别)
    * 2.[`git merge` 和 `git rebase` 的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2git-merge-和-git-rebase-的区别)
    * 3.[如何在本地新建一个分支，并 push 到远程服务器上？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3如何在本地新建一个分支并-push-到远程服务器上)
    * 4.[如果 fork 了一个别人的仓库，怎样与源仓库保持同步](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4如果-fork-了一个别人的仓库怎样与源仓库保持同步)
    * 5.[总结一下 Git 常用的命令？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5总结一下-git-常用的命令)
- 2.[Svn](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2svn)
- 3.[CocoaPods](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3cocoapods)
    * 1.[说一下 `CocoaPods` 的原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下-cocoapods-的原理)
    * 2.[如何让自己写的框架支持 `CocoaPods`？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2如何让自己写的框架支持-cocoapods)
    * 3.[`pod update` 和 `pod install` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3pod-update-和-pod-install-有什么区别)
    * 4.[`Podfile.lock` 文件起什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4podfilelock-文件起什么作用)
    * 5.[CocoaPods 常用指令？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5cocoapods-常用指令)
    * 6.[在使用 CocoaPods 中遇到过哪些问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6在使用-cocoapods-中遇到过哪些问题)
    * 7.[如何使用 CocoaPods 集成远程私有库？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7如何使用-cocoapods-集成远程私有库)
    * 8.[如果自己写的库需要依赖其他的三方库，该怎么办？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8如果自己写的库需要依赖其他的三方库该怎么办)
    * 9.[CocoaPods 中的 Subspec 字段有什么用处？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9cocoapods-中的-subspec-字段有什么用处)
- 4.[Carthage](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4carthage)
- 5.[Fastlane](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5fastlane)
- 6.[Jenkins](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6jenkins)
- 7.[fir.im](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7firim)
- 8.[蒲公英](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8蒲公英)
- 9.[TestFlight](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9testflight)

## 数据安全及加密
- 1.[RSA非对称加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1rsa非对称加密)
- 2.[AES对称加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2aes对称加密)
- 3.[DES加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3des加密)
- 4.[Base64加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4base64加密)
- 5.[MD5加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5md5加密)
- 6.[简述 `SSL` 加密的过程用了哪些加密方法，为何这么作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6简述-ssl-加密的过程用了哪些加密方法为何这么作)
- 7.[是否了解 `iOS` 的签名机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7是否了解-ios-的签名机制)
- 8.[如何对 `APP` 进行重签名？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8如何对-app-进行重签名)
- 9.[在HTTPS建立连接的时候都用了哪些加密算法，为什么要这么设计](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9在https建立连接的时候都用了哪些加密算法为什么要这么设计)
- 10.[常见的加密算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10常见的加密算法)
- 11.[对称加密算法和非对称加密算法的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11对称加密算法和非对称加密算法的区别)


## 源代码阅读
- 1.[YYKit](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1yykit)
- 2.SDWebImage
    * 1.[看过sdwebimage的源码吗？说一下sdwebimage的原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1看过sdwebimage的源码吗说一下sdwebimage的原理)
    * 2.[说一下SDWebImage的缓存策略？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2说一下sdwebimage的缓存策略)
    * 3.[磁盘缓存时间，默认的缓存路径，怎么处理图片的名称?默认的超时时间是多少?最大并发数？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3磁盘缓存时间默认的缓存路径怎么处理图片的名称默认的超时时间是多少最大并发数)
    * 4.[该框架内部对内存警告的处理方式?（或者问：当app接收到内存警告时，SDWebImage做了什么？）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4该框架内部对内存警告的处理方式或者问当app接收到内存警告时sdwebimage做了什么)
    * 5.[NSCache和字典的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5nscache和字典的区别)
    * 6.[如何计算图片的成本?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6如何计算图片的成本)
    * 7.[保证错误的URL不会被尝试重新下载，使用什么来下载图片的 ](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7保证错误的url不会被尝试重新下载使用什么来下载图片的)
    * 8.[sdwebimage是一个异步下载图片的三方，怎么保证线程安全的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8sdwebimage是一个异步下载图片的三方怎么保证线程安全的)
    * 9.[如果一个页面 加载图片很卡 ，什么原因，会跟sdwebimage有关吗，还是跟图片渲染有关？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9如果一个页面-加载图片很卡-什么原因会跟sdwebimage有关吗还是跟图片渲染有关)
    * 10.[如果收到内存警告怎么办](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10如果收到内存警告怎么办)
    * 11.[SDWebImage是如何做到Url不变的情况下，更新图片内容的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11sdwebimage是如何做到url不变的情况下更新图片内容的)
- 3.AFNetworking
- 4.SVProgressHub 
- 5.Texture（ASDK）


## iOS逆向及安全
- 1.[怎么防止反编译？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1怎么防止反编译)
- 2.[项目中网络层如何做安全处理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2项目中网络层如何做安全处理)


## Coretext
## 项目组件化
- 1.[说一下你之前项目的组件化方案？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1说一下你之前项目的组件化方案)
- 2.[项目的组件化模块应该如何划分？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2项目的组件化模块应该如何划分)
- 3.[如何集成本地私有库？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3如何集成本地私有库)
- 4.[如何集成远程私有库？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4如何集成远程私有库)


## 性能优化
- 1.[如何提升 `tableview` 的流畅度？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1如何提升-tableview-的流畅度)
- 2.[如何使用 `Instruments` 进行性能调优？(Time Profiler、Zombies、Allocations、Leaks)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2如何使用-instruments-进行性能调优time-profilerzombiesallocationsleaks)
- 3.[如何优化 `APP` 的启动时间](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3如何优化-app-的启动时间)
- 4.[今日头条的启动优化方案](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4今日头条的启动优化方案)
- 5.[如何对 `APP` 进行内存、电量、网络流量的优化](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5如何对-app-进行内存电量网络流量的优化)
- 6.[如何有效降低 `APP` 包的大小？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6如何有效降低-app-包的大小)
- 7.[日常如何检查内存泄露？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7日常如何检查内存泄露)
- 8.[能不能说一下物理屏幕显示的原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8能不能说一下物理屏幕显示的原理)
- 9.[解释一下什么是屏幕卡顿、掉帧？该如何避免？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9解释一下什么是屏幕卡顿掉帧该如何避免)
- 10.[什么是 `离屏渲染`？什么情况下会触发？该如何应对？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10什么是离屏渲染什么情况下会触发该如何应对)
- 11.[如何检测离屏渲染？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11如何检测离屏渲染)
- 12.[如何高性能的画一个圆角？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12如何高性能的画一个圆角)
- 13.[如何优化 APP 的内存？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13如何优化-app-的内存)
- 14.[如何优化 APP 的电量？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14如何优化-app-的电量)
- 15.[假如Controller太臃肿，如何优化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15假如controller太臃肿如何优化)


## 调试技巧 & 软件使用
- 1.[`LLDB` 调试。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1lldb-调试)
- 2.[断点调试- breakPoint。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2断点调试--breakpoint)
- 3.[`NSAssert` 的使用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3nsassert-的使用)
- 4.[`Charles` 的使用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4charles-的使用)
- 5.[`Reveal` 的使用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5reveal-的使用)
- 6.[iOS 常见的崩溃类型有哪些？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6ios-常见的崩溃类型有哪些)
- 7.[当页面 AutoLayout 出现了问题，怎样快速调试？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7当页面-autolayout-出现了问题怎样快速调试)


## 扩展问题
- 1.[无痕埋点](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1无痕埋点)
- 2.[APM（应用程序性能监测）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2apm应用程序性能监测)
- 3.[Hot Patch（热修补）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3hot-patch热修补)
- 4.[崩溃的处理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4崩溃的处理)
- [补充：各个app之间是怎么相互切换的](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充各个app之间是怎么相互切换的)


## 其他问题
- 1.[面向对象的三个要素](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1面向对象的三个要素)
- 2.[多态？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2多态)
- 补充： bitcode 的理解和作用
- 补充：事务的特征
- 补充：事务的状态
- 3.[Java，python，OC运行效率孰高？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3javapythonoc运行效率孰高)
- 4.[Property，其中copy如何？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4property其中copy如何)
- 5.[Property(nonatomatic, copy) NSMutableArray有什么问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5propertynonatomatic-copy-nsmutablearray有什么问题)
- 6.[Copy和MutableCopy的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6copy和mutablecopy的区别)
- 7.[解释下类别的原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7解释下类别的原理)
- 8.[解释下封装，重载](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8解释下封装重载)
- 9.[OC存在多重继承吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9oc存在多重继承吗)
- 10.[了解表视图吗，解释一下复用原理](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10了解表视图吗解释一下复用原理)
- 11.[说明一下表视图的滑动卡顿的优化方法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11说明一下表视图的滑动卡顿的优化方法)
- 12.[viewDidLoad和viewDidAppear的调用时机（一次和多次的区别）；](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12viewdidload和viewdidappear的调用时机一次和多次的区别)
- 13.[页面间的传值方式有哪些（公有属性，公有方法和协议，block传值，通知，extern全局变量传值，NSUserDefault简单数据存储传值）；](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13页面间的传值方式有哪些公有属性公有方法和协议block传值通知extern全局变量传值nsuserdefault简单数据存储传值)
- 14.[在OC中对象方法的几种访问权限，分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14在oc中对象方法的几种访问权限分别是什么)
- 15.[列出 #import 和 #include 的区别，另外什么时候使用@class？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15列出-import-和-include-的区别另外什么时候使用class)
- [16.`load` 和 `Initialize` 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16load-和-initialize-的区别)
- [17.`Designated Initializer`的规则？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17designated-initializer的规则)
- [18.`App` 编译过程有了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18app-编译过程有了解吗)
- 19.[介绍下App启动的完成过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19介绍下app启动的完成过程)
- 20.[`JS` 和 `Native` 交互。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20js-和-native-交互)
- 21.[`LoadView`方法了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21loadview方法了解吗)
- 22.[说一下对 `APNS` 的认识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22说一下对-apns-的认识)
- 23.[简述Xcode7和Xcode8的异同](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23简述xcode7和xcode8的异同)
- 24.[描述iOS 10的一些新特性（包括系统和开发环境）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24描述ios-10的一些新特性包括系统和开发环境)
- 25.[App 上有一数据列表，客户端和服务端均没有任何缓存，当服务端有数据更新时，该列表在 wifi 下能获取到数据，在 4G 下刷新不到，但是在 4g 环境下其他 App 都可以正常打开，分析其产生的原因？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25app-上有一数据列表客户端和服务端均没有任何缓存当服务端有数据更新时该列表在-wifi-下能获取到数据在-4g-下刷新不到但是在-4g-环境下其他-app-都可以正常打开分析其产生的原因)
- 26.[是否了解链式编程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26是否了解链式编程)
- 27.[dSYM你是如何分析的](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#27dsym你是如何分析的)



# 数据结构及算法

## 数据结构
### 1.数据结构
#### 1.数据结构的存储一般常用的有几种？各有什么特点？
- 数据结构的存储一般常用的有两种 顺序存储结构 和 链式存储结构
- 顺序存储结构:
    * 比如，数组，1-2-3-4-5-6-7-8-9-10，存储是按顺序的。再比如栈和队列等
- 链式存储结构:
    * 比如，数组，1-2-3-4-5-6-7-8-9-10，链式存储就不一样了 1(地址)-2(地址)-7(地址)-4(地址)-5(地址)-9(地址)-8(地址)-3(地址)-6(地址)-10(地址)。每个数字后面跟着一个地址 而且存储形式不再是顺序

#### 2.集合结构 线性结构 树形结构 图形结构

### 2.数组
#### 1.数组和链表的区别
- 数组
    * 数组元素在内存上连续存放，可以通过下标查找元素；插入、删除需要移动大量元素，比较适用于元素很少变化的情况
- 链表
    * 链表中的元素在内存中不是顺序存储的，查找慢，插入、删除只需要对元素指针重新赋值，效率高

### 3.字符串
#### 1.字符匹配 & 字符去重
### 4.链表
#### 1.单向链表 双向链表 循环链表
- 单向链表 A->B->C->D->E->F->G->H. 这就是单向链表 H 是头 A 是尾 像一个只有一个头的火车一样 只能一个头拉着跑

![image](https://upload-images.jianshu.io/upload_images/12311242-b8b156df351244ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/690)

- 双向链表

![image](https://upload-images.jianshu.io/upload_images/12311242-1e239e3e44cb5169.png?imageMogr2/auto-orient/strip|imageView2/2/w/690)

- 循环链表
    * 循环链表是与单向链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。发挥想象力 A->B->C->D->E->F->G->H->A. 绕成一个圈。就像蛇吃自己的这就是循环 不需要去死记硬背哪些理论知识。

### 5.树
#### 二叉树
##### 基本概念
- 二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。
- 二叉树常被用于实现二叉查找树和二叉堆(详见堆排序)。
- 二叉树不是树的一种特殊情形，尽管其与树有许多相似之处，但树和二叉树有两个主要差别：
    * 树中结点的最大度数没有限制，而二叉树结点的最大度数为2；
    * 树的结点无左、右之分，而二叉树的结点有左、右之分。

##### 分类
- 完全二叉树
    * 若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。完全二叉树的特点是：“叶子节点的位置比较规律”。因此在对数据进行排序或者查找时可以用到它，比如堆排序就使用了它。
- 满二叉树
    * 除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
- 平衡二叉树
    * 平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

##### 存储结构
- 二叉树的存储结构有顺序和链式两种方式。前者虽然使用简单，但是存在浪费空间的问题
- 二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点。即用一维数组存储二叉树中的结点。因此，必须把二叉树的所有结点安排成一个恰当的序列，结点在这个序列中的相互位置能反映出结点之间的逻辑关系。用编号的方法从树根起，自上层至下层，每层自左至右地给所有结点编号。
- 依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映出结点之间的逻辑关系，这样既能够最大可能地节省存储空间，又可以利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。
- 但是对于一般的非完全二叉树来说，如果仍然按照从上到下、从左到右的次序存储在一维数组中，则数组下标之间不能准确反映树中结点间的逻辑关系，可以在非完全二叉树中添加一些并不存在的空结点使之变成完全二叉树，不过这样做有可能会造成空间的浪费。在最坏的情况下，一棵深度为k的右斜树，它只有k个结点，却需要2^k-1个结点存储空间。这显然是对存储空间的严重浪费，所以顺序存储结构一般只用于完全二叉树或满二叉树。
- 二叉树的链式存储结构是指用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。二叉树的每个结点最多有两个孩子，因此，每个结点除了存储自身的数据外，还应设置两个指针分别指向左、右孩子结点。data是数据域，lchild和rchild都是指针域，分别存放指向左孩子和右孩子的指针。当没有孩子结点时，相应的指针域置为空。

##### 二叉查找树
- 二叉树的提出其实主要就是为了提高查找效率，比如我们常用的 HashMap在处理哈希冲突严重时，拉链过长导致查找效率降低，就引入了红黑树。二分查找可以缩短查找的时间，但是它要求查找的数据必须是有序的。每次查找、操作时都要维护一个有序的数据集，于是有了二叉查找树这个概念。
- 二叉查找树（又叫二叉排序树），它是具有下列性质的二叉树：
    * 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    * 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
    * 左、右子树也分别为二叉排序树。
- 二叉查找树中，左子树都比节点小，右子树都比节点大，递归定义。根据二叉排序树这个特点我们可以知道：二叉排序树的中序遍历一定是从小到大的。
- 比如：

![image](https://upload-images.jianshu.io/upload_images/1170656-e1e38cf94b3ad1d4.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/256)

- 中序遍历结果是

```
1 3 4 6 7 8 10 13 14
```
- 在最好的情况下，二叉排序树的查找效率比较高，是 O(logn)，其访问性能近似于折半查找；但最差时候会是 O(n)，比如插入的元素是有序的，生成的二叉排序树就是一个链表，这种情况下，需要遍历全部元素才行（见下图 ）。

![image](https://upload-images.jianshu.io/upload_images/1170656-4fce4ddb7694e358.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/509)

- 如果我们可以保证二叉排序树不出现上面提到的极端情况（插入的元素是有序的，导致变成一个链表），就可以保证很高的效率了。但这在插入有序的元素时不太好控制，按二叉排序树的定义，我们无法判断当前的树是否需要调整。因此就要用到平衡二叉树（AVL 树）了。平衡二叉树在添加和删除时需要进行旋转保持整个树的平衡，内部做了这么复杂的工作后，我们在使用它时，插入、查找的时间复杂度都是 O(logn)，性能已经相当好了。

##### 遍历顺序
- 二叉的遍历方式有四种：
    * 第一种：前序遍历。先访问根节点，再访问左子树，最后访问右子树。
    * 第二种：中序遍历。先访问左子树，再访问根节点，最后访问右子树。
    * 第三种：后序遍历。先访问左子树，再访问右子树，最后访问根节点。
    * 第四种：层序遍历。一层层节点依次遍历。

![image](https://upload-images.jianshu.io/upload_images/1170656-fcfcd39aed2bad36.png?imageMogr2/auto-orient/strip|imageView2/2/w/329)

- 这颗二叉树
    * 前序遍历：1-2-4-5-7-3-6
    * 中序遍历：4-2-5-7-1-6-3
    * 后序遍历：4-7-5-2-6-3-1
    * 层序遍历：1-2-3-4-5-6-7
- 先序遍历是先访问根结点，再左子树，再右子树。中序是先访问左子树,再根结点，再右子树。后序是先访问左子树, 再右子树，再根结点。递归固然是清晰明了，但是存在效率低的问题，非递归的方案用栈结构来存结点信息，通过出栈访问来遍历二叉树。它思想是这样的，当栈顶中的指针非空时，遍历左子树，也就是左子树根的指针进栈。当栈顶指针为空时，应退至上一层，如果是从左子树返回的，访问当前层，也就是栈顶中的根指针结点。如果是从右子树返回，说明当前层遍历完毕，继续退栈。

#### 二叉搜索树
##### 1.输入一棵二叉树的根结点，求该树的深度？
- 二叉树的结点定义如下：

```
struct BinaryTreeNode
{
    int m_nValue ；
    BinaryTreeNode* m_pLeft;
    BinarvTreeNode* m_pRight ；
}
```
- 如果一棵树只有一个结点，它的深度为1。
- 如果根结点只有左子树而没有右子树，那么树的深度应该是其左子树的深度加1；同样，如果根结点只有右子树而没有左子树，那么树的深度应该是其右子树的深度加1。
- 如果既有右子树又有左子树，那该树的深度就是其左、右子树深度的较大值再加1。

```
int TreeDepth(TreeNode* pRoot)
{
    if(pRoot == nullptr)
        return 0;
    int left = TreeDepth(pRoot->left);
    int right = TreeDepth(pRoot->right);

    return (left>right) ? (left+1) : (right+1);
}
```

##### 2.输入一课二叉树的根结点，判断该树是不是平衡二叉树？
- 重复遍历结点
    * 先求出根结点的左右子树的深度，然后判断它们的深度相差不超过1，如果否，则不是一棵二叉树；如果是，再用同样的方法分别判断左子树和右子树是否为平衡二叉树，如果都是，则这就是一棵平衡二叉树。
- 遍历一遍结点
    * 遍历结点的同时记录下该结点的深度，避免重复访问。
- 方法1:

```
struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
};
 
int TreeDepth(TreeNode* pRoot){
    if(pRoot==NULL)
        return 0;
    int left=TreeDepth(pRoot->left);
    int right=TreeDepth(pRoot->right);
    return left>right?(left+1):(right+1);
}
 
bool IsBalanced(TreeNode* pRoot){
    if(pRoot==NULL)
        return true;
    int left=TreeDepth(pRoot->left);
    int right=TreeDepth(pRoot->right);
    int diff=left-right;
    if(diff>1 || diff<-1)
        return false;
    return IsBalanced(pRoot->left) && IsBalanced(pRoot->right);
}

```
- 方法2

```
bool IsBalanced_1(TreeNode* pRoot,int& depth){
    if(pRoot==NULL){
        depth=0;
        return true;
    }
    int left,right;
    int diff;
    if(IsBalanced_1(pRoot->left,left) && IsBalanced_1(pRoot->right,right)){
        diff=left-right;
        if(diff<=1 || diff>=-1){
            depth=left>right?left+1:right+1;
            return true;
        }
    }
    return false;
}
 
bool IsBalancedTree(TreeNode* pRoot){
    int depth=0;
    return IsBalanced_1(pRoot,depth);
} 
```

#### 红黑树
### 6.栈
#### 1.堆、栈和队列 分别是什么？
### 7.队列
### 8.哈希表（有哪些功能是通过哈希表实现的）

## 算法
### 基本概念
#### 时间复杂度
- 时间频度
    * 一个算法执行所耗费的时间,从理论上是不能算出来的,必须上机运行测试才能知道.但我们不可能也没有必要对每个算法都上机测试,只需知道哪个算法花费的时间多,哪个算法花费的时间少就可以了.并且一个算法花费的时间与算法中语句的执行次数成正比例,哪个算法中语句执行次数多,它花费时间就多.一个算法中的语句执行次数称为语句频度或时间频度.记为T(n).
- 时间复杂度
    * 一般情况下,算法中基本操作重复执行的次数是问题规模n的某个函数,用T(n)表示,若有某个辅助函数f(n),使得当n趋近于无穷大时,T（n)/f(n)的极限值为不等于零的常数,则称f(n)是T(n)的同数量级函数.记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度,简称时间复杂度.
    * 在各种不同算法中,若算法中语句执行次数为一个常数,则时间复杂度为O(1),另外,在时间频度不相同时,时间复杂度有可能相同,如T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同,但时间复杂度相同,都为O(n2).
- 按数量级递增排列,常见的时间复杂度有：
    * O(1)称为常量级，算法的时间复杂度是一个常数。
    * O(n)称为线性级，时间复杂度是数据量n的线性函数。
    * O(n²)称为平方级，与数据量n的二次多项式函数属于同一数量级。
    * O(n³)称为立方级，是n的三次多项式函数。
    * O(logn)称为对数级，是n的对数函数。
    * O(nlogn)称为介于线性级和平方级之间的一种数量级
    * O(2ⁿ)称为指数级，与数据量n的指数函数是一个数量级。
    * O(n!)称为阶乘级，与数据量n的阶乘是一个数量级。
    * 它们之间的关系是： O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)，随着问题规模n的不断增大,上述时间复杂度不断增大,算法的执行效率越低.

#### 空间复杂度
- 评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。不包括算法程序代码和所处理的数据本身所占空间部分。通常用所使用额外空间的字节数表示。其算法比较简单，记为S(n)=O(f(n))，其中，n表示问题规模。

### 常见的摘要算法
#### HEX编码
#### Base64
#### MD5
#### SHA1
#### SHA256
#### MAC算法

### 常见对称加密算法
#### AES
#### DES
#### 3DES
#### - Blowfish

### 常见的排序算法

![image](https://upload-images.jianshu.io/upload_images/6370252-af954dfa5ba39bca.png?imageMogr2/auto-orient/strip|imageView2/2/w/678)

#### 插入排序
- 插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法。插入排序是一种最简单的方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动
- 思想：插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序
- 特性：
    * 如果当前索引大于0，并且前一张牌比后一张牌大
    * 如果判断的时候相等，那么是不稳定排序，会交换两个相等的元素的位置，这里只是compare为大于
    * 时间复杂度取决于逆序对的数量，如10，9，8，3，2，1，【10，1】，【9，2】，【8，3】，互为逆序对，最后面的牌，需要经历很远的路程，才可以排到前面
    * 时间复杂度与逆序对的数量成正比
    * 逆序对的数量越多，插入排序的时间复杂度越高
    * 时间复杂度为O(n^2),最好的时间复杂度为O(n),如果没有逆序对，就是最优的情况
    * 属于稳定排序
    * 数量不大的时候，插入排序的效率很高
- 算法时间复杂度
    * 最好的情况下：正序有序(从小到大)，这样只需要比较n次，不需要移动。因此时间复杂度为O(n)
    * 最坏的情况下：逆序有序,这样每一个元素就需要比较n次，共有n个元素，因此实际复杂度为O(n­2)
    * 平均情况下：O(n­2)
- 稳定性
    * 理解性记忆比死记硬背要好。因此，我们来分析下。稳定性，就是有两个相同的元素，排序先后的相对位置是否变化，主要用在排序时有多个排序规则的情况下。在插入排序中，K1是已排序部分中的元素，当K2和K1比较时，直接插到K1的后面(没有必要插到K1的前面，这样做还需要移动！！)，因此，插入排序是稳定的。
- 几种算法实现
    * 每次拿到当前元素之后和前面的元素挨个比较，如果比当前元素小，就交换元素位置，以此类推，所以这种算法会频繁交换
    * 每次拿当前元素和前面的元素进行比较，如果前面的元素比当前元素大，那么将前面的元素向后移动，然后记录当前要插入的元素的位置，这种算法优于前面，因为每次只需要移动一次元素位置即可
    * 基于二分法查找优化，每次拿到当前元素之后，去前面已经排好序的数组中查找要插入的位置，查找基于二分法查找，这样效率大大提高于之前的每次交换，然后拿到要插入的元素的位置之后，再移动一次元素的位置。

```
//
//  SCXInsertionSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/12.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXInsertionSoft.h"

@implementation SCXInsertionSoft
// 插入排序更优的优化
- (NSArray *)soft:(NSArray<NSNumber *> *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    for (int i = 1 ; i < soft.count; i ++) {
        // 原始位置元素
        NSNumber *cur = soft[i];
        // 从第一个位置开始查找当前这个位置的元素应该放的位置，因为是依次查找，所以顺便排序了
        // 这个当前元素应该插入的索引
        int index = [self binarySearch:soft index:i];
        // 找到这个index之后开始挪动元素位置，区间为[index,begin);
        for (int j = i ; j > index; j --) {
            soft[j] = soft[j - 1];
        }
        soft[index] = cur;
    }
    return soft.copy;
}

/// 二分查找找到index位置应该插入的位置
/// @param arr 查找的数组
/// @param index 要查找区间最大值
/// @return 元素的索引
// 下面的另一个二分查找的方法有弊端，比如有重复的元素，1，2，3，5，5，5，5，5，6，7，8，其中有多个5，在我们二分查找的过程中可能元素个数的不同，返回5的索引位置也不同，这样是不行的，我们应该返回第一个元素的位置，不影响原来相同元素位置的排序，这样才是稳定的
- (int)binarySearch:(NSArray *)arr index:(int)index{
    if (arr == nil || arr.count <= 0 || index >= arr.count) {
        return -1;
    }
    NSNumber *obj = arr[index];
    // 开始索引
    int begin = 0;
    // 结束索引
    // 区间为[begin,end);,左闭由开
    int end = index;
    int value = obj.intValue;
    while (begin < end) {
        int mid = (begin + end) >> 1;
        NSNumber *midValue = arr[mid];
        // 要查找的值在左边
        if (value < midValue.intValue) {
            // 更改end的位置
            end = mid;
        } else {
            // 这里是找到第一个大于当前值得位置，因为如果valu比midValue大的话，那么插入的位置肯定在后面
            // 如果vaalue 和 midvalue 相等的话，我们这里也向后查找，如上面举的例子，存在好几个5，那么第一次出现5的位置并不一定是我们要找的位置，但是我们可以确定，一定在这个值得后面。
            // 要查找的值在右边
            // 更改begin的位置
            begin = mid + 1;
        }
    }
    return begin;
}
/// 二分查找
/// @param arr 查找的数组
/// @param obj 要查找的值
/// @return 元素的索引
- (int)binarySearch1:(NSArray *)arr obj1:(NSNumber *)obj{
    if (arr == nil || arr.count <= 0 || obj == nil) {
        return -1;
    }
    // 开始索引
    int begin = 0;
    // 结束索引
    // 区间为[begin,end);,左闭由开
    int end = arr.count;
    int value = obj.intValue;
    while (begin < end) {
        int mid = (begin + end) >> 1;
        NSNumber *midValue = arr[mid];
        // 要查找的值在左边
        if (value < midValue.intValue) {
            // 更改end的位置
            end = mid;
        } else if (value > midValue.intValue){
            // 要查找的值在右边
            // 更改begin的位置
            begin = mid + 1;
        } else {
            // 命中
            return mid;
        }
    }
    return -1;
}
// 插入排序优化
-(NSArray *)soft2:(NSArray<NSNumber *> *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    // 插入排序的优化的思想就是将元素向后挪，挪出一个位置之后，再将待插入的元素放进去
    // 1，2，4，5，然后插入3,相当于,1,2,[],4,5,4和5，向后挪动了，中间留了一个位置给3，最后把3放进去
    for (int i = 1 ; i < soft.count - 1; i ++) {
        int index = i;
        // 当前待插入的元素
        NSNumber *cur = soft[index];
        while (index > 0 && [self compareA:soft[index - 1] valueB:cur]) {
            // 比当前要插入的对象要大的那个元素往后移动，流出来当前位置给要插入的那个元素
            // 下面的插入排序方法，这里每次都需要交换，三行代码，这里只需要向后挪动，一行代码
            soft[index] = soft[index - 1];
            index --;
        }
        // 将腾出来的那个位置赋值
        soft[index] = cur;
    }
    
    return soft.copy;
}
// 普通插入排序
-(NSArray *)soft1:(NSArray *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    // 把插入排序看成打扑克牌，每次抓一张牌然后插入到已经有的牌当中，原来抓到手的牌是有序的，插入之后还是有序的。
    // 每次抓取一张牌
    for (int i = 1; i < soft.count - 1; i ++) {
        // 如果当前牌索引大于0，并且前一张牌比后一张牌大
        // 如果判断的时候，相等，那么是不稳定排序，会交换两个相等的元素的位置，这里只是compare为大于
        // 时间复杂度取决于逆序对的数量，如，10，9，8，3，2，1，【10，1】，【9，2】，【8，3】，互为逆序对，最后面的牌，需要经历很远的路程，才可以排到前面
        // 时间复杂度与逆序对的数量成正比
        // 逆序对的数量越多，插入排序的时间复杂度越高
        // 时间复杂度为O(n^2),最好的时间复杂度为O(n),如果没有逆序对，就是最优的情况
        // 属于稳定排序
        // 数量不大的时候，插入排序的效率很高
        int index = i;
        while (index > 0 && [self compareA:soft[index - 1] valueB:soft[index]]) {
            // 交换牌的位置
            NSNumber *tmp = soft[index];
            soft[index] = soft[index - 1];
            soft[index - 1] = tmp;
            
            // 一次向前推，直到排到最前面有序的位置
            index --;
        }
    }
    return soft.copy;
}
- (BOOL)compareA:(NSNumber *)valueA valueB:(NSNumber *)valueB{
    return valueA.intValue > valueB.intValue;
}
@end
```

#### 快速排序
- 思想：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序
- 说明：最核心的思想是将小的部分放在左边，大的部分放到右边，实现分割。
- 快速排序算法通过多次比较和交换来实现排序，其排序流程如下：
    * 首先设定一个分界值，通过该分界值将数组分成左右两部分。
    * 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
    * 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
    * 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。
- 算法复杂度
    * 最好的情况下：因为每次都将序列分为两个部分(一般二分都复杂度都和logN相关)，故为 O(N*logN)
    * 最坏的情况下：基本有序时，退化为冒泡排序，几乎要比较N*N次，故为O(N*N)
- 稳定性
    * 由于每次都需要和中轴元素交换，因此原来的顺序就可能被打乱。如序列为5 3 3 4 3 8 9 10 11会将3的顺序打乱。所以说，快速排序是不稳定的！
- 代码

```
//
//  SCXQuickSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/14.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXQuickSoft.h"
@interface SCXQuickSoft()
@property(nonatomic,strong) NSMutableArray *softArr;
@end
@implementation SCXQuickSoft
-(NSArray *)soft:(NSArray<NSNumber *> *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    self.softArr = soft;
    [self beginSoft:0 end:soft.count];
    return soft.copy;
}
- (void)beginSoft:(NSInteger)begin end:(NSInteger)end{
    if (end - begin < 2) {
        return;
    }
    // 找到轴点，然后依次在进行分割
    // 时间复杂度 O(n)
    NSInteger pivotIndex = [self pivotIndex:begin end:end];
    // 左半边
    // T(n/2)
    [self beginSoft:begin end:pivotIndex];
    // 右半边
    // T(n/2)
    [self beginSoft:pivotIndex+1 end:end];
    // 如果左右分布均匀，此时为最好的情况想，总时间复杂度 T(n) = 2 * T(n/2) + O(n) = O(nlogn)
    // 如果分布不均匀，如，7，6，5，4，3，2，1，7 为轴点，7右边的都比7小，那么需要将每一个都调到7的左边
    // T(n) = T(n - 1) + O(n) =O(n^2)
}

/// 获取轴点位置，也就是那个分割点的位置，每次将序列分为两个，这个分割点的左边都比这个轴点小，右边都比这个轴点大
/// @param begin 开始位置
/// @param end 结束位置
- (NSInteger)pivotIndex:(NSInteger)begin end:(NSInteger)end{
    /*
     1.取出第一元素来一次进行比较，从后往前比较
     2.如果后面的元素比当前元素大，那么不用动，然后end--
     ,如果发现后面的元素小于等于当前轴点元素，那么将end的位置的元素，
     覆盖当前begin位置的元素，然后从begin开始比较,
     调到步骤3
     3.如果发现当前元素大小比轴点元素大小小，那么begin++，
     如果当前元素比轴点元素大，那么将begin位置的元素赋值给end，
     然后再从end往回比较，
     调到步骤2.
     
     */
    
    // 为了优化，随机选择一个元素和begin位置元素作为交换，不要每次都选第一个，有局限性
    int rand = begin + (arc4random() %(end - begin + 1));
    NSNumber *tmp = self.softArr[begin];
    self.softArr[begin] = self.softArr[rand];
    self.softArr[rand] = tmp;
    
    // 1. 取出来第一个元素，当做轴点元素,备份
    NSNumber *first = self.softArr[begin];
    // 最后一个元素的位置
    end --;
    // begin 和 end 没有重合
    while (begin < end) {
        // 最后一个元素，从后往前走
        while (begin < end) {
            // 取出最后一个元素，然后和轴点元素比较
            NSNumber *last = self.softArr[end];
            // 2. 从后往前比较，如果后面的比前面大，那么不用交换，end--
            if (last.intValue > first.intValue) {
                // 2. 后面的大，一直往前走就可以
                end --;
            } else {
                // 2. 后面的比前面的小或者等于，需要调换位置
                // 2. 将end元素覆盖到begin位置，然后begin++，然后调用，从begin开始，从前往后比较。
                self.softArr[begin++] = last;
                break;
            }
        }
        
        // 如果这时候begin和end重合了，那么久说明找到了
        // 3.如果没有重合，就说明掉头了，需要从前往后走
        while (begin < end) {
            // 3。取出第一个元素，和当前轴点元素作比较
            NSNumber *last = self.softArr[begin];
            // 3.如果当前元素比轴点元素小，那么只需要begin++ 就可以，继续向后找
            // 等于放到下面是为了均匀分割，分布均匀之后，效率会大大增高，差别很大
            if (first.intValue > last.intValue) {
                begin ++;
            } else {
                // 3. 如果当前位置元素比轴点元素大，那么需要将这个begin位置的元素，覆盖到end位置，然后end--；
                // 2. 然后跳到步骤2，从后往前走
                self.softArr[end--] = last;
                break;;
            }
        }
        
    }
    // 然后将备份的元素放到轴点位置
    self.softArr[begin] = first;
    // 当开始哨兵和结束的哨兵位置重合的时候，就是轴点的位置，说明已经分割好了
    return begin;
}
@end
```

#### 堆排序
- 思想：
    * 堆排序实际上是对选择排序的一个优化，选择排序每次都要选出一个最大值，相当于从头遍历到尾去选择最大值，时间复杂度为O(n)，在加上外层遍历n-1次，所有时间复杂度为O(n^2)，而堆排序在选择最大值的时候有优势，所以堆排序是对选择排序的一个优化。
    * 利用完全二叉树中双亲节点和孩子节点之间的内在关系，在当前无序区中选择关键字最大(或者最小)的记录。也就是说，以最小堆为例，根节点为最小元素，较大的节点偏向于分布在堆底附近。

![image](https://upload-images.jianshu.io/upload_images/6370252-ba7f66b5e558da7f.png?imageMogr2/auto-orient/strip|imageView2/2/w/431)

- 操作流程
    * 对数组元素进行原地建堆，然后执行后面的操作，直到堆的元素数量为1
    * 交换堆顶元素与尾元素，相当于最大值和最小值的交换
    * 然后将堆的数量减去一
    * 因为堆顶元素被交换之后不符合大顶堆或者小顶堆的要求，需要对0位置的元素进行一次 siftDown 下滤操作。
- 算法复杂度
    * 最坏情况下，接近于最差情况下：O(N*logN)，因此它是一种效果不错的排序算法。
- 稳定性
    * 堆排序需要不断地调整堆，因此它是一种不稳定的排序！
- 代码

```
//
//  SCXHeapSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/11.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXHeapSoft.h"
@interface SCXHeapSoft(){
    
    int _size;
}

@end
@implementation SCXHeapSoft
-(NSArray *)soft:(NSArray *)arr{
    // 建堆
    NSMutableArray *soft = arr.mutableCopy;
    _size = soft.count;
    // 自下而上下滤
    for (NSInteger i = (_size >> 1) - 1; i >= 0; i --) {
        [self siftDown:i arr:soft];
    }
    while (_size > 1) {
        // 将堆顶和堆尾元素互换
        // size --
        NSNumber *tmp = soft[--_size];
        soft[_size] = soft[0];
        soft[0] = tmp;
        
        // 将第0个元素下滤，保证除了最后一个元素之外，其余的元素组成一个堆
        [self siftDown:0 arr:soft];
    }
    return soft.copy;
}
// 下滤
- (void)siftDown:(NSInteger)index arr:(NSMutableArray *)_array{
    //第一个叶子节点的索引就是非叶子节点的数量，因为为完全二叉树，所以，要么没有左右子节点，要么只有左节点，不可能出现只有右子节点的情况
    // index < 第一个叶子节点的索引，这样就能保证他能和有子节点的进行交换
    // 必须保证index 位置为非叶子节点，因为这样可以找到左节点，或者左右节点，进行交换
    // 非叶子节点的数量为 二叉树节点数量除以二
    if (index >= _array.count) {
        return;
    }
    id obj = _array[index];
    // 第一个非叶子节点的索引
    NSInteger half = _size >> 1;
    while (index < half) {
        // 要么只有左子节点
        // 要么右左右子节点
        // 左子节点的索引为 2i +1 ,右子节点的索引为 2i+2
        NSInteger leftIndex = (index << 1) + 1;
        id leftObjf = _array[leftIndex];
        NSInteger rightIndex = leftIndex +1;
        
        
        // 选出最大值
        id maxObj = leftObjf;
        NSInteger maxIndex = leftIndex;
        if (rightIndex < _size ) {
            id rightObj = _array[rightIndex];
            if ([self compareA:rightObj valueB:leftObjf]) {
                // 右节点比左节点大
                maxObj = rightObj;
                maxIndex = rightIndex;
            }
        }
        
        // 选出左右最大的节点和index之后，和当前节点进行比较
        if ([self compareA:obj valueB:maxObj]) {
            // 如果当前节点比左右子节点中最大的那一个都打大，就退出不用交换了
            break;
        }
        // 如果当前节点比左右节点中的其中一个小，那么将当前位置，赋值为最大值,将最大值一次上滤，然后自己下沉，记住位置
        _array[index] = maxObj;
        index = maxIndex;
    }
    _array[index] = obj;
}
- (BOOL)compareA:(NSNumber *)valueA valueB:(NSNumber *)valueB{
    return valueA.intValue > valueB.intValue;
}
@end
```

#### 冒泡排序
- 基本思想：通过无序区中相邻记录关键字间的比较和位置的交换,使关键字最小的记录如气泡一般逐渐往上“漂浮”直至“水面”。
- 原理
    * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
    * 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
    * 针对所有的元素重复以上的步骤，除了最后一个。
    * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
- 时间复杂度
    * 最好情况下：正序有序，则只需要比较n次。故，为O(n)
    * 最坏情况下:逆序有序，则需要比较(n-1)+(n-2)+……+1，故，为O(N*N)
- 稳定性
    * 排序过程中只交换相邻两个元素的位置。因此，当两个数相等时，是没必要交换两个数的位置的。所以，它们的相对位置并没有改变，冒泡排序算法是稳定的！
- 代码

```
//
//  SCXBubbleSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/11.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXBubbleSoft.h"

@implementation SCXBubbleSoft
-(NSArray *)soft:(NSArray *)arr{
    // 改进，因为冒泡排序每次是找到最大值，比如遍历之后，后面四个已经是有序的，那么每次就不需要遍历后面几个了，记住最开始的那个有序的位置就可以了
    NSMutableArray *soft = arr.mutableCopy;
    for (int i = soft.count - 1 ; i > 0; i --) {
        int end = 1;
        for ( int j = 1; j <= i; j ++) {
            NSNumber *pre = soft[j - 1];
            NSNumber *current = soft[j];
            if (pre.intValue > current.intValue) {
                NSNumber *tmp = pre;
                soft[j - 1] = current;
                soft[j] = tmp;
                // 当前排序的索引
                end = j;
            }
        }
        // 如果上面的for循环里面的 end 没有赋值，说明就没有交换，说明就是有序的，就不需要排序了
        i = end;
    }
    return soft.copy;;
}
-(NSArray *)soft1:(NSArray *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    for (int i = 0 ; i < soft.count - 1; i ++) {
        for ( int j = 1; j < soft.count - 1 - i; j ++) {
            NSNumber *pre = soft[j - 1];
            NSNumber *current = soft[j];
            if (pre.intValue > current.intValue) {
                NSNumber *tmp = pre;
                soft[j - 1] = current;
                soft[j] = tmp;
            }
        }
        
    }
    return soft.copy;;
}
@end
```

#### 选择排序
- 思想：选择排序是一种简单直观的[排序算法]。它的工作原理是：第一次从待排序的[数据元素]中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。
- 思路：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

![image](https://upload-images.jianshu.io/upload_images/6370252-9048e08e9155b963.png?imageMogr2/auto-orient/strip|imageView2/2/w/275)

- 时间复杂度
    * 最好情况下：交换0次，但是每次都要找到最小的元素，因此大约必须遍历N*N次，因此为O(N*N)。减少了交换次数！
    * 最坏情况下，平均情况下：O(N*N)
- 稳定性
    * 选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法
- 代码

```
//  SCXSelectionSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/11.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXSelectionSoft.h"

@implementation SCXSelectionSoft
-(NSArray *)soft:(NSArray *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    // 需要遍历多少趟
    for (int i = soft.count - 1; i > 0; i --) {
        
        // 假设最大的是第一个元素
        int index = 0;
        // 每次遍历除了最后几个已经排好序的元素之外，其余的元素
        // 如果当前的元素比最大值的这个位置的元素要大，更改最大值的位置，继续遍历
        for (int j = 1 ; j <= i; j ++) {
            NSNumber *current = soft[j];
            NSNumber *max = soft[index];
            if (current.intValue > max.intValue) {
                index = j;
            }
        }
        // 找到最大元素的位置，将其放到最后
        if (index != i) {
            NSNumber *tmp = soft[i];
            soft[i] = soft[index];
            soft[index] = tmp;
        }
    }
    return soft.copy;
}
@end
```

#### 希尔排序
- 思想：希尔排序也是一种插入排序方法,实际上是一种分组插入方法。先取定一个小于n的整数d1作为第一个增量,把表的全部记录分成d1个组,所有距离为d1的倍数的记录放在同一个组中,在各组内进行直接插入排序；然后,取第二个增量d2(＜d1),重复上述的分组和排序,直至所取的增量dt=1
- 时间复杂度
    * 最好情况：由于希尔排序的好坏和步长d的选择有很多关系，因此，目前还没有得出最好的步长如何选择(现在有些比较好的选择了，但不确定是否是最好的)。所以，不知道最好的情况下的算法时间复杂度。
    * 最坏情况下：O(N*logN)，最坏的情况下和平均情况下差不多。
    * 平均情况下：O(N*logN)
- 稳定性
    * 由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。
- 代码

![image](https://upload-images.jianshu.io/upload_images/6370252-b07115db43096672.png?imageMogr2/auto-orient/strip|imageView2/2/w/522)

#### 归并排序
- 思想：不断的将当前序列，分割成两个子序列,直到分割到一个元素不能分割为止，不断的将两个子序列合并成一个有序序列，直到最后只剩下一个有序序列。
- 算法时间复杂度
    * 最好的情况下：一趟归并需要n次，总共需要logN次，因此为O(N*logN)
    * 最坏的情况下，接近于平均情况下，为O(N*logN)
    * 对长度为n的文件，需进行logN 趟二路归并，每趟归并的时间为O(n)，故其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlgn)。

![image](https://upload-images.jianshu.io/upload_images/6370252-96053f74b9b11315.png?imageMogr2/auto-orient/strip|imageView2/2/w/360)

- 稳定性
    * 归并排序最大的特色就是它是一种稳定的排序算法。归并过程中是不会改变元素的相对位置的。
- 缺点
    * 它需要O(n)的额外空间。但是很适合于多链表排序。
- 代码

```
//  SCXMergeSoft.m
//  TestArithmetic
//
//  Created by 孙承秀 on 2020/7/13.
//  Copyright © 2020 孙承秀. All rights reserved.
//

#import "SCXMergeSoft.h"
/*
 1. 不断的将当前序列，分割成两个子序列,直到分割到一个元素不能分割为止
 2. 不断的将两个子序列合并成一个有序序列，直到最后只剩下一个有序序列
 */
@interface SCXMergeSoft()
@property (nonatomic , strong) NSMutableArray *softArr;
@property (nonatomic , strong) NSMutableArray *leftArr;
@end
@implementation SCXMergeSoft
- (NSArray *)soft:(NSArray<NSNumber *> *)arr{
    NSMutableArray *soft = arr.mutableCopy;
    self.softArr = soft;
    self.leftArr = [NSMutableArray arrayWithCapacity:(soft.count) >> 1];
    [self binary:0 end:soft.count];
    return soft.copy;;
}
- (void)binary:(int)begin end:(int) end{
    // 至少要有两个元素
    if (end - begin < 2) {
        return;
    }
    int mid = (end + begin ) >> 1;
    // 将左边的不断的拆分，直到拆分到一个元素
    [self binary:begin end:mid];
    // 将右边的不断的拆分，直到拆分到一个元素
    [self binary:mid end:end];
    // 不断的将两个元素合并
    [self merge:begin mid:mid end:end];
}
/*
 merge 的原理:
 比如一个数组[1,6,2,7,3,8,4,9];
 1.我们经过不断的拆分之后变成1,6  2,7 3,8 4,9 ,这样的
 2. 然后将上面拆分出来的一个一个数据，两个连个再次合并到一起，[1,6],[2,7],[3,8],[4,9]
 然后再变成[1,2,6,7],[3,4,8,9]
 然后再变成[1,2,3,4,6,7,8,9];
 这个流程
 3.其实我们最终的目的其实就是将所有的元素合并到一个大数组里面，其实我们的最后[1,2,3,4,6,7,8,9];，一次，这个数据就是最终的大数组，而他是由之前的两份数据得来的，所以我们可以将大数组拆分成一个小数组，然后每次将小数组的元素和当前大数组剩余的元素作比较，然后依次比较添加，什么意思呢？
 
 将 [1,2,3,4,6,7,8,9]; ，的左一半copy出来，其余元素不变，也就是
 [1,2,3,4,6,7,8,9]; 和 [1,2,3,4,];
 或者你可以理解为
 [null,null,null,null,6,7,8,9]; 和 [1,2,3,4]; 最后将这两个合并不就是 [1,2,3,4,6,7,8,9];吗
 
 
 */
- (void)merge:(int)begin mid:(int)mid end:(int) end{
    // 定义标记,对应于数组的索引
    // 左边的开始位置的标记
    int lb = 0;
    // 左边的结束位置的标记
    int le = mid - begin;
    // 右边开始位置的标记
    int rb = mid;
    // 右边结束位置的标记
    int re = end;
    // 整个大数组的标记
    int ab = begin;
    
    // 左边备份的数组
    for (int i = lb; i < le; i ++) {
        self.leftArr[i] = self.softArr[begin + i];
    }
    NSLog(@"----%@",self.leftArr);
    // 左右进行比对
    while (lb < le) {
        // 左边没有排完，就将左边的依次放到大数组里面
        // 如果左边排完了，右边不动就行
        // 判断如果左边拿出来的元素比右边拿出来的元素小，就放到大数组里面
        NSNumber *left = self.leftArr[lb];
        NSNumber *right = self.softArr[rb];
        // 如果右边的大或者右边排完了，那么就跳出来这if，跑到下面去，因为右边的大，肯定是将左边放进去，或者右边的所有元素都取完了，那么也跑到else里面
        if (rb< re && left.intValue > right.intValue ) {
            // 如果左边的大于等于右边的，就将右边的放入大数组的前面
            self.softArr[ab++] = right;
            rb++;
        } else {
            // 如果右边的比左边大或者等于左边当前取出的，就将左边的先取出来放到数组里面，这样可以保证算法的稳定性
            self.softArr[ab++] = left;
            lb++;
            
        }
    }
    NSLog(@"~~~~~%@",self.softArr);
}
@end
```

#### 基数排序
- 思想：它是一种非比较排序。它是根据位的高低进行排序的，也就是先按个位排序，然后依据十位排序……以此类推。
- 示例如下：

![image](https://upload-images.jianshu.io/upload_images/6370252-46b92b43b25fa8f0.png?imageMogr2/auto-orient/strip|imageView2/2/w/899)

![image](https://upload-images.jianshu.io/upload_images/6370252-f165a8bada6ae8d8.png?imageMogr2/auto-orient/strip|imageView2/2/w/907)

- 算法的时间复杂度
    * 分配需要O(n),收集为O(r),其中r为分配后链表的个数，以r=10为例，则有0～9这样10个链表来将原来的序列分类。而d，也就是位数(如最大的数是1234，位数是4，则d=4)，即"分配-收集"的趟数。因此时间复杂度为O(d*(n+r))。
- 稳定性
    * 基数排序过程中不改变元素的相对位置，因此是稳定的！
- 适用情况：如果有一个序列，知道数的范围(比如1～1000)，用快速排序或者堆排序，需要O(N*logN)，但是如果采用基数排序，则可以达到O(4*(n+10))=O(n)的时间复杂度。算是这种情况下排序最快的！

### 常见的字符编码方法
#### ASCII
#### ISO-8859-1
#### GB2312
#### GBK
#### UTF-8
#### UTF-16
#### Unicode

### 常考算法题
#### 1.字符串反转
- 做法就是，设立两个begin和end哨兵，然后将这两个哨兵对应的值进行交换，当 begin >=end 的时候结束

```
void reverseStr(char *chr){
    char *begin = chr;
    char *end = chr + strlen(chr) - 1;
    while (begin < end) {
        char temp = *begin;
        *(begin ++) = *end;
        *(end --) = temp;
    }
}
```

#### 2.链表反转
- 1->2->3->4->NULL 听过反转之后变成 4->3->2->1->NULL

##### 头插法：
- 头插法需要我们定义一个新的头结点作为新的链表，然后利用头插法，将原来的链表的每一个节点取出来，然后去新的链表里面做头插法，这样就可以反转了，这里需要一个新的头结点，和遍历原来链表的一个P指针。

```
/// 构造一个链表
struct Node *constructList(void){
    // 当前节点
    struct Node *cur = NULL;
    // 头结点
    struct Node *head = NULL;
    for (int i = 1 ; i < 5 ; i ++) {
        struct Node *node = malloc(sizeof(struct Node));
        node->data = i;
        // 如果头结点为空
        if (head == NULL) {
            // 将当前节点赋值为头结点
            head = node;
        } else {
            // 将当前节点的next指向这个新的节点，形成链表
            cur->next = node;
        }
        // 将当前节点赋向后移动
        cur = node;
    }
    cur->next = NULL;
    return head;
}
```
- 上面的代码是构造一个链表，构造一个链表的思想就是，创建一个节点，然后如果当前有头结点，就将当前节点的next指向新创建的节点，然后将当前节点向后移动，如果当前没有头结点，就将头结点和当前节点都赋值为新创建的节点

```
/// 链表的反转
/// @param head 头结点
struct Node * reverseList(struct Node *head){
    // 新链表哨兵指针
    struct Node *newHead = NULL;
    // 旧链表哨兵指针
    struct Node *p = head;
    // 旧链表遍历完毕
    while (p != NULL) {
        // 下一个节点
        struct Node *temp = p->next;
        // 将这个节点头插到新的链表里面
        p->next = newHead;
        // 更改新链表的头位置
        newHead = p;
        // 旧链表的头向后移动
        p = temp;
    }
    return newHead;
}
```
- 上面的代码是反转一个链表，反转链表的思想就是新建一个链表然后利用头插法，先从原来的链表里面按照顺序一个个取，取出来之后到新的链表里面进行头插，就形成了头插。

#### 3.有序数组合并
- 第一种方法：始终比较两个数组的首元素大小，然后将小者 shift 出来push到结果数组中去，因为总是会将数组首元素较小的那个移出，故不用改变比较数组的索引值，一直固定为 0 就行了。最后不要忘记将长度值大于 0 的数组中的元素移出放置到结果数组中。

```
/* 清空了原来的两个有序数组 */
function mergeTwoSortedArr (arr1, arr2) {
  var retArr = [];
  /* 遍历比较两个数组的首元素大小，小者 shift 出来 push 到结果数组中去 */
  while (arr1.length > 0 && arr2.length > 0) {
    if (arr1[0] < arr2[0]) {
      retArr.push(arr1.shift());
    } else if (arr1[0] > arr2[0]) {
      retArr.push(arr2.shift());
    } else {
      retArr.push(arr1.shift());
      retArr.push(arr2.shift());
    }
  }
  /* 将数组（最多有一个）剩余元素移出放置到结果数组中 */
  while (arr1.length > 0) {
    retArr.push(arr1.shift());
  }
  while (arr2.length > 0) {
    retArr.push(arr2.shift());
  }
  return retArr;
}

// 示例
var arr1 = [2, 3, 5];
var arr2 = [3, 4, 7, 9];
console.log(mergeTwoSortedArr(arr1, arr2));   // [2, 3, 3, 4, 5, 7, 9]
```
- 第二种：没有影响原来的两个有序数组，通过遍历比较两个数组当前元素的大小，小者push到结果数组中去，相应数组索引加一，然后再进行循环比较。同样，最后不要忘记将未遍历过的数组元素复制到结果数组中。

```
/* 未对原来的两个有序数组做改动 */
function mergeTwoSortedArr (arr1, arr2) {
  var retArr = [];
  var len1 = arr1.length;
  var len2 = arr2.length;
  var i = 0, j = 0;
  /* 遍历比较两个数组当前元素的大小，小者 push 到结果数组中去，相应数组索引加一 */
  while (i < len1 && j < len2) {
    if (arr1[i] < arr2[j]) {
      retArr.push(arr1[i]);
      i++;
    } else if(arr1[i] > arr2[j]) {
      retArr.push(arr2[j]);
      j++;
    } else {
      retArr.push(arr1[i], arr1[i]);
      i++;
      j++;
    }
  }
  /* 将数组（最多有一个）剩余元素 push 到结果数组中 */
  for (; i < len1; i++) {
    retArr.push(arr1[i]);
  }
  for (; j < len2; j++) {
    retArr.push(arr2[j]);
  }
  return retArr;
}

// 示例
var arr1 = [2, 3, 5];
var arr2 = [3, 4, 7, 9];
console.log(mergeTwoSortedArr(arr1, arr2));   // [2, 3, 3, 4, 5, 7, 9]
```
#### 4.假设某个数组中只有数字1和2，进行排序，使得数字1位于数组前部分，数字2位于后部分
- 使用双指针的方法
- 解法步骤：
    * 设置一个头指针、一个尾指针，头指针首先指向数组的第一个元素（索引为0），而尾指针则指向数组的最后一个元素（索引为len-1，假定数组的长度为 len）；
    * 然后比较这两个一前一后元素的大小：
        * 若两值不相等，则较小的 1 放在前面，较大的 2 放在后面，头指针往后移动一步，尾指针向前移动一步；
        * 若两值相等且都等于1，则头指针往后移动一步，尾指针不移动；
        * 若两值相等且都等于2，则尾指针往前移动一步，头指针不移动。
    * 接着再次比较头、尾指针指向元素的大小，决定是否交换值以及移动指针；
    * 依照以上步骤进行指针移动、元素大小比较，便可使得数字1位于数组前部分，数字2位于数组后部分。
- 注意点：上面循环进行操作的条件是头指针索引值小于尾指针索引值。
- 代码

```
function sortOneTwoInArr (arr) {
  var len = arr.length;
  var head = 0;
  var tail = len - 1;
  /* 遍历数组，对 1 和 2 进行排序 */
  while (head < tail) {
    // 若头、尾指针指向的元素大小相等则只移
    // 动一个指针，否则同时移动两个指针
    if (arr[head] === arr[tail]) {
      if (arr[head] === 1) {
        head++;
      } else if (arr[head] === 2) {
        tail--;
      }
    } else {
      if (arr[head] > arr[tail]) {
        [arr[head], arr[tail]] = [arr[tail], arr[head]];
      }
      head++;
      tail--;
    }
  }
  return arr;
}

/* 测试用例 */
var arr1 = [];
var arr2 = [1];
var arr3 = [2];
var arr4 = [1, 2, 1, 2];
var arr5 = [1, 1, 2, 2];
var arr6 = [1, 2, 2, 1, 1];
var arr7 = [2, 2, 1, 1, 2];
console.log(sortOneTwoInArr(arr6));            // [1, 1, 1, 2, 2]
```

#### 5.查找第一个只出现一次的字符
- 方式一：
    * 遍历每一个字符，然后取出遍历的当前字符与剩下的字符做比较，判断剩下的字符串中是否有当前遍历的这个字符，如果没有，则是在字符串中出现一次的，而第一个出现的，就是要查找的。

```
/**
     * 使用便利的方式，时间复杂度是O(n^2)
     * @param str
     */
    private static void printFirstCharOnlyOnce(String str) {
        for (int i = 0; i < str.length(); i++) {
            // 截去第i个字符
            String temp = str.substring(0, i) + str.substring(i + 1);
            // 判断截去第i个字符后剩下的字符串中是否还有与第i个字符相同的字符
            int index = temp.indexOf(str.charAt(i));
            // 如果剩下的字符中没有与第i个字符相同的字符存在，则返回-1
            // 第一次出现index=-1的时候，说明第i个字符就是第一个出现一次的字符
            if (index == -1) {
                String c = String.valueOf(str.charAt(i));
                System.out.println(c);
                break;
            }
        }
    }
```
- 方式二：
    * 直接使用hash表来查询，即使用HashMap来实现；首先遍历字符串的每一个字符，将字符作为HashMap的key，然后使用Integer作为HashMap的value，当key相同的时候，value就加1。遍历完之后，再对HashMap做遍历，找出key对应的value=1的key，第一个key就是查找第一个只出现一次的字符

```
/**
    * 时间复杂度为O(n)
    */
    private static void printFirstCharOnlyOnce(String str) {
        HashMap<Character, Integer> hashMap = new HashMap<>();
        for (int i = 0; i < str.length(); i++) {
            if (hashMap.containsKey(str.charAt(i))) {
                int value = hashMap.get(str.charAt(i));
                hashMap.put(str.charAt(i), value + 1);
            } else {
                hashMap.put(str.charAt(i), 1);
            }
        }

        for (int i = 0; i < str.length(); i++) {
            if (hashMap.get(str.charAt(i)) == 1) {
                System.out.println(str.charAt(i));
                break;
            }
        }
    }
```
- 方式三：
    * 借助ASCII码，将字符的ASCII码作为在int数组的索引位置，而该字符出现的次数就是对应的int数组的索引位置的值

```
private static void printFirstCharOnlyOnce(String str) {
        int[] hash = new int[256];
        for (int i = 0; i < str.length(); i++) {
            int temp = str.charAt(i);
            hash[temp]++;
        }

        for (int i=0;i<str.length();i++) {
            int temp = str.charAt(i);
            if (hash[temp] == 1) {
                System.out.println(str.charAt(i));
                break;
            }
        }
    }
```

#### 6.查找两个子视图的共同父视图

```
- (NSArray <UIView *> *)findCommonSuperView:(UIView *)viewOne other:(UIView *)viewOther
{
    NSMutableArray *result = [NSMutableArray array];
    
    // 查找第一个视图的所有父视图
    NSArray *arrayOne = [self findSuperViews:viewOne];
    // 查找第二个视图的所有父视图
    NSArray *arrayOther = [self findSuperViews:viewOther];
    
    int i = 0;
    // 越界限制条件
    while (i < MIN((int)arrayOne.count, (int)arrayOther.count)) {
        // 倒序方式获取各个视图的父视图
        UIView *superOne = [arrayOne objectAtIndex:arrayOne.count - i - 1];
        UIView *superOther = [arrayOther objectAtIndex:arrayOther.count - i - 1];
        
        // 比较如果相等 则为共同父视图
        if (superOne == superOther) {
            [result addObject:superOne];
            i++;
        }
        // 如果不相等，则结束遍历
        else{
            break;
        }
    }
    
    return result;
}

- (NSArray <UIView *> *)findSuperViews:(UIView *)view
{
    // 初始化为第一父视图
    UIView *temp = view.superview;
    // 保存结果的数组
    NSMutableArray *result = [NSMutableArray array];
    while (temp) {
        [result addObject:temp];
        // 顺着superview指针一直向上查找
        temp = temp.superview;
    }
    return result;
}
```

#### 7.无序数组中的中位数
- 中位数，就是数组排序后处于数组最中间的那个元素。如果数组长度是奇数，最中间就是位置为(n+1)/2的那个元素；如果数组长度是偶数，中位数就是位置n/2和位置为n/2+1的两个元素的和除以2的结果。
- 第一种方法是先排序，然后找中位数；第二种方法是，用快速排序，然后找中位数
- 基于快速排序查找中位数
    * 定义一个key，一般取数组最右边的元素为key，然后再定义两个变量start和end
    * start为首元素索引，end为尾元素索引
    * 然后从后往前找，找到第一个比key小的元素，没找到则end--，找到则将当前start位置的元素值置为当前end位置的元素值
    * 然后再start++
    * 接着再从前往后找，找到第一个比key大的元素，没找到则start++，找到则将当前end位置的元素值置为当前start位置的元素值
    * 最后当start==end的时候，将当前start位置的元素值置为key
    * 接着递归调用，按当前start==end的位置，分成两半
    * 左边到start-1，右边从start+1开始
    * 求中位数，如果数组长度为奇数，则是第(n+1)/2个，即下标为(n+1)/2-1，如果数组长度为偶数，则是第n/2和n/2+1个之和除以2，即下标为n/2-1和n/2的两个数的和除以2；

```
/**
     * 基于快速排序查找中位数
     * 定义一个key，一般取数组最右边的元素为key，然后再定义两个变量start和end
     * start为首元素索引，end为尾元素索引
     * 然后从后往前找，找到第一个比key小的元素，没找到则end--，找到则将当前start位置的元素值置为当前end位置的元素值
     * 然后再start++
     * 接着再从前往后找，找到第一个比key大的元素，没找到则start++，找到则将当前end位置的元素值置为当前start位置的元素值
     * 最后当start==end的时候，将当前start位置的元素值置为key
     * 接着递归调用，按当前start==end的位置，分成两半
     * 左边到start-1，右边从start+1开始
     *
     * @param array
     * @param left
     * @param right
     */
    private static void quickSortSearchMedian(int[] array, int left, int right) {
        if (left < 0) {
            return;
        }
        if (right >= array.length) {
            return;
        }
        if (left >= right) {
            return ;
        }
        int key = array[left];
        int start = left;
        int end = right;
        while (start < end) {
            // 从右边往左边找，找到第一个小于key的值，则索引--
            while (start < end && array[end] >= key) {
                end--;
            }
            if (start < end) {
                array[start] = array[end];
                start++;
            }
            // 从左边往右边找，找到第一个大于key的值，则索引++
            while (start < end && array[start] <= key) {
                start++;
            }
            if (start < end) {
                array[end] = array[start];
                end--;
            }
        }
        // start == end
        array[start] = key;
        quickSortSearchMedian(array, left, start - 1);
        quickSortSearchMedian(array, start + 1, right);
    }

    /**
     * 求中位数
     * 如果数组长度为奇数，则是第(n+1)/2个，即下标为(n+1)/2-1
     * 如果数组长度为偶数，则是第n/2和n/2+1个之和除以2，即下标为n/2-1和n/2的两个数的和除以2
     * @param array
     */
    public static void searchMedian(int[] array) {
        quickSortSearchMedian(array, 0, array.length - 1);
        if ((array.length % 2) == 0) {
            int i = array[array.length/2-1];
            int j = array[array.length/2];
            System.out.println((i+j)/2.0);
        } else {
            System.out.println(array[(array.length + 1) / 2 - 1]);
        }
    }
```

#### 8.两数之和为特定值
- 穷举法：O（n^2）
- 采用哈希算法确定某个数是否存在数组中：O（n）
- 先排序，然后从左右两边进行调整

#### 9.求出数组中连续数字的和值

#### 10.白鼠与毒酒的算法问题
- 一个酒窖里有一千桶酒，其中有一桶是毒酒，白鼠喝了毒酒一个星期后会死去。现在问给你多少只白鼠（最少的），在一个星期内确定那桶毒酒。
- 设有 N 桶酒，有一桶是毒酒，编号从0到N-1,最少要 K 只白鼠，显然：
> 当N=2，K=1 
当N=3，K=2 
当N=4，K=2 
4桶酒编号0，1，2，3 
K=2，设有白鼠A和白鼠B 
A喝0,1，B喝0,2 
一星期后，有4种可能状态 
A死B死(0号有毒)，A死B活(1号有毒)，A活B死(2号有毒)，A活B活(3号有毒) 
- 猜想白鼠的最终状态只有死活两种可能，通过白鼠一星期后的状态可以算出毒酒编号
- 很自然想到二进制
> 当N=4时，0=00,1=01,2=10,3=11 
当N=8，K=3 
0=000,1=001,2=010,3=011，4=100，5=101，6=110，7=111 
白鼠A,B,C 
A喝0，1，2，3 (0XX) 
B喝0，1，4，5 (X0X) 
C喝0，2，4，6 (XX0) 
ABC的最终状态可以确定毒酒编号 
当N=1000时，可以类推至少要10只，你可以这样推出这10只白鼠具体是喝哪些编号的酒，规律很明显了 
- 回过来再想想，1000之内的任意一个数都可以用一个10位的二进制数表示(不够的话前面补0),白鼠与数位对应，第几位为0，则说明第几位的白鼠死了，而这个二进制的编号即为毒酒编号

#### 11.背包问题
- 背包问题是指在给定条件下 如何获得最高价值的问题
- 给定一个重量限制，和几种不同物品的价值和重量，每种物品只有一个，寻找能拿到的最大价值是多少
- 背包问题根本指的是，同种物品有且最高只有一个，在给定限制下，如何获得最大收益
- 思路一：枚举：找出所有组合
- 思路二：动态规划
    * 问题的关键在于我们是否要选择当前物品，选取了当前物品是否是最大的价值，做一个n^2的算法
    * 内层循环表示寻找合适的大小，外层循环表示第几件物品，每次内层循环，我们第一个要找的是我们是否能放下当前物品。放下当前物品后，是否比放上一件物品的价值高，选取高者。之后继续查找剩余空间能否放下之前的物品，如果能那么和上一轮的结果比取高者。

```
#include<iostream>
using namespace std;
const int maxn = 1000;
int dp[20];
int value[20],weight[20];

int main(){
    int n,limitw;
    cin>>n>>limitw;
    for (int i=1;i<=n;i++){
        cin>>value[i]>>weight[i];
    }
    cout<<"0 1 2 3 4 5 6 7 8 9 10\n";   //更好的观察算法
    for(int i=1;i<=n;i++){
        for(int j=limitw;j>=weight[i];j--){
            dp[j]=max(dp[j-weight[i]]+value[i],dp[j]);
            cout<<dp[j]<<" ";   //更好的观察算法
        }
        cout<<"\n"; //更好的观察算法
    }

    cout<<dp[limitw];
    return 0;
}
```

#### 补充：多重背包问题
- 有N种物品，第i种物品的体积是C，价值是W，每种物品的数量都是有限的，为N。现有容量为V的背包，放入若干物品，在总体积不超过V的条件下，使总价值尽可能大。
- 每种物品数量为1的多重背包问题，和背包问题一样，把物品拆分成一件一件的；

```
#include<iostream>
using namespace std;
int dp[1010];       //背包大小
int w[10],c[21],n[21];  //价值,体积,数量
int main(){
    int N,V;
    cin>>N>>V;
    for(int i=1;i<=N;i++){
        cin>>w[i]>>c[i]>>n[i];
    }
    for(int i=1;i<=N;i++){  //第几件物品
        for(int j=V;j>=0;j--){  //背包大小，优化空间复杂度一定要反着放
            for(int k=0;k<=n[i];k++){   //这里其实把物品当做一个一个往里面放
                if(j>=c[i]*k){
                    dp[j]=max(dp[j-c[i]*k]+w[i]*k,dp[j]);
                }
            }
        }
    }
    cout<<dp[V]<<endl;
    return 0;
}
```

#### 补充：完全背包问题
- 在多重背包问题上把每种物品的数量取消限制
- 解决思路：转换成多重背包问题
- 因为虽然物品数量没有上限，但其实物品数量的上限就是背包的上限，只需要处理数量*体积<剩余空间。

```
#include<stdio.h>
#include<algorithm>
#include<iostream>
using namespace std;
int dp[1010];       //背包大小
int w[10],c[21];  //价值,体积
int main(){
    int N,V;
    cin>>N>>V;
    for(int i=1;i<=N;i++){
        cin>>w[i]>>c[i];
    }
    for(int i=1;i<=N;i++){  //第几件物品
        for(int j=1;j<=V;j++){  //背包大小
            dp[j]=max(dp[j-c[i]]+w[i],dp[j]);
        }
    }
    cout<<dp[V]<<endl;
    return 0;
}
```

#### 12.实现数组的随机排序（含洗牌算法）
- 有时，我们需要将一个数组内的元素顺序进行打乱，达到随机排序的目的。首先想到的是 Math.random() 方法结合数组的 sort() 方法。
- Math.random() 结合 sort() 方法，Math.random() 方法用于产生一个介于 0 和 1 之间的随机数（含 0 但不包括 1）。数组的 sort() 方法可以有两种用法：
    * 用法一：在不传入可选的函数参数时，将会对数组的每一个元素应用toString()方法，通过比较字符串大小的方式升序排列所有的数组项。
    * 用法二：编写比较函数并作为参数传入，假设有以下比较函数（补充一点关于下面参数 a、b 的说明，若a为数组的第一个元素，则b为第二个元素，依次类推……）
    * 如果你想将a变量排列在变量b的前面位置，则比较函数返回负数（即上述 val 为负数）；若想将 a 变量排列在变量 b 的后面，则返回正数（即上述 val 为正数）；若不需要改变a、b变量之间的顺序，则返回 0（即上述 val 为 0）

```
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
arr.sort(function (a, b) {
  return Math.random() - 0.5;
});
console.log(arr);
```

##### 补充：洗牌算法
- 洗牌原理，该算法需要遍历整个数组，当遍历到第 i（i 为数组元素的索引）个元素时，从 0 到 i 随机挑选出一个数字，记为 index，然后对索引为 i 和 index 的数组元素进行互换，直至遍历结束。如此下来，也即完成了数组的随机排序。
- 代码

```
var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
function shuffle (arr) {
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    // 生成 0 到 i 之间的随机整数
    var index = Math.floor(Math.random() * (i + 1));
    // 使用 ES6 中的解构赋值完成两个变量值的交换
    [arr[i], arr[index]] = [arr[index], arr[i]];
  }
  return arr;
}
console.log('Shuffled arr: ', shuffle(arr));
```

#### 13.在一个数组中找出前四个最大的数字
- 和下面这个题的逻辑差不多

#### 14.最小的K个数，输入n个整数，找出其中最小的K个数
- 第一种方式：普通的排序算法，排序之后自然可以得到最小的k个数，但时间复杂度高达O(NlogN)
- 第二种方式：用快排将数组排序，输出前k小的数。
- 基于快速排序
    * 定义一个key，一般取数组最右边的元素为key，然后再定义两个变量start和end
    * start为首元素索引，end为尾元素索引
    * 然后从后往前找，找到第一个比key小的元素，没找到则end--，找到则将当前start位置的元素值置为当前end位置的元素值
    * 然后再start++
    * 接着再从前往后找，找到第一个比key大的元素，没找到则start++，找到则将当前end位置的元素值置为当前start位置的元素值
    * 最后当start==end的时候，将当前start位置的元素值置为key
    * 接着递归调用，按当前start==end的位置，分成两半
    * 左边到start-1，右边从start+1开始
    * 查找前K小，就从左边输出
- 但上面两种方式是有限制的，需要一次性将全部数据装入内存，对于求解海量数据的top k问题是无能为力的。
- 还有一种方式：BFPRT算法
    * 时间复杂度仅为O(N)
    * 在时间复杂度O(N)内，从无序的数组中找到第k小的数。显而易见的是，如果我们找到了第k小的数，那么想求arr中最小的k个数，只需再遍历一遍数组，把小于第k小的数都搜集起来，再把不足部分用第k小的数补全即可。
    * BFPRT算法的过程
        * 假设BFPRT算法的函数是int select(int[] arr, int k)，该函数的功能为在arr中找到第k小的数，然后返回该数。select(arr, k)的过程如下：
            * 将arr中的n个元素划分成 n/5 组，每组5个元素，如果最后的组不够5个元素，那么最后剩下的元素为一组（n%5 个元素）。时间复杂度O(1)
            * 对每个组进行排序，比如选择简单的插入排序，只针对每个组最多5个元素之间的组内排序，组与组之间不排序。时间复杂度 N/5O(1)
            * 找到每个组的中位数，如果元素个数为偶数可以找下中位数，让这些中位数组成一个新的数组，记为mArr。时间复杂度O(N/5)
            * 递归调用select(mArr, mArr.length / 2)，意义是找到mArr这个数组的中位数x，即中位数的中位数。时间复杂度T(N/2)
            * 根据上面得到的x划分整个arr数组（partition过程），划分的过程为：在arr中，比x小的都在x左边，比x大的都在x右边，x在中间。时间复杂度O(N)
            * 假设划分完成后，x在arr中的位置记为i，关于i与k的相对大小，有如下三种情况：
                * 如果 i = k，说明x为整个数组中第k小的数，直接返回。时间复杂度O(1)
                * 如果 i < k，说明x处在第k小的数左边，应该在x的右边继续寻找，所以递归调用select函数，在右半区寻找第k-i小的数。时间复杂度不超过T(7/10N + 6)
                * 如果 i > k，说明x处在第k小的数右边，应该在x的左边继续寻找，所以递归调用select函数，在左半区寻找第k小的数。时间复杂度同样不超过T(7/10N + 6)
- 针对海量数据的top k问题
    * 实现了一种时间复杂度为O(Nlogk)的有效算法：初始时一次性从文件中读取k个数据，并建立一个有k个数的最大堆，代表目前选出的最小的k个数。然后从文件中一个一个的读取剩余数据，如果读取的数据比堆顶元素小，则把堆顶元素替换成当前的数，然后从堆顶向下重新进行堆调整；否则不进行任何操作，继续读取下一个数据。直到文件中的所有数据读取完毕，堆中的k个数就是海量数据中最小的k个数（如果是找最大的k个数，则使用最小堆）。
- 对于从海量数据(N)中找出TOP K，这种算法仅需一次性将k个数装入内存，其余数据从文件一个一个读即可，所以它是针对海量数据TOP K问题最为有效的算法

#### 15.找出数组中第 k 大的数字及其出现次数
- 比如说数组 [1, 2, 4, 4, 3, 5]，第 2 大的数字是 4，出现了 2 次
- 大体的思路
    * 既然涉及到数字大小的问题，那就要对给定数组进行排序，题目要求“第k大”的数字，故选择降序的方式更有利于后面的查找；
    * 需要遍历数组，对当前遍历到的数组元素的大小排名和 k 值进行比较，若排名大于k值则结束循环；如果排名等于 k 值，则将该数组元素记为第 k 大的数字，且次数加一；
    * 我们先将数组的第一项定为第 1 大的数字，然后比较第一项和第二项是否相等，若相等则第二项也为第 1 大；如果不相等则数组第二项为第 2 大的数字。依次类推，可获知每次遍历的数组元素的大小排名。
- 边界判断
    * 给定的 k 值是否大于或等于 1（保证没有第 0 大的数字），且k值小于或等于数组的长度（因为数组经降序排序后，值最小的数组元素的大小排名值不可能比数组长度值更大）。这条判断隐含了数组不能为空的条件。
    * 遍历结束时，k值不能超出值最小的数组元素的大小排名，若超出了，说明数组中不存在这样的数字。
- 代码

```
function findKthNum (arr, k) {
  var len = arr.length;
  // 对给定的 k 值进行判断，确保 len >= k >= 1
  if (k > len || k < 1) {
    console.log("There doesn't exists the number you want !");
    return;
  }
  // 获得数组的副本
  var _arr = arr.slice();
  // 遍历数组时，当前数组元素的大小排名
  var rank = 1;
  // 第 k 大的数字
  var num = 0;
  // 第 k 大数字的出现次数
  var count = 0;
  // 对 _arr 进行降序排序
  _arr.sort(function (a, b) {
    return b - a;
  });
  for (var i = 0; i < len; i++) {
    var j = i + 1;
    // 对当前数组元素的大小排名和 k 值进行比较，若排名大
    // 于 k 值则结束循环；如果排名等于 k 值，则将该数组
    // 元素记为第 k 大的数字，且次数加一。
    if (rank > k) {
      break;
    } else if (rank == k) {
      num = _arr[i];
      count++;
    }
    // 若当前遍历的数组项与下一项数字不相等，则说明下一个
    // 数字的排名值比当前遍历数字的排名刚好大 1
    if ((j < len) && (_arr[i] != _arr[j])) {
      rank++;
    }
  }
  // 遍历结束时，若最后遍历的数组元素的大小排名小于给定的 k 值，则说
  // 明数组中没有第 k 大的数字，即 k 值超出了所有数组元素的大小排名。
  if (rank < k) {
    console.log("There doesn't exists the number you want !");
  } else {
    console.log('第' + k + '大的数字：' + num, '出现次数：' + count);
  }
}
```
- 测试数据

```
// 正常情况，findKthNum(arr1, 2)
var arr1 = [1, 2, 4, 4, 3, 5];

// 数组为空，findKthNum(arr2, 2)
var arr2 = [];

// k 值小于 1，findKthNum(arr3, 0)
var arr3 = [1, 2, 4, 4, 3, 5];

// k 值大于数组长度，findKthNum(arr4, 7)
var arr4 = [1, 2, 4, 4, 3, 5];

// k 值超出了所有数组元素的大小排名，findKthNum(arr5, 6)
var arr5 = [1, 2, 4, 4, 3, 5];
```

#### 16.假如有 10亿 条数据，每条数据的大小在 10k-100k 之间，我们有一台内存为4G的电脑，如何算出播放次数最多的一条微博？
#### 17.如何打印一个矩阵
- 例如：输出一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字
- 顺时针打印矩阵

##### 思路一：
- 将复杂的矩阵拆解成若干个圈，循环打印矩阵，每次打印其中一个圈，设起点坐标为(start,start)，矩阵的行数为rows，矩阵的列数为columns，循环结束条件为 rows>start * 2，并且columns>start * 2将打印一圈拆解为四部分：
    * 第一步：从左到右打印一行
    * 第二步：从上到下打印一列
    * 第三步：从右到左打印一行
    * 第四步：从下到上打印一列
- 需要注意的是最后一步打印，所以在每一行打印时要做好条件判断:
    * 能走到最后一圈，从左到右必定会打印
    * 结束行号大于开始行号，需要从上到下打印
    * 结束列号大于开始列号，需要从右到左打印
    * 结束行号大于开始行号+1，需要从下到上打印

#### 18.如何验证一个 IP 地址的有效性
- IPv4 地址由十进制数和点来表示，每个地址包含4个十进制数，其范围为 0 - 255
- IPv4 地址内的数不会以 0 开头
- IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。
- 正则表达式

```
String pattern = "^(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])){3}$";
```

```
/**
 * 有效IP地址
 */
public class Code_07_IsValidIP {
    public static String getIp(String ip) {
        if (ip == null || ip.length() == 0) return "Neither";

        if (ip.startsWith(":") || ip.startsWith(".")
                || ip.endsWith(":") || ip.endsWith(".")
        )
            return "Neither";

        String[] split = ip.split("\\.");
        if (split.length == 4) {
            int n = 1;
            for (int i = 0; i < 4; i++) {
                try {
                    n = Integer.parseInt(split[i]);
                    if (n < 0 || n > 255) return "Neither";
                    if (split[i].length() > 1 && (split[i].startsWith("0") || split[i].startsWith(".")))
                        return "Neither";
                } catch (Exception e) {
                    return "Neither";
                }
            }
            return "IPv4";
        } else {
            split = ip.split(":");
            if (split.length == 8) {
                long n = -1;
                for (int i = 0; i < 8; i++) {
                    try {
                        if (split[i].length() > 4 || split[i].startsWith(".")) return "Neither";
                        n = Long.parseLong(split[i], 16);
                        if (n < 0) return "Neither";
                    } catch (Exception e) {
                        return "Neither";
                    }
                }
                return "IPv6";
            } else {
                return "Neither";
            }

        }

    }

    public static void main(String[] args) {
        System.out.println(getIp("256.256.256.256"));
        System.out.println(getIp("2001:0db8:85a3:0:0:8A2E:0370:7334"));
        System.out.println(getIp("172.16.254.1"));
    }
}
```

#### 19.栈中储存着一组无序的数字，不用遍历的方式，如何找出最小值
#### 20.二维数组查找一个值
- 例子：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
- 方法一：穷举法
- 方法二：双索引查找
    * 二维数组是有序的，通过观察发现，若我们选取数组右上角的数字作为查找的起始点，如果等于目标值，则直接返回true；否则：如果大于目标值，则在该列左侧进行查找，如果小于目标值，则在该行下方进行查找。这样重复迭代，每查找一次就缩小查找范围，直到找到要查找的数字，或者查找范围为空。

#### 21.有一个很大的整形数据，转成二进制求1的个数
- 思路一：移位法。位操作。首先，判断这个数的最后一位是否为1，如果为1，那么计算器加1，然后通过右移丢弃掉最后一位，循环执行该操作直到这个数等于0位置。在判断二进制表示的最后一位是否为1时，可以采用与运算来达到这个目的。
- 思路二：一个数的二进制形式中1的个数等于将这个数和这个数减一的值相与，将相与的到的数作为新的数。接着和其减一相与，知道结果变为0，中间的相与的次数。

#### 22.判断一个正数是否是2的乘方
- 思路一：
    * 从int temp = 1开始，每次循环比较是否与number相等，不相等就让temp增大一倍(temp = temp*2)，如此循环比较，直到相等为止。这个方法的时间复杂度是O(LogN)

#### 23.缓存淘汰算法 LRU 和 LFU
- 缓存是一个计算机思维，对于重复的计算，缓存其结果，下次再算这个任务的时候，不去真正的计算，而是直接返回结果，能加快处理速度。当然有些会随时间改变的东西，缓存会失效，得重新计算。
- 比如缓存空间只有2个，要缓存的数据有很多，1，2，3，4，5，那么当缓存空间满了，需要淘汰一个缓存出去，其中淘汰算法有 LRU，LFU，FIFO，SC二次机会，老化算法，时钟工作集算法等等。
- LRU，最近最少使用，把数据加入一个链表中，按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。比如有数据 1，2，1，3，2，此时缓存中已有（1，2）当3加入的时候，得把后面的2淘汰，变成（3，1）
- LFU，最近不经常使用，把数据加入到链表中，按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。比如有数据1，1，1，2，2，3缓存中有（1(3次)，2(2次)）当3加入的时候，得把后面的2淘汰，变成（1(3次)，3(1次)）
- 区别：LRU 是得把 1 淘汰。
- 显然LRU对于循环出现的数据，缓存命中不高比如，这样的数据，1，1，1，2，2，2，3，4，1，1，1，2，2，2.....当走到3，4的时候，1，2会被淘汰掉，但是后面还有很多1，2
- LFU对于交替出现的数据，缓存命中不高比如，1，1，1，2，2，3，4，3，4，3，4，3，4，3，4，3，4......
由于前面被（1(3次)，2(2次)）3加入把2淘汰，4加入把3淘汰，3加入把4淘汰，然而3，4才是最需要缓存的，1去到了3次，谁也淘汰不了它了。

#### 24.LRU缓存机制

> 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key,value)-如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。进阶:你是否可以在 O(1) 时间复杂度内完成这两种操作？
- 思路大概是：维护一个按数据未使用时长升序的双链表（即最近使用的数据放在表头），建立hash表映射至双链表中的结点，并采用拉链法解决哈希冲突，哈希地址采用取余法。
- 最难的是 put 操作，分析一下有几种情形：
    * hash表中已有与该密钥（key）相同的数据，则无论缓存容量是否满，直接替换双链表中结点的数据值，并将其更新至双链表表头；
    * hash表中没有与该密钥（key）的数据，那我们肯定要创建结点来存放该（密钥\数据），分两种情况：
        * 缓存容量没满，那我们直接创建一个hash表的结点和双链表的结点，并存入（密钥\数据）及建立映射，再更新至双链表表头就可以了;
        * 缓存容量满了，这时有两种办法：
            * 删除双链表中最后一个数据结点（即最久未使用的数据），并删除其对应的hash表中的结点，然后和①操作类似；
            删除hash表中最久未使用数据的结点，并根据密钥（key）建立一个新的结点，将其映射至双链表最后一个数据结点，改变该数据结点的密钥\数据值，再对其更新至双链表表头，相当于利用了该数据结点，避免了删除和新增这两步操作。
- 采用的是第二种方法

```
#define Nothingness -1

struct node{
    int key;
    int value;
    struct node* prev;
    struct node* next;
};//双向链表

struct hash{
    struct node* unused;//数据的未使用时长
    struct hash* next;//拉链法解决哈希冲突
};//哈希表结构

typedef struct {    
    int size;//当前缓存大小
    int capacity;//缓存容量
    struct hash* table;//哈希表
    //维护一个双向链表用于记录 数据的未使用时长
    struct node* head;//后继 指向 最近使用的数据
    struct node* tail;//前驱 指向 最久未使用的数据    
} LRUCache;

struct hash* HashMap(struct hash* table, int key, int capacity)
{//哈希地址
    int addr = key % capacity;//求余数
    return &table[addr];
}

void HeadInsertion(struct node* head, struct node* cur)
{//双链表头插法
    if (cur->prev == NULL && cur->next == NULL)
    {// cur 不在链表中        
        cur->prev = head;
        cur->next = head->next;
        head->next->prev = cur;
        head->next = cur;
    }
    else
    {// cur 在链表中
        struct node* fisrt = head->next;//链表的第一个数据结点
        if ( fisrt != cur)
        {//cur 是否已在第一个
            cur->prev->next = cur->next;//改变前驱结点指向
            cur->next->prev = cur->prev;//改变后继结点指向
            cur->next = fisrt;//插入到第一个结点位置
            cur->prev = head;
            head->next = cur;
            fisrt->prev = cur;
        }
    }
}

LRUCache* lRUCacheCreate(int capacity) {
    /*if (capacity <= 0)
    {//传参检查
        return NULL;
    }*/
    LRUCache* obj = (LRUCache*)malloc(sizeof(LRUCache));
    obj->table = (struct hash*)malloc(capacity * sizeof(struct hash));
    memset(obj->table, 0, capacity * sizeof(struct hash));
    obj->head = (struct node*)malloc(sizeof(struct node));
    obj->tail = (struct node*)malloc(sizeof(struct node));
    //创建头、尾结点并初始化
    obj->head->prev = NULL;
    obj->head->next = obj->tail;
    obj->tail->prev = obj->head;
    obj->tail->next = NULL;
    //初始化缓存 大小 和 容量 
    obj->size = 0;
    obj->capacity = capacity;
    return obj;
}

int lRUCacheGet(LRUCache* obj, int key) {
    struct hash* addr = HashMap(obj->table, key, obj->capacity);//取得哈希地址
    addr = addr->next;//跳过头结点
    if (addr == NULL){
        return Nothingness;
    }
    while ( addr->next != NULL && addr->unused->key != key)
    {//寻找密钥是否存在
        addr = addr->next;
    }
    if (addr->unused->key == key)
    {//查找成功
        HeadInsertion(obj->head, addr->unused);//更新至表头
        return addr->unused->value;
    }
    return Nothingness;
}

void lRUCachePut(LRUCache* obj, int key, int value) {
    struct hash* addr = HashMap(obj->table, key, obj->capacity);//取得哈希地址
    if (lRUCacheGet(obj, key) == Nothingness)
    {//密钥不存在
        if (obj->size >= obj->capacity)
        {//缓存容量达到上限
            struct node* last = obj->tail->prev;//最后一个数据结点
            struct hash* remove = HashMap(obj->table, last->key, obj->capacity);//舍弃结点的哈希地址
            struct hash* ptr = remove;
            remove = remove->next;//跳过头结点
            while (remove->unused->key != last->key)
            {//找到最久未使用的结点
                ptr = remove;
                remove = remove->next;
            }
            ptr->next = remove->next;//在 table[last->key % capacity] 链表中删除结点
            remove->next = NULL;
            remove->unused = NULL;//解除映射
            free(remove);//回收资源
            struct hash* new_node = (struct hash*)malloc(sizeof(struct hash));
            new_node->next = addr->next;//连接到 table[key % capacity] 的链表中
            addr->next = new_node;
            new_node->unused = last;//最大化利用双链表中的结点，对其重映射(节约空间)
            last->key = key;//重新赋值
            last->value = value;
            HeadInsertion(obj->head, last);//更新最近使用的数据
        }
        else
        {//缓存未达上限
            //创建(密钥\数据)结点,并建立映射
            struct hash* new_node = (struct hash*)malloc(sizeof(struct hash));
            new_node->unused = (struct node*)malloc(sizeof(struct node));
            new_node->next = addr->next;//连接到 table[key % capacity] 的链表中
            addr->next = new_node;
            new_node->unused->prev = NULL;//标记该结点是新创建的,不在双向链表中
            new_node->unused->next = NULL;
            new_node->unused->key = key;//插入密钥
            new_node->unused->value = value;//插入数据
            HeadInsertion(obj->head,new_node->unused);//更新最近使用的数据
            ++(obj->size);//缓存大小+1
        }
    }
    else
    {//密钥已存在
    // lRUCacheGet 函数已经更新双链表表头，故此处不用更新
        obj->head->next->value = value;//替换数据值
    }
}

void lRUCacheFree(LRUCache* obj) {
    free(obj->table);
    free(obj->head);
    free(obj->tail);
    free(obj);
}
```

#### 25.行间的换页算法有哪些
#### 26.山脉数组找目标值(要求logN的时间复杂度)
- 山脉数组：顶峰向左是递增的；顶峰向右是递减的
- 首先找出顶峰节点，在往两边的递增递减数据使用二分

```

// 找到峰顶
// 在峰顶左边 递增数组
// 在峰顶右边 递减数组
func findPeakSlope(pStart, pEnd int, pMountainArr *MountainArray) int {
    for pStart < pEnd {
        mid := pStart + (pEnd-pStart)/2
        midNum := pMountainArr.get(mid)
        if pMountainArr.get(mid+1) > midNum {
            pStart = mid + 1
        } else {
            pEnd = mid
        }
    }
    return pStart
}

// 递增排序
func FindPositiveSlope(pStart, pEnd, pTarget int, pMountainArr *MountainArray) int {
    mid := (pStart + pEnd) / 2
    for pStart <= pEnd {
        if pMountainArr.get(mid) == pTarget {
            return mid
        }
        if pMountainArr.get(mid) > pTarget {
            pEnd = mid - 1
        } else {
            pStart = mid + 1
        }
        mid = (pStart + pEnd) / 2
    }
    return -1
}

// 递减排序
func FindBackSlope(pStart, pEnd, pTarget int, pMountainArr *MountainArray) int {
    mid := (pStart + pEnd) / 2
    for pStart <= pEnd {
        if pMountainArr.get(mid) == pTarget {
            return mid
        }
        if pMountainArr.get(mid) > pTarget {
            pStart = mid + 1
        } else {
            pEnd = mid - 1
        }
        mid = (pStart + pEnd) / 2
    }
    return -1
}
func findInMountainArray(target int, mountainArr *MountainArray) int {
    // 错误处理
    if mountainArr.length() == 0 {
        return -1
    }
    // 二分查找
    peakIndex := findPeakSlope(0, mountainArr.length()-1, mountainArr)
    if mountainArr.get(peakIndex) == target {
        return peakIndex
    }
    // 递增
    r := FindPositiveSlope(0, peakIndex-1, target, mountainArr)
    if r != -1 {
        return r
    }
    r = FindBackSlope(peakIndex+1, mountainArr.length()-1, target, mountainArr)
    return r
}
```

#### 27.给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
##### 方法一：最笨效率最低的办法，两个for循环，找出出现相同数字的次数

```
- (void)test1{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
   
    for (int i = 0; i < array.count; i++) {
        NSString *itemi = array[i];
         int count = 0;
        for (int j = 0; j<array.count; j++) {
             NSString *itemj = array[j];
            if ([itemi isEqualToString:itemj]) {
                count++;
            }
        }
        if (count == 1) {
            NSLog(@"只出现一次数为：%@", array[i]);
        }
    }
}
```
##### 方法二：利用数组比较元素的方法，如果数组中没有出现该元素则添加，如果该元素出现了则删除该元素

```
- (void)test2{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
    
    NSMutableArray *mArray = [[NSMutableArray alloc] init];
   
    for (int i = 0; i < array.count; i++) {
         NSString *item = array[i];
        if (![mArray containsObject:item]) {
            [mArray addObject:item];
        }else{
            [mArray removeObject:item];
        }
    }
    NSLog(@"只出现一次数为：%@", mArray);
}

```
##### 方法三：直接遍历整个数组，建成hash的数组。最后再遍历一次hash，取出对应key的数组有几个元素，如果有一个元素的key则是要找的只出现一次的元素。

```
- (void)test3{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
    
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    for (int i = 0; i < array.count; i++) {
        NSString *item = array[i];
       // 如果字典中不存在该key
        if (![[dict allKeys] containsObject:item]) {
            NSMutableArray *mArray = [[NSMutableArray alloc] init];
            [mArray addObject:item];
            [dict setObject:mArray forKey:item];
        }
        else{
            // 如果字典中存在key,则取出数组增加元素
            NSMutableArray *mArray = [dict objectForKey:item];
            [mArray addObject:item];
        }
        
    }
    
    NSArray *keyArr = dict.allKeys;
// 遍历字典，取出的数组如果只有一个元素的则是我们要找的
    for (int i = 0; i < keyArr.count; i++) {
        NSString *key = keyArr[i];
        NSMutableArray *arr = [dict objectForKey:key];
        if (arr.count == 1) {
            NSLog(@"只出现一个数为：%@", key);
        }
    }
    
}
```

### 补充：有一个a[1000]的数组，存放1-1000的数，现在有一个数重复了，用一个时间复杂度为N的算法找到重复的数值
- 方法一：将1001个元素相加减去1,2,3,……1000数列的和，得到的差即为重复的元素。

#### 28.100层楼，扔两个鸡蛋，寻找使鸡蛋摔碎的楼层最快要扔多少次？（Google经典的面试题，有一个100层的楼，你手里现在有两个一模一样的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置
- 解释：两个鸡蛋一样，只有在达到某个楼层高度时，才会摔碎。可以假设这个摔碎临界楼层是N。
- 最笨的方法:只用一个鸡蛋遍历——N次尝试
    * 一个鸡蛋遍历那就是从一楼顶开始，逐层尝试，如果摔不碎那就继续往上层尝试，直到N层摔碎了。这样就尝试了N次，而且浪费了一个鸡蛋的使用。
- 二分查找——两个鸡蛋，鸡蛋A用来二分尝试，鸡蛋B用来在A摔碎后做局部遍历尝试
    * 鸡蛋A用来做二分尝试，即第一次从50层扔下。
    * 最悲观情况，直接摔碎，说明N在1-50之间，那么鸡蛋B也只能从1开始遍历，回到了第一种情况（最多尝试次数也是N）。
    * 乐观情况，鸡蛋A没摔碎，接下来就可以尝试从75层扔下，碎了那就是N在51-74之间了。尝试次数为1+1+（74-51）=25次。
    * 更乐观情况，鸡蛋A在75层也没碎，接下来可以在87层扔下；A碎了则N在76-86之间，故是需要1+1+1+（86-76）=13次。
    * A没碎，接下来在93层扔下；A碎了则N在88-92之间，故需要扔1+1+1+1+（92-88）=8次。
    * A没碎，接下来在96层扔下；A碎了则N在94-95之间，故需要扔1+1+1+1+1+（95-94）=6次。
    * A没碎，接下来在98层扔下；A碎了则N在97-98，故需要扔1+1+1+1+1+1=6次。
    * A没碎，则A在99-100之间，如需要扔6+1=7次。
- 可见，用二分法结果很不稳定，特别是N小于50时最糟糕（甚至会比第一种直接遍历的还要多一次）。N越大越好找，需要尝试的次数越少。如果这个题目换成鸡蛋个数不限制，那就是用二分法最快了。
- 平均分割楼层法——假设总共扔X次，其中鸡蛋A扔了X1次，鸡蛋B扔了X2次
    * X=X1+X2
    * 鸡蛋A用来做楼层平均分割，大步尝试；鸡蛋B作为每一小部分的遍历小步尝试。
    * 假设将100层平均分为10部分，即鸡蛋A分别在第10、20、30、40、50、60、70、80、90、100层扔；则鸡蛋B在A摔碎后在细分的那个楼层小步遍历寻找即可。如此的平均尝试次数又要比二分查找更好。
    * 但问题是如何找到最优的平均分割n段，X1=n，X2=100/n。X=n+100/n，可见n平方=100即n等于10时，X=20。
    * 若能在后面每一段更准确地分析出应该分的楼层数（如图2），而不是平均10层一段（如图1），会有更优的效果。下一个方法就是这样。
- 假设法——假设最多允许尝试X次，问能尝试到的最高的楼层。
    * 第1次从X楼扔下来。因为即使摔坏了，也可以用另一个鸡蛋遍历X-1次找到该楼层。
    * 第2次（还剩X-1次尝试次数）可以从X+(X-1)层扔下来。因为即使摔碎了，也可以用另一个鸡蛋遍历X-1-1次找到该楼层。
    * 同理，第3次，可以从X+(X-1)+(X-2)层扔下来。
    * 第X次。可以从第X+(X-1)+(X-2)+...+(X-(X-2))+1层扔下来，这就是最高可能尝试到的楼层X*(X+1)/2，下面所有的楼层都可以在X次尝试中到达。
    * 当最高楼层为100时，可列出不等式：最高可能尝试到的楼层X*(X+1)/2 > 100，解出X=14次。这就是最稳定的最快寻找到该楼层的扔鸡蛋次数。也就是说第一次扔鸡蛋要从14楼开始扔。14+13+12+11+...+2+1 = 105层，也就是14次尝试一定可以在1-105层中找到那个第N层。推出了公式X*(X+1)/2后，要想编程求任意总楼层条件下，就都很方便了。

![image](https://upload-images.jianshu.io/upload_images/1197643-f14862e6af2c67c9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/198)

- 动态规划法——找最优解常用方法
    * 在我们编程解决问题的过程中，如果遇到最优问题的时候，往往可以先尝试一下动态规划的方法。而动态规划的方法，首要的我们要找到构成这个最优问题的最优子问题。所以，下面的分析，我们首先尝试动态规划的方法，如何解决这个问题，这也是典型的程序员的思路；其次，在众多的问题当中，有不少可以直接归结为数学方程式，如果我们能够写出数学方程式，那么，答案将是更加的简洁、美妙（比如上一种方法推导出来的公式）。
- 基于动态规划的方法
    * 前面提到，若要采用动态规划的方法，最重要的是要找到子问题。做如下面的分析，假设F{n}表示从第n层楼扔下鸡蛋，找到不摔碎鸡蛋楼层的最少尝试次数。第一个鸡蛋可能从第i层扔下，有两个情况：
        * 碎了，第二个鸡蛋，需要从第一层开始试验，最多要尝试i-1次。
        * 没碎，两个鸡蛋，还有n-i层。这个就是子问题了f[n-i] 。
- 所以，当第一个鸡蛋，由第i个位置落下的时候，要尝试的次数为f[i]= 1 + max(i - 1, f[n-i])用max是确保一定可以在这么多次内找到。那么对于每一个i对f(i)进行比较，非最小的f(i)，就是F{n}的值。状态转移方程如下： F{n} = min f[i] = min(1 + max(i - 1, f[n-i]) ) 其中: i的范围为(1, n), f[1] = 1 完毕。
- 推广动态规划的方法，可以推广为n层楼，m个鸡蛋。如下分析： 假设f{n,m}表示n层楼、m个鸡蛋时找到最高楼层的最少尝试次数。当第一个鸡蛋从第i层扔下，如果碎了，还剩m-1个鸡蛋，为确定下面楼层中的安全楼层，还需要f{i-1,m-1}次，找到子问题；不碎的话，上面还有n-i层，还需要f[n-i,m]次，又一个子问题。 状态转移方程如下： f{n, m} = min(1 + max(f{i - 1, m - 1}, f{n - i, m}) ) 其中： i为(1, n), f{i, 1} = 1
- 拓展一下，如果不是100楼层，是N楼层，曾怎么计算呢？

![image](https://upload-images.jianshu.io/upload_images/1197643-336110312293e97a.png?imageMogr2/auto-orient/strip|imageView2/2/w/283)
* 再次拓展，如果我们有三个鸡蛋，有k次机会，我们最大可以测试多少层楼？

![image](https://upload-images.jianshu.io/upload_images/1197643-5a0a44afdb597907.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/690)
* 如果我们有M个鸡蛋，有k次机会，我们最大可以测试多少层楼？

#### 29.数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。或者是问：给定一个大小为n的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素
##### 题解一
- 对于排序的数组，数组中出现次数超过一半的数字一定会出现在数组的中间。于是先将数组排序，然后输出中位数即可。但是由于输入的数组不一定满足要求，所以别忘了检查得到的数字是否真的在数组中出现的次数超过一半。
- 时间复杂度为O(nlogn)，空间复杂度为O(1)。

##### 题解二
- 一个直观的解法是使用哈希表。遍历一遍数组，将数组中每个元素出现的次数存入哈希表，然后遍历哈希表，找出出现次数大于一半的数字。
- 时间复杂度为O(n)，空间复杂度为O(n)。

##### 题解三
- 考虑数组的特性，若数组中有一个数字出现的次数超过了数组长度的一半，那么数组中第 n/2 大的数字一定是这个数字。
- 可以借助快排的思想来寻找特定的下标，这里我们需要寻找的下标就是 n/2，每次 Partition 都可以将 pivot放置到其对应的位置，且所有小于pivot的数字都在 pivot 左边，大于 pivot 的数字都在 pivot右边。排序后数组中的下标为数组长度一半的数字即为数组中第 n/2 大的数字（数组的中位数）。
- 为了找到这个数字，我们可以使用递归，如果 pivot 的坐标小于 n/2，那么继续在 pivot 右边进行查找；如果 pivot 的坐标大于 n/2，那么继续在 pivot 左边进行查找；如果 pivot 的坐标刚好等于n/2，那么就返回数组中对应的数字。
- 最后别忘了检查得到的数字是否真的在数组中出现的次数超过一半，毕竟上述算法得到的只是这个数组中第 n/2大的数字，并不保证这个数字出现次数超过一半。
- 时间复杂度为O(n)，空间复杂度为O(1)。

##### 题解四
- 还有另外一种巧妙的方法。遍历数组，同时维护两个变量：一个是数组中的一个数字，另一个是次数。在遍历数组时，第一个数字作为守方，设置count=1，接下来的数字进行攻击。在遇到相同元素时守方即count加1，遇到不同元素时count-1。在count为0时，新的数字成为新的守方，接受接下来的攻击。
- 若数组中有一个出现次数超过一半的数字，那么它一定是最终的胜利者。但也有可能不存在这与的数字，所以在结束之后也要像之前一样进行检查。
- 时间复杂度为O(n)，空间复杂度为O(1)。

### 30.怎么判断一条链表有环
- 有环的定义：链表的尾结点指向了链表中的某个结点

![image](https://upload-images.jianshu.io/upload_images/3738156-67be985aa4b3da78.png?imageMogr2/auto-orient/strip|imageView2/2/w/677)

- 两种解决方案
    * 方法一：使用p、q两个指针，p总是向前走，但q每次都从头开始走，对于每个结节点，看p走的步数是否和q一样。如果不一样，就存在环。如图，当p从6走到3时，总共需要6步，此时q从头head出发，只需要两步就到3，步数不等，存在环。
    * 方法二：利用快慢指针，使用p、q两个指针，p每次向前走一步，q每次向前走两步，若在某个时候，p == q，则存在环。
- 代码：
- 第一步：创建有环单链表

```
/**
 * 随机产生n个元素的值，建立带头结点的单链表L（尾插法）
 */
void CreatListTail(LinkList * L, int n){
    
    LinkList p,r;
    int i;
    
    srand(time(0));                            /* 初始化随机数种子 */
    *L = (LinkList)malloc(sizeof(Node));        /* L为整个线性表 */
    r = *L;                                   /* r为指向尾部的结点 */
    
    for (i = 0; i < n; i++) {
        
        p = (LinkList)malloc(sizeof(Node));     /* 生成新节点 */
        p->data = rand()%100 +1;               /* 随机生成100以内的数字 */
        r->next = p;                          /* 将表尾终端结点的指针指针指向新节点 */
        r = p;                                /* 将当前的新节点定义为表尾终端结点 */
    }
    
    r->next = (*L)->next->next;                /* 尾部指向第二个结点(如果无环r->next = null) */
}
```
- 用比较步数的方法【方法一】判断是否有环

```
/**
 * 比较步数的方法
 */
int HasLoop(LinkList L){
    
    LinkList cur1 = L;                         /* 定义结点cur1 */
    int pos1 = 0;                              /* cur1的步数 */
    
    while (cur1) {                             /* 结点cur1存在 */
        
        LinkList cur2 = L;                     /* 定义结点cur2 */
        int pos2 = 0;                          /* cur2的步数 */
        
        while (cur2) {                         /* 结点cur2存在 */
            
            if (cur2 == cur1) {                /* 当cur2和cur1到达相同的结点时 */
                
                if (pos1 == pos2)              /* cur2和cur1走过的步数一样,说明没有环 */
                    break;
                else{                          /* 有环并返回1*/
                    printf("环的位置在第%d个结点处.\n\n",pos2);
                    return 1;
                }

            }
            cur2 = cur2->next;                 /* 若果没有环，继续下一个结点 */
            pos2++;                            /* cur2的步数自增 */
        }
        cur1 = cur1->next;                     /* cur1继续向后一个结点 */
        pos1++;                                /* cur1的步数自增 */
    }
    return 0;
}
```
- 用快慢指针【方法二】

```
/**
 * 用快慢指针的方法
 */
int HasLoop2(LinkList L){

    LinkList p = L;
    LinkList q = L;
    
    while (p != NULL && q != NULL && q->next != NULL) {
        
        p = p->next;                          /* p每次走一步*/
        
        if (q->next != NULL) {
            q = q->next->next;                /* p每次走两步*/
        }
        
        printf("p:%d, q:%d \n", p->data,q->data);
        
        if (p == q) {
            return 1;                        /* 当p和q相等，则表示有环 */
        }
    }
    return 0;
}
```

### 31.求数组的最长子数组
### 32.回文算法，最长回文子串之 Manacher 算法
- 最长回文子串：在计算机科学中，最长回文子串或最长对称因子问题是在一个字符串中查找一个最长连续子串，这个子串必须是回文。例如“banana”最长回文子串是“anana”。最长回文子串并不能保证是唯一的
- 回文串可分为奇数回文串和偶数回文串。
- 它们的区别是：奇数回文串关于它的“中点”满足“中心对称”，偶数回文串关于它“中间的两个点”满足“中心对称”。
- 思路1：暴力匹配 Brute Force。
    * 暴力匹配，虽然听起来并不是那么友好，但是我个人认为暴力解法虽然时间复杂度很高，但是它简单粗暴，编写正确的概率其实是很高的，完全可以使用暴力匹配算法检验我们编写的算法的正确性，并且在优化正确的前提下，通过和暴力匹配的比较，也可以体现我们优化算法的性能优势。
    * 当然，“最长回文子串”在 LeetCode 上有标准的问题，我们编写好算法以后，可以提交到 LeetCode 上，运行 LeetCode 的测试用例检验我们实现的算法。
- 思路2：中心扩散法。想法很简单，就是遍历每一个索引，以这个索引为中心，看看往两边扩散，最多能扩散多长的字符串。具体做法是利用“回文串”中心对称的特点，在枚举子串的过程中进行剪枝，在具体解这个问题的过程中，我们就要对可能产生的回文串是奇数长度和偶数长度进行考量，但是完全可以设计一种方法，兼容两种情况。
- 思路3：动态规划。
    * 定义状态：s[i, j] ：表示原始字符串的一个子串，i、j分别是索引，使用闭区间表示包括区间左右端点。
    * dp[i, j]：如果子串 s[i,...,j] 是回文串，那么 dp[i, j] = true。即二维 dp：dp[i, j] 表示子串 s[i, j]（包括区间左右端点）是否构成回文串，是一个二维布尔型数组。
    * 状态转移方程：在 dp[i, j] = true 的时候， dp[i + 1, j - 1] = true，因此，如果已知 dp[i + 1, j - 1]，就可以通过比较 s[i] 和 s[j] 并且考虑 dp[i + 1, j - 1] 进而得到 dp[i, j]。
    * 如果 s[i, j] 是一个回文串，例如 “abccba”，那么 s[i+1, j-1] 也一定是一个回文串，根据这个递归的性质，我们可以写出状态转移方程。
    * dp[i, j] = dp[i+1, j-1]，当然，此时我们要保证 [i+1, j-1] 能够形成区间，因此有i+1<=j-1，整理得 i-j <= -2，或者 j-i >=2。
- 思路4：专门解决回文串的一个著名算法 Manacher 算法。
    * Manacher 算法就是专门解决“最长回文子串”的一个算法，它的时间复杂度可以达到 O(n)
    * [Manacher(1975)] 发现了一种线性时间算法，可以在列出给定字符串中从字符串头部开始的所有回文。并且，Apostolico, Breslauer & Galil (1995) 发现，同样的算法也可以在任意位置查找全部最大回文子串，并且时间复杂度是线性的。因此，他们提供了一种时间复杂度为线性的最长回文子串解法。替代性的线性时间解决 Jeuring (1994), Gusfield (1997)提供的，基于后缀树(suffix trees)。也存在已知的高效并行算法。
    * 第 1 步：预处理，添加分隔符
        * 分隔符是字符串中没有出现过的字符，这个分隔符的种类只有一个，即你不能同时添加 "#" 和 "?" 作为分隔符；
        * 在字符串的首位置、尾位置和每个字符的“中间”都添加  个这个分隔符，可以很容易知道，如果这个字符串的长度是 len，那么添加的分隔符的个数就是 len + 1，得到的新的字符串的长度就是 2len + 1，显然它一定是奇数。
        * 为什么要添加分隔符？
            * 首先是正确性：添加了分隔符以后的字符串的回文性质与原始字符串是一样的。
            * 其实是避免奇偶数讨论，对于使用“中心扩散法”判定回文串的时候，长度为奇数和偶数的判定是不同的，添加分隔符可以避免对奇偶性的讨论。
    * 第 2 步：得到 p 数组
        * 第 1 行 char 数组：这个数组就是待检测字符串加上分隔符以后的字符构成的数组。
        * 第 2 行 index 数组：这个数组是索引数组，我们后面要利用到它，填写即索引从 0 开始写就好了。
        * 回文半径：以 char[i] 作为回文中心，同时向左边、向右边进行扩散，直到不能构成回文串或者触碰到边界为止，能扩散的步数 + 1 ，即定义为 p 数组索引的值，也称之为回文半径。
        * p-1 数组很简单了，把 p 数组的数 -1 就行了。于是：数组 p -1 的最大值就是最长的回文子串，可以在得到 p 数组的过程中记录这个最大值，并且记录最长回文子串。

### 33.判断一个字符串是不是对称的字符串，比如 abba 或者 aba 这样的就是对称的。
### 34.hash 算法的原理
### 35.二叉树逐层打印
- 请按层输出其的节点值，即：按从上到下，从左到右的顺序。
- 因为我们不但需要按层来遍历，还需要按层来输出结果，所以我在代码中使用了两个队列，分别名为level和nextLevel，用于保存不同层的节点。
- 最终，整个算法逻辑是：
    * 判断输入参数是否是为空。
    * 将根节点加入到队列level中。
    * 如果level不为空，则：
        * 将level加入到结果ans中。
        * 遍历level的左子节点和右子节点，将其加入到nextLevel中。
        * 将nextLevel赋值给level，重复第 3 步的判断。
    * 将ans中的节点换成节点的值，返回结果。

### 36.找出一个页面中漏出部分面积最大的试图，重合的部分按照最上层的面积算漏出
### 37.一个坦克从一个空间的起点到终点，中间在某些位置上有阻隔的情况下，判断从起点到终点是否有可行路径。
### 38.二叉树翻转，将二叉树的两个孩子换位置，即左变右，右变左。
- 方法一：循环，栈存储（DFS，非递归)    
    * 本质思想是，左右节点进行交换，循环翻转每个节点的左右子节点，将未翻转的子节点存入栈中，循环直到栈里所有节点都循环交换完为止。

```
       public TreeNode invertTree(TreeNode root) {          
            if (root == null) {
                return null;
            }
            Stack<TreeNode> stack = new Stack<>();
            stack.push(root);           
            while(!stack.isEmpty()) {
                final TreeNode node = stack.pop();
                final TreeNode left = node.left;
                node.left = node.right;
                node.right = left;           
                if(node.left != null) {
                    stack.push(node.left);
                }
                if(node.right != null) {
                    stack.push(node.right);
                }
            }
            return root;
        }
```

- 方法二：循环，队列存储（BFS，非递归）
    * 本质思想是，左右节点进行交换，循环翻转每个节点的左右子节点，将未翻转的子节点存入队列中，循环直到栈里所有节点都循环交换完为止。

```
    public TreeNode invertTree(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode left = node.left;
            node.left = node.right;
            node.right = left;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return root;
    }
```

- 方法一、方法二伪代码：

```
1、判断根结点是否为空，为空则返回null；
2、新建栈（队列），用于节点存储，初始存入根节点到栈（队列）里；
3、while循环，栈（队列）为空时结束循环；
  i.出栈（队列）一个节点，将该节点的左右子节点交互；
  ii.判断左右子节点是否为null，非null则继续将左右节点入栈（队列）；
4、循环交换结束，返回根节点;

```
- 方法三：递归
    * 本质思想也是左右节点进行交换，交换前递归调用对根结点的左右节点分别进行处理，保证交换前左右节点已经翻转。

```
1、判断根结点是否为空，为空则返回null；
2、交换跟节点的左右节点；
3、递归交互左右子树；
```

```
    public TreeNode invertTree(TreeNode node) {
        if (node == null) {
            return null;
        }
        TreeNode temp = node.left;
        node.left = node.right;
        node.right = temp;
        invertTree(node.left);
        invertTree(node.right);
        return node;
    }
```

## UIKit
### 1.UIView 和 CALayer 是什么关系？
- 首先从继承关系来分析两者：UIView : UIResponder，CALayer : NSObject。
#### UIView
- UIView 响应事件，UIView 继承 UIResponder，而 UIResponder 是响应者对象，所以UIView 响应事件
- 实现了如下 API，所以继承自 UIResponder 的都具有响应事件的能力：

```
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet<UITouch *> *)touches NS_AVAILABLE_IOS(9_1);
```
- 并且 UIView 提供了以下两个方法，来进行 iOS 中的事件的响应及传递（响应者链）：

```
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;  
```
#### CALayer 绘制 UI
- CALayer 绘制 UI：CALayer 没有继承自 UIResponder，所以CALayer不具备响应处理事件的能力。CALayer 是 QuartzCore中的类，是一个比较底层的用来绘制内容的类。
#### UIView 对 CALayer 封装属性
- UIView 中持有一个 layer 对象，同时这个 layer 对象的 delegate 是 UIView ，所以，UIView 和 CALayer 是协同工作。
- 平时我们对 UIView 设置 frame、center、bounds 等位置信息，其实都是UIView对CALayer进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性，UIView就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。
- Frame 属性主要是依赖：bounds、anchorPoint、transform、和position。
- 我们这主要说一下 anchorPoint 和 position 如何影响 Frame 的：anchorPoint锚点是相对于当前Layer的一个点，position 是 Layer 中 anchorPoint 锚点在 superLayer 中的点，即 position 是由 anchorPoint 来确认的。
- 这里有几个通用的公式：

```
position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  
position.y = frame.origin.y + anchorPoint.y * bounds.size.height；
  
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；    
```
- 故有：
    * position 是 layer 中的 anchorPoint 在 superLayer 中的位置坐标。
    * 单独修改 position 与 anchorPoint 中任何一个属性都不影响另一个属性。
#### UIView 是 CALayer 的代理
- UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 的数据，例如动画和绘制。

```
//绘制相关
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;

//动画相关
- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;
```
#### 动画相关
- Layer 中很多属性都是 animatable 的，这就意味着修改这些属性会产生隐式动画。当是如果修改 UIView主Layer的话，此时隐式动画会失效，因为：UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们。
- 当一个 animatable 属性变化时，Layer 会询问代理方法该如何处理这个动画，即需要在代理方法中返回合适的 CAAction 对象。
- 属性改变时 layer会向view请求一个动作，而一般情况下 view 将返回一个NSNull，只有当属性改变发生在动画 block 中时，view 才会返回实际的动作。
#### 绘制相关
- CALayer 在屏幕上绘制东西是因为 CALayer 内部有一个 contents (CGImage)的属性，contents 也被称为寄宿图。绘制相关的 API 如下：

```
- (void)displayLayer:(CALayer *)layer;
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;

- (void)drawRect:(CGRect)rect
```
#### drawRect 方法实现
- 平时为自定义View添加空间或者在上下文画图都会使用到这个函数，但是如果当我们实现了这个方法的时候，这个时候会生成一张寄宿图，这个寄宿图的尺寸是 layer 的宽 * 高 * contentsScale，其实算出来的是有多少像素。然后每个像素占用4个字节，总共消耗的内存大小为：宽 * 高 * contentsScale * 4 字节。
- 这里跟我们图片显示是一个道理：一张图片需要解压成位图才能显示到屏幕上，图片的颜色空间一般是RGBA，每个像素点需要包含RGBA四个信息，所以一张图片解压成位图需要占用内存大小为：像素宽 * 像素高 * 4 个字节。（PS：将图片解压成位图是比较耗时的，这就是为什么通常会在子线程解压图片，然后再到主线程中显示，避免卡住主线程）
- 所以在使用 drawRect方法来实现功能之前，需要看看是否有替代方案，避免产生寄宿图增加程序的内存，使用 CAShapeLayer 来绘制是一个不错的方案。
#### UILabel 绘制文字占用内存的情况
- 这里讲到绘制占用内存的情况，我们简单来了解下 Label 绘制文字占用的内存情况，实例代码如下：

```
//绘制一个全屏的 Label
        UILabel *label1 = [[UILabel alloc] initWithFrame:self.view.bounds];
    label1.text = @"11111";
    [self.view addSubview:label1];
    
    UILabel *label2 = [[UILabel alloc] initWithFrame:self.view.bounds];
    label2.text = @"😀11111";
    [self.view addSubview:label2];
```
- 绘制一个全屏的 Label，按理由需要占用内存：宽 * 高 * 4，iPhone 6SP 像素为：1242 * 2208，全屏差不多是占用 10 M 左右，但是 label1 大概会占用 3 M左右， label2 会占用 10 M左右；其实这里是因为如果使用黑白位图，苹果会优化颜色空间，这里每个像素就只会占用 1 个字节，比 4 字节节省 75% 的空间。
#### 总结
- 如果确定是不需要交互的，可以将 UIView 替换成 CALayer，来省去UIView封装带来的损耗，AsyncDisplayKit 库利用 ASDisplayNode 来替代UIView来节省资源。

### 2.Bounds 和 Frame 的区别?
#### frame
- 是每个view必备的属性，代表的是当前视图的位置和大小，没有设置frame，当前视图是看不到的。
- 在iOS坐标系中以左上角为坐标原点，往右为X正方向，往下是Y正方向
- frame中的位置是以父视图的坐标系为标准来确定当前视图的位置
- 同样的默认情况下，本视图的左上角就是子视图的坐标原点
- 更改frame中位置，则当前视图的位置会发生改变
- 更改frame的大小，则当前视图以当前视图的左上角为基准进行大小的修改
#### bounds
- 是每个View都有的属性，这个属性我们一般不进行设置，他同样代表位置和大小；
每个视图都有自己的坐标系，且这个坐标系默认以自身的左上角为坐标原点，所有子视图以这个坐标系的原点为基准点。
- bounds的位置代表的是子视图看待当前视图左上角的位置;bounds的大小代表当前视图的大小；
- 更改bounds中的位置对于当前视图没有影响，相当于更改了当前视图的坐标系，对于子视图来说当前视图的左上角已经不再是(0,0), 而是改变后的坐标，坐标系改了，那么所有子视图的位置也会跟着改变
- 更改bounds的大小，bounds的大小代表当前视图的长和宽，修改长宽后，中心点继续保持不变, 长宽进行改变；通过bounds修改长宽看起来就像是以中心点为基准点对长宽两边同时进行缩放；
#### frame和bounds

![image](https://upload-images.jianshu.io/upload_images/1196725-188e8cb0157b3cee.png?imageMogr2/auto-orient/strip|imageView2/2/w/779)

- 因为是View A是顶层视图，所以其实相当于覆盖在框架上，因此位置从父视图的（0，0）开始，大小为500*400
- 默认情况下，本视图的坐标系是没有发生改变的即当前视图(view A)的左上角就是所有子视图的原点，大小就是当前视图的大小.
- 因为View B是ViewA的子视图，所以ViewB的frame位置需要以View A的左上角为参照，因此位置为(200, 100), 大小为200*150
- bounds在默认情况下本视图的坐标系是没有发生改变的即当前视图(viewB)的左上角就是当前视图所有子视图的原点.

![image](https://upload-images.jianshu.io/upload_images/1196725-2844fc5a83246fca.png?imageMogr2/auto-orient/strip|imageView2/2/w/893)

- 在上一个例子的基础上，我们更改了view A的bounds后，view B看待View A的左上角就已经发生改变了；这个时候我们看待View A的左上角就不是坐标原点了，而是我们通过bounds设置后的坐标，如图也就是(0, 100);
在View B的frame没有保存不变的基础上，我们View B的位置向上移动了100

![image](https://upload-images.jianshu.io/upload_images/1196725-ed92b2bc1640b1bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/935)

#### 总结
- frame不管对于位置还是大小，改变的都是自己本身
- frame的位置是以父视图的坐标系为参照，从而确定当前视图在父视图中的位置
- frame的大小改变时，当前视图的左上角位置不会发生改变，只是大小发生改变
- bounds改变位置时，改变的是子视图的位置，自身没有影响；其实就是改变了本身的坐标系原点，默认本身坐标系的原点是左上角
- bounds的大小改变时，当前视图的中心点不会发生改变，当前视图的大小发生改变，看起来效果就想缩放一样

### 3.TableViewCell如何根据UILabel内容长度自动调整高度?
- 将需要改变高度的UILabel的Line设置为0。Line代表UILabel能显示的最多行数
- 重写estimatedHeightForRowAtIndexPath方法
    * 因为系统是先获取cell的高度，再获取cell的view。也就是先调用heightForRowAtIndexPath，再调用cellForRowAtIndexPath。在cellForRowAtIndexPath被调用之前，你的label是没有被设置文本内容的，因此它获取到的高度，并不是你想要的。那么我们必须想办法让系统在获取了cell之后，再获取cell的高度。方法就是，重写estimatedHeightForRowAtIndexPath
    * 它会返回一个估计高度，有了这个方法后，tableview会先调用它获取估计高度，然后获取cell，最后获取真实高度。那么最后的真实高度，就是我们希望的高度。estimatedHeightForRowAtIndexPath的返回值可以随意，返回多少都可以，让它延迟获取真实的高度。
- 重写heightForRowAtIndexPath，真实高度返回值为UITableViewAutomaticDimension
- 或者在viewDidLoad中直接用

```
self.tableView.estimatedRowHeight = 10
self.tableView.rowHeight = UITableViewAutomaticDimension
```

### 4.LoadView方法了解吗？
- loadView作用,用来创建控制器的View.
- 当控制器的View,第一次使用的时候调用.
- loadView底层原理:
    * 先判断当前控制器是不是从storyBoard当中加载的,如果是从storyBoard加载的控制器.那么它就会把从storyBoard当中加载的控制器的View,设置成当前控制器的view.
    * 当前控制器是不是从xib当中加载的,如果是从xib当中加载的话,把xib当中指定的View,设置为当前控制器的View.
    * 如果也不是从xib加载的,它会创建空白的view.
- 一但重写了loadView方法,就说明要自己定义View.
- 一般使用的场景:当控制器的View一显示时,就是一张图片,或者UIWebView.
节省内存

### 5.UIButton 的父类是什么？UILabel 的父类又是什么？
- UIControl 
- UIView

### 补充：UIButton防止多次点击
#### 设置enabled或userInteractionEnabled属性
* 通过UIButton的enabled属性和userInteractionEnabled属性控制按钮是否可点击。此方案在逻辑上比较清晰、易懂，但具体代码书写分散，常常涉及多个地方。

```
- (void)tapBtn:(UIButton *)btn {
    NSLog(@"按钮点击...");
    btn.enabled = NO;
    
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        btn.enabled = YES;
    });
}
```
#### 借助cancelPreviousPerformRequestsWithTarget:selector:object实现
- 通过 NSObject 的两个方法
- 实现步骤如下:
    * 创建一个UIButton的分类，使用runtime增加public属性cs_eventInterval和private属性cs_eventInvalid。
    * 在+load方法中使用runtime将UIButton的-sendAction:to:forEvent:方法与自定义的cs_sendAction:to:forEvent:方法进行交换
    * 使用cs_eventInterval作为控制cs_eventInvalid的计时因子，用cs_eventInvalid控制UIButton的event事件是否有效。

```
// 此方法会在连续点击按钮时取消之前的点击事件，从而只执行最后一次点击事件
+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;
// 多长时间后做某件事情
- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;
```

```
/** 方法一 */
- (void)tapBtn:(UIButton *)btn {
    NSLog(@"按钮点击了...");
    // 此方法会在连续点击按钮时取消之前的点击事件，从而只执行最后一次点击事件
    [NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(buttonClickedAction:) object:btn];
    // 多长时间后做某件事情
    [self performSelector:@selector(buttonClickedAction:) withObject:btn afterDelay:2.0];
}

- (void)buttonClickedAction:(UIButton *)btn {
    NSLog(@"真正开始执行业务 - 比如网络请求...");
}
```
- 通过runtime交换方法实现

```
@interface UIButton (Extension)

/** 时间间隔 */
@property(nonatomic, assign)NSTimeInterval cs_eventInterval;

@end
```

```
#import "UIButton+Extension.h"
#import <objc/runtime.h>

static char *const kEventIntervalKey = "kEventIntervalKey"; // 时间间隔
static char *const kEventInvalidKey = "kEventInvalidKey";   // 是否失效

@interface UIButton()

/** 是否失效 - 即不可以点击 */
@property(nonatomic, assign)BOOL cs_eventInvalid;

@end

@implementation UIButton (Extension)

+ (void)load {
    // 交换方法
    Method clickMethod = class_getInstanceMethod(self, @selector(sendAction:to:forEvent:));
    Method cs_clickMethod = class_getInstanceMethod(self, @selector(cs_sendAction:to:forEvent:));
    method_exchangeImplementations(clickMethod, cs_clickMethod);
}

#pragma mark - click

- (void)cs_sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event {
    if (!self.cs_eventInvalid) {
        self.cs_eventInvalid = YES;
        [self cs_sendAction:action to:target forEvent:event];
        [self performSelector:@selector(setCs_eventInvalid:) withObject:@(NO) afterDelay:self.cs_eventInterval];
    }
}

#pragma mark - set | get

- (NSTimeInterval)cs_eventInterval {
    return [objc_getAssociatedObject(self, kEventIntervalKey) doubleValue];
}

- (void)setCs_eventInterval:(NSTimeInterval)cs_eventInterval {
    objc_setAssociatedObject(self, kEventIntervalKey, @(cs_eventInterval), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (BOOL)cs_eventInvalid {
    return [objc_getAssociatedObject(self, kEventInvalidKey) boolValue];
}

- (void)setCs_eventInvalid:(BOOL)cs_eventInvalid {
    objc_setAssociatedObject(self, kEventInvalidKey, @(cs_eventInvalid), OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
```


### 6.IBOutlet连出来的视图属性为什么可以被设置成weak?
- 官方文档里面说：一般的IBOutlet直接关联到viewcontroller。但是跟其关联的控件并不是添加在controller上，而是添加到controller的view上，比如[self.view addSubView：xxx]; 这个时候self.view已经对xxx 强引用过了，self.view才是持有xxx的对象。这样子才符合引用计数的规则。所以直接IBOutlet顶级view的时候肯定是strong的。
- 其实质是：使用storyboard创建的viewController，那么会有一个叫 _topLevelObjectsToKeepAliveFromStoryboard的私有数组强引用所有top level的对象，同时top level对象强引用所有子对象，那么vc没必要再强引用top level对象的子对象。
- 以UIButton为例：UIViewController->UIView->UIButton
    * 如果我们在vc中这样写

```
@IBOutlet weak var bu: UIButton!
```
他们之间的引用关系用图表示如下：

![image](http://jbcdn2.b0.upaiyun.com/2016/03/5f5fef26ea7d3eb2dd997e21d1254758.png)
viewController强引用view对象，同时view强引用button对象，那么你声明属性的时候使用weak就可以了。（觉得Strong也可以，但是完全没必要）

释放过程：其实不管声明的属性是强引用还是弱引用，在控制器消失的时候，这个属性消失，View消失，subViews消失，控件也就消失了。

### 7.IB中User Defined Runtime Attributes如何使用？
- 用户定义的运行时属性
- 它能够通过KVC的方式配置一些你在interface builder 中不能配置的属性。当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller
- 当你使用IB（Storyboard或者Xib）编辑视图的时候，有时可能会遇到诸如 圆角、边框、边框颜色、控件背景颜色等等难以通过IB直接设置的属性。这时你不得不借助代码实现。其实当出现这类情况时,我们其实可以借助Runtime Attribute在IB中实现。
- 在IB中，点击任意一个控件切换到identity inspector

![image](https://upload-images.jianshu.io/upload_images/2791656-10f9e2c59df07f7b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/300)
- 属性类型
    * 下面是一些可用的Attribute Types与其相对应的数据类型:
        * Boolean – BOOL
        * Number – NSNumber * 
        * String – NSString *
        * Point – CGPoint
        * Size – CGSize
        * Rect – CGRect
        * Range – NSRange
        * Color – UIColor *
        * Image - UIImage imageNamed
    
==注意：在user defined runtime attributes（用户定义的运行时属性）是没有报错机制的，我们必须保障每一个属性都要写正确（尤其是大小写）和每个Type的数据类型选择正确==

### 8.实现一个控件，可以浮在任意界面的上层并支持拖动？
### 9.说一下控制器View的生命周期，一旦收到内存警告会如何处理？
![image](https://upload-images.jianshu.io/upload_images/1434508-370daf660ff330e4.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
- Phone下每个app可用的内存是被限制的，如果一个app使用的内存超过20M，则系统会向该app发送Memory Warning消息。
- 当应用程序占用了大约20MB内存时，iphone开始发出内存警告。当应用程序所占内存大约为30MB时，iphone OS会关闭应用程序。收到此消息后，app必须正确处理，否则可能出错或者出现内存泄露。app收到Memory Warning后会调用：
    * UIApplication::didReceiveMemoryWarning
    * UIApplicationDelegate::applicationDidReceiveMemoryWarning
- 然后调用当前所有的viewController进行处理。因此处理的主要工作是在viewController。
- 我们知道，创建viewcontroller时，执行顺序是loadview -> viewDidLoad。
- 当收到内存警告时，如果viewcontroller未显示（在后台），会执行didReceiveMemoryWarning -> viewDidUnLoad；如果viewcontroller当前正在显示（在前台），则只执行didReceiveMemoryWarning。
当重新显示该viewController时，执行过viewDidUnLoad的viewcontroller（即原来在后台）会重新调用loadview -> viewDidLoad。
- 重载didReceiveMemoryWarning时，一定调用这个函数的super实现来允许父类（一般是UIVIewController）释放self.view。self.view释放之后，会调用下面的viewDidUnload函数.也就是说，尽管self.view是被处理了，但是outlets的变量因为被retain过，所以不会被释放，为了解决这个问题，就需要在viewDidUnload中释放这些retain过的outlets变量。通常controller会保存nib文件建立的views的引用，但是也可能会保存着loadView函数创建的对象的引用。

#### 生命周期
- 单个viewController
    * loadView： 加载view
    * viewDidLoad： view加载完毕
    * viewWillAppear： 控制器的view将要显示
    * viewWillLayoutSubviews：控制器的view将要布局子控件
    * viewDidLayoutSubviews：控制器的view布局子控件完成
    * viewDidAppear: 控制器的view完全显示
    * viewWillDisappear： 控制器的view即将消失的时候
    * viewDidDisappear： 控制器的view完全消失的时候
- 多个viewControllers跳转
    * 当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法
    * loadView：ViewController2
    * viewDidLoad：ViewController2
    * viewWillDisappear：ViewController1 将要消失
    * viewWillAppear：ViewController2 将要出现
    * viewWillLayoutSubviews ViewController2
    * viewDidLayoutSubviews ViewController2
    * viewWillLayoutSubviews:ViewController1
    * viewDidLayoutSubviews:ViewController1
    * viewDidDisappear:ViewController1 完全消失
    * viewDidAppear:ViewController2 完全出现
- 控制器的view是延迟加载的：创建控制器并不一定会创建控制器的view，等用到时再加载
- 补充：
    * 如果a控制器push到b控制器,那么a和b的View都不会被销毁,因为它的控制器还存在，有一个强引用引用着它(除非内存警告会销毁a的View)如果b控制器pop到a控制器,那么b的View会被销毁a和b都在导航控制器的栈里被管理,就是个数组
    * 此时如果你打印会发现方法的调用顺序是:
        * 控制器b的View的viewDidLoad
        * 控制器b的View的viewWillAppear
        * 控制器a的View的viewDidDisappear
#### 内存警告的处理
- 两个内存警告
    * 当application接收到内存警告的时候，会先通知它的代理，代理在接收到内存警告的时候会调用applicationDidReceiveMemoryWarning方法
    * 之后代理会通知它的window,window会通知它的根控制器，根控制器会通知它的子控制器,内存警告是由上往下一层一层往下传的,最后传给控制器View,控制器View会调用它的didReceiveMemoryWarning方法
- 内存警告的处理

![image](https://upload-images.jianshu.io/upload_images/6950351-dd67f46bce6d4073.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

### 10.说一下 UIView 的生命周期？
- 单个viewController
    * viewDidLoad
    * viewWillAppear
    * viewWillLayoutSubviews
    * viewDidLayoutSubviews
    * viewDidAppear
    * viewWillDisappear
    * viewDidDisappear
- 多个viewControllers跳转
    * 当我们点击push的时候首先会加载下一个界面然后才会调用界面的消失方法
    * loadView：ViewController2
    * viewDidLoad：ViewController2
    * viewWillDisappear：ViewController1 将要消失
    * viewWillAppear：ViewController2 将要出现
    * viewWillLayoutSubviews ViewController2
    * viewDidLayoutSubviews ViewController2
    * viewWillLayoutSubviews:ViewController1
    * viewDidLayoutSubviews:ViewController1
    * viewDidDisappear:ViewController1 完全消失
    * viewDidAppear:ViewController2 完全出现


### 11.说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？
- 1,-(void)applicationWillResignActive:(UIApplication *)application.
    * 说明:当应用程序将要入非活动状态执行,在此期间,应用程序不接收消息或事件,比如来电
- 2.-(void)applicationDidBecomeActive:(UIApplication *)application
    * 说明:当应用程序入活动状态执行,这个刚好跟上面那个方法相反
- 3,-(void)applicationDidEnterBackground:(UIApplication *)application
    * 说明:当程序被推送到后台的时候调用。所以要设置后台继续运行,则在这个函数里面设置即,可
- 4,-(void)applicationWillEnterForeground:(UIApplication *)application
    * 说明:当程序从后台将要重新回到前台时候调用,这个刚好跟上面的那个方法相反.
- 5,-(void)applicationWillTerminate:(UIApplication *)application.
    * 说明:当程序将要退出是被调用,通常是用来保存数据和一些退出前的清理工作。这个需要要,设置UIApplicationExitsOnSuspend的键值。
- 6,-(void)applicationDidReceiveMemoryWarning:(UIApplication *)application
    * 说明: iPhone设备只有有限的内存,如果为应用程序分配了太多内存操作系统会终止应用程!序的运行,在终止前会执行这个方法,通常可以在这里进行内存清理工作防止程序被终止,
- 7,-(void)applicationSignificantTimeChange:(UIApplication*)application
    * 说明：当系统时间发生改变时执行
- 8,-(void)applicationDidFinishLaunching:(UIApplication*)application
    * 说明:当程序载入后执行
- 9.- (void)application:(UApplication)application willChangeStatusBarFrame:(CGRectinewStatusBarFrame
    * 说明:当StatusBar框将要变化时执行
- 10 - (void)application:(UIApplication*)application willChangeStatusBarOrientation:(UlinterfaceOrientation)newStatusBarOrientation
duration(NSTimelinterval)duration
    * 说明:当StatusBar框方向将要变化时执行,
- 11,-(BOOL)application:(UIApplication*)application handleOpenURL:(NSURL*)url
    * 说明:当通过url执行
- 12.- (void)application:(UIApplication*)application didChangeStatusBarOrientation(unterfaceOrientation)oldStatusBarOrientation
    * 说明:当StatusBar框方向变化完成后执行
- 13.-(void)application:(UIApplication*)application didChangeSetStatusBarFrame:(CGRect)oldStatusBarFrame
    * 说明:当StatusBar框变化完成后执行

### 12.如何暂停一个 UIView 中正在播放的动画？暂停后如何恢复？
### 13.如何以通用的方法找到当前显示的ViewController?
- 场景：在处理 URL Router 跳转的时候，经常需要得到“当前最上层的视图控制器”来进行视图跳转。
- 方法一：
    * Podfile添加pod 'CJBaseHelper/UIViewControllerCJHelper'，并pod update或pod install
    * 库引入成功后，直接使用如下方法即可。即：

```
UIViewController *vc = [UIViewControllerCJHelper findCurrentShowingViewController];
或
UIViewController *vc = [UIViewControllerCJHelper findCurrentShowingViewControllerFrom:self];
```
### 14.如何在多次presentViewController后直接返回到指定层
- 场景：如果多个控制器都通过 present 的方式跳转呢？比如从A跳转到B，从B跳转到C，从C跳转到D，如何由D直接返回到A呢？
- 可以通过 presentingViewController 一直找到A控制器，然后调用A控制器的 dismissViewControllerAnimated 方法。方法如下：

```
UIViewController *controller = self;
while(controller.presentingViewController != nil){
    controller = controller.presentingViewController;
}
[controller dismissViewControllerAnimated:YES completion:nil];
```
- presentedViewController 与 presentingViewController
    * 假设从A控制器通过present的方式跳转到了B控制器，那么 A.presentedViewController 就是B控制器；B.presentingViewController 就是A控制器。

### 15.如何通过视图(view)获取该视图所在的控制器(viewController)
```
+ (nullable UIViewController *)findBelongViewControllerForView:(UIView *)view {
    UIResponder *responder = view;
    while ((responder = [responder nextResponder]))
        if ([responder isKindOfClass: [UIViewController class]]) {
            return (UIViewController *)responder;
        }
    return nil;
}
```

### 16.setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？
- setNeedsDisplay会调用drawRect方法重画页面
- setNeedsLayout会调用layoutSubviews，页面才会发生变化。
- 调用layoutIfNeed不会触发VC中viewDidLayoutSubviews 和 viewWillLayoutSubviews 里面重写 views的布局

### 17.什么情况下会调用layoutSubviews ？
- 调用setNeedsLayout  layoutIfNeed，直接调用setLayoutSubviews
- addsubview时触发layoutSubviews
- 改变一个view的frame会触发layoutSubviews
- 改变view的size会触发父view的layoutSubviews
- 滚动会触发layoutSubviews
- 旋转Screen会触发父UIView上的layoutSubviews事件

### 18.什么情况会调用draw rect方法
- controller的loadView、viewdidLoad方法调用之后，view即将出现在屏幕之前系统调用drawRect。
- sizeToFit方法调用之后。
- 设置contetMode为UIViewCOntentModelRedraw，之后每次更改frame的时候调用redraw方法。
- 调用setNeedsDisplay方法。

### 19.多个类型的cell如何优雅加载？
#### 题解一
- 一种就是常见的if else，但是如果修改的话，就会代码很多，一旦修改，就会修改太多，太繁琐了；

#### 题解二
- modle，根据model来对应cell，cell面向model开发，一般都是一个类型的数据（model）对应一种类型的cell，所以类型是固定的，所以我们用一个枚举来定义所有类型的cell，cellType或者model就知道如何去处理相应的cell了；但是会有重复的操作和数据处理。

#### 题解三
- Model：对 Cell 类型进行更高层次的抽象，将model抽出相同的数据，定义BaseModel，通过继承的方式，分为数据类型 DataModel 和非数据类型 SpecialModel 两种，进行定义，通过多层继承可进一步避免重复定义变量。将非数据类型也定义为类型的好处是，将这部分 UI 控制逻辑下沉到 Model 创建之处：网络/持久化数据 Entity -> UIModel，在这个过程中，创建额外的非数据型UIModel，只要数据创建好，后期就不用再理相关逻辑了。
- Cell：定义BaseCell, Cell子类型通过运行时动态创建，UI显示通过CardBaseView作为容器，加载到Cell 的ContentView上。
- 通过一系列解耦，将变化分散到两端：Model 和 View；
- View：因为是View放置在Cell的ContentView上，因此，View的Delegate是Cell，Cell通过消息转发实现回调，避免Cell实现中手写回调中转。

### 20.UICollectionView自定义layout如何实现？
> 在创建自定义的layout之前，你需要知道UICollectionViewFlowLayout提供的很多特性已经 经过优化以满足多种常用的layout。除非是如下情况，否则不建议自定义

- 你所想实现的外观并不是网格或者 line-based breaking 布局（items排成一行直到行满，再继续往下一行上去排，直到所有items都排列完成），或者必须要在多个方向上都可以滚动
- 需要频繁地改变所有 Cell的位置，以致于创建自定义layout比修改现有flow layout工作量更省

==记住：自定义最难的部分是确定布局中各item位置所需要的计算==

### 继承UICollectionViewLayout
- 继承UICollectionViewLayout之后只需要重载几个提供布局核心特性的方法，其他方法只需按情况重载即可，核心特性如下：
    * 指定可滚动内容区域的size
    * 为布局中的每个Cell及view提供属性对象
- layout对象需要用到datasource以创建collection view的layout对象，其通过layout自身的collectionView属性访问此datasource。需要注意的是，知道 layout过程中哪些信息可以从collection view中访问到，哪些不可以 是非常重要的。因为layout过程中，collection view 是无法获知各View的布局以及位置的。所以尽量避免通过 collection view获取除layout之外的信息。
> 深入理解布局过程

collection view完全通过你自定义的layout对象管理整个布局过程，如 collection view 首次布局或者resize的时候，会向布局对象获取相关信息。你也可以手动调用invalidateLayout方法以更新布局对象，此方法会强制生成新layout。（需要注意invalidateLayout与reloadData的区别，在移动，添加或者删除item的时候，需要摒弃原有布局，重新生成新的布局，使用invalidateLayout，而如果只是datasource中的数据有更新，这时需要使用reloadData）

layout过程中，如下方法提供了layout的基本信息，其他方法也会被调用，但如下这些方法总是按如下顺序调用的：

1 prepareLayout方法调用来为即将进行的layout作前期的计算

2 collectionViewContentSize方法基于初始计算，返回整体内容区域的size

3 layoutAttributesForElementsInRect:方法返回指定区域中cells和views的属性

![image](https://upload-images.jianshu.io/upload_images/268750-cd700e8158f38214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

prepareLayout方法是为确定布局中各cell和view位置做计算，需要在此方法中算出足够的信息以供后续方法计算内容区域的整体size，collection view使用content size 以正确地配置scroll view。比如 content size 长宽均超过屏幕的话，水平与竖直方向的滚动都会被enable。基于当前滚动位置，collection view会调用 layoutAttributesForElementsInRect:方法以请求特定rect(有可能是也可能不是可见rect）中cell和view的属性。到此，core layout process已经结束了。

layout结束之后，cells和views的属性在你或者collection view invalidate布局之前都不会变，collection view可以在滚动的过程中自动invalidate 布局：用户滚动内容过程中，collection view调用layout的shouldInvalidateLayoutForBoundsChange:方法，如果返回值为YES则invalidate 布局。（但需要知道的是，invalidateLayout并不会马上触发layout update process,而是在下一个view更新周期中，collection view发现layout已经dirty才会去更新)

> 创建布局属性

自定义layout需要返回UICollectionViewLayoutAttributes类的对象，这些对象可以在很多不同方法中创建，但创建时间可以根据具体情况具体决定。如果collectionview未有数千的item,则prepare layout时创建会比在用户滚动过程中用到时再计算更可取，因为创建的这些属性可以缓存起来。如果计算所有属性并缓存起来所带来的性能消耗比请求时获取的消耗更大，则可请求时再创建相关属性对象。

创建UICollectionViewLayoutAttributes类对象新实例时，可以使用这样几个方法：layoutAttributesForCellWithIndexPath:，layoutAttributesForSupplementaryViewOfKind:withIndexPath:，layoutAttributesForDecorationViewOfKind:withIndexPath:，基于展示的view类型的不同，必须使用正确的类方法，因为collection view使用这些信息向datasource对象请求适当类型的view。使用错误的方法会引起collection view在错误的地方创建错误的view，你所希望呈现的layout就不会出现。

创建每个属性对象之后，将相应View的相关属性都设置上。最少要在layout中设置view的size和position。如果在你的布局中有view重叠了，需要正确配置zIndex属性以维持重叠views的一致的有序状态。其他属性可以让你控制cell或者view的可见性或者外观表现。如果标准属性类无法满足你的需要，可以继承并对其进行扩充以存储每个View的其他信息。继承layout属性时，需要实现属性的isEqual:方法因为collectionview需要使用这个方法。

> 给定矩形中的items的布局属性

layout processs的最后，collection view会调用你的layout对象的layoutAttributesForElementsInRect：方法。对一个大的可滚动的内容区域，collectionview可能只会请求当前可见的那部分区域中的所有items的属性。当然，这个方法需要支持获取任意rect中items的信息，因为有可能在插入及删除时需要做动画效果。

![image](https://upload-images.jianshu.io/upload_images/268750-30364131ff8a1720.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

layoutAttributesForElementsInRect：方法的实现需要遵循如下步骤：

1 遍历prepareLayout方法产生的数据以访问缓存的属性或者创建新的属性

2 检查每个item的frame以确定是否与layoutAttributesForElementsInRect:方法中指定rectangle有重叠部分

3 对每个重叠的item，添加一个对应的UICollectionViewLayoutAttributes对象到一个数组中

4 返回布局属性的数组给collection view

不仅要记住缓存layout信息能够带来性能提升，也要记住不断重复为cells创建新layout属性的计算代价是十分昂贵的，足以影响到app的性能。当collection view管理的items量很大时，采用在请求时创建layout属性的方式是十分合理的。

> 按需提供布局属性对象

collection view会在正常的layout 过程之外周期性地让你提供单个items的layout对象。比如为某item配置插入和删除动画时。自定义的layout通过如下方法提供这些信息：

layoutAttributesForItemAtIndexPath:

layoutAttributesForSupplementaryViewOfKind:atIndexPath:

layoutAttributesForDecorationViewOfKind:atIndexPath:

返回属性时，不能更新这些layout属性，如果需要改变layout信息，调用invalidateLayout，在接下来的layout周期中更新这些信息。上述方法中layoutAttributesForItemAtIndexPath：是所有自定义 layout都必须重载的方法，如果有supplementary view和decoration view可以分别重载下面两个方法。

> 可以通过self.collectionView.collectionViewLayout = [[MyCustomLayout alloc] init];方式也可以在storyboard文件中设置collection view 的class属性

### 让你的layout更优异

除了上述这些必须实现的方法，还有一些特性能够改善自定义layout的用户体验，实现这些属性是可选但推荐实现的。

> 通过 附加view 提供内容品质

supplementary views与Cells分离且有自己的layout属性，由Datasource提供，且其目的是为app主要内容增强信息。与cells一样，supplementary view也会经历重用的过程以最小化collection view使用的资源消耗。所以所有 supplementary view都需要继承UICollectionReusableView。

添加supplementary view到layout中的过程如下：

1 注册supplementary view到layout对象中，registerClass:forSupplementaryViewOfKind:withReuseIdentifier: or registerNib:forSupplementaryViewOfKind:withReuseIdentifier:

2 在datasource中实现collectionView:viewForSupplementaryElementOfKind:atIndexPath:,由于这些view是可重用的，调用dequeueReusableSupplementaryViewOfKind:withReuseIdentifier:forIndexPath:来获取可用的view

3 但为Cells创建一样为supplementary Views创建layout 属性对象

4 layoutAttributesForElementsInRect:方法中返回的属性数组中包含supplementary view的layout属性对象

5 实现layoutAttributesForSupplementaryViewOfKind:atIndexPath:方法为特定supplementary View返回属性对象

处理supplementaryview布局属性的过程和cell属性的过程一样，但不同的是supplementary view可以有很多种但只能有一种Cell。这是因为 supplementary view与它们是分离开的，是为了烘托主旨，所以每个supplementary view方法都会指明其各类以方便正确计算其特有的属性。

> 在layout中添加Decoration Views

Decoration Views是layout UI特征的有效点缀，与cell和supplementary view不同的是，它只做外观呈现用，所以与datasource无关。可以用来提供自定义背影，在Cells缝隙之间填充，甚至可以掩盖cell,它完全由layout对象控制。

在layout中添加Decoration view步骤如下：

1 用registerClass:forDecorationViewOfKind: or registerNib:forDecorationViewOfKind: method方法注册自定义的decoration view，但记住是在layout对象中注册

2 layout对象中layoutAttributesForElementsInRect:方法中为decoration view创建属性

3 实现layoutAttributesForDecorationViewOfKind:atIndexPath:方法并在请求时返回decoration view的布局属性

4 选择性地实现initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath: 和 finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:方法以处理出现和消失的动画，可参考下面的插入和删除动画部分

由于decoration view与cell和supplementary view的创建过程不同，注册class或者 nib即可，最多需要调用 一个initWithFrame:方法。但任何decoration view也需要是UICollectionReusableView子类，因为 也对其启用了回收机制。

> 插入和删除动画

插入及删除cell时collection view会询问layout对象提供一组初始化属性用于动画，同样，删除元素时会询问一组终值属性。

![image](https://upload-images.jianshu.io/upload_images/268750-44af6d2d9ef3b376.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

item插入时，layout对象提供正要被插入的item的初始化layout信息。在此例中，layout先将Cell的初始化位置设置到Collection view中间，并将其alpha通道设置为0，动画期间，此item会渐现并从中间移动到右下角。下面的代码描述了如何设置初始化信息及实现动画：

![image](https://upload-images.jianshu.io/upload_images/268750-a64cb521b2521b45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

需要注意的是，上述代码会使得此item插入的时候对所有Cell都会添加此插入的动画，若只想对插入的item做插入动画，可以检查 index path是否与传入prepareForCollectionViewUpdates:方法的item的index path匹配，并只在有匹配到的时候才进行动画，否则只返回super initialLayoutAttributesForAppearingItemAtIndexPath:

delete动画与插入类似，提供正确的final 属性即可

> 提升layout的滚动体验

滚动的时候scrollview会根据当前的speed和减速状况决定最终会停在哪个偏移，当算出这个停留位置之后，其会调用 targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法是否要改变这个位置，由于其是在滚动过程中调用此方法，所以自定义layout可以改变滚动的仪停留位置。

下图展示了调整滚动特性的效果

![image](https://upload-images.jianshu.io/upload_images/268750-9c00715d303bc260.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

假定collection view开始于（0，0），且用户向左侧滑，collection view计算出滚动原本会停下的位置，自定义layout可能会改变这个值以确保滚动停下的时候，某个item正好停留在可见区域正中间。这个新值会成为新的目标content offset，且会从targetContentOffsetForProposedContentOffset:withScrollingVelocity：方法返回。

注意：

1 items数较小（数百），或者items layout信息变化较小 时，可以在prepareLayout中创建并缓存layout信息

2 尽量不要继承UICollectionView

3 不要在layoutAttributesForElementsInRect：方法中调用uicollectionview的visiblecells方法，因为其实这个调用是转化成了向layout对象请求visible cells

### 21.用StoryBoard开发界面有什么弊端？如何避免？
* 难以维护
    - Storyboard在某些角度上，是难以维护的。我所遇到过的实际情况是，公司一个项目的2.0版本，设计师希望替换原有字体。然而原来项目的每一个Label都是采用Storyboard来定义字体的，因此替换新字体需要在Storyboard中更改每一个Label。
    - 幸亏我们知道Storyboard的源文件是XML，最终写了一个读取-解析-替换脚本来搞定这件事。
* 性能瓶颈
    - 当项目达到一定的规模，即使是高性能的MacBook Pro,在打开Storyboard是也会有3-5秒的读取时间。无论是只有几个Scene的小东西，还是几十个Scene的庞然大物，都无法避免。Scene越多的文件，打开速度越慢(从另一个方面说明了分割大故事板的重要性)。
    - 让人沮丧的是，这个造成卡顿的项目规模并不是太难达到。 
    - 我猜想是由于每一次打开都需要进行I/O操作造成的，Apple对这一块的缓存优化没有做到位。可能是由于Storyboard占用了太多内存，难以在内存中进行缓存。Whatever,这个问题总是让人困扰的。 
    - 然而需要指出的是，采用Storyboard开发或采用纯代码开发的App，在真机的运行效率上，并没有太大的区别。
* 错误定位困难
    - Storyboard的初学者应该对此深有体会。排除BAD_EXCUSE错误不说，单单是有提示的错误，就足以让人在代码和Storyboard之间来回摸索，却无法找到解决方案。

### 22.iOS滑块验证
#### 拼图的验证
- 思路：
    * 1.创建一个背景图片和一个滑块，需要注意的是我们需要压缩背景的显示图片到指定的尺寸目的是为了从这图片上截取某一块的时候frame对的上
    * 2 创建一个从可移动的图片，从背景图的随机位置截取某一部分，并绘制贝塞尔曲线
    * 3 创建一个遮罩层UIView （上面加入一个CAShapeLayer CAShapeLayer的贝塞尔曲线和截取图片的一样）
    * 4 拉动滑块移动让图片位置随着Slider的value值改变而改变frame
    * 5 判断可移动图片与遮罩层的frame的x值相差是否在误差范围内

#### 文本按顺序点击的验证
- 思路：
    * 创建普通的背景图和滑块。。。
    * 获取多个随机汉字并打乱顺序
    * 创建随机位置的按钮文本（x值固定，y值随机）

### 23.控件的点击事件和添加在上边的手势谁先响应，并说明原因
- 只会响应手势
- UIGestureRecognizer有个属性cancelsTouchesInView，这个属性默认值为YES，即当手势识别成功后，会发送touchesCancelled消息为view来结束view的响应。如果cancelsTouchesInView为NO，那么gestureRecognizer和view都可以响应。
UIKit内置了6中手势识别器：
    * UITapGestureRecognizer:点击（单击、双击、三连击等）手势。
    * UIPinchGestureRecognizer：缩放手势。
    * UIPanGestureRecognizer：拖拽手势。
    * UISwipeGestureRecognizer：滑动手势。
    * UIRotationGestureRecognizer：旋转手势。
    * UILongPressGestureRecognizer：长按手势。

## Foundation
### 1.nil`、`NIL`、`NSNULL` 有什么区别？
- nil、NIL 可以说是等价的，都代表内存中一块空地址。
- NSNULL 代表一个指向 nil 的对象。

### 2.如何实现一个线程安全的 `NSMutableArray`?
- NSMutableArray是线程不安全的，当有多个线程同时对数组进行操作的时候可能导致崩溃或数据错误
- 线程锁：使用线程锁对数组读写时进行加锁
- 派发队列：多用派发队列，少用同步锁中指出：使用“串行同步队列”，将读取操作及写入操作都安排在同一个队列里，即可保证数据同步。
- 而通过并发队列，结合GCD的栅栏块（barrier）来不仅实现数据同步线程安全，还比串行同步队列方式更高效。

### 3.如何定义一台 iOS 设备的唯一性?
- UUID+keyChain存储
- 获取UUID

```
[[UIDevice currentDevice] identifierForVendor] UUIDString]
```
- 当你升级或者重装软件的时候，UUID会发生变化，这时候我们再去获取UUID时，得到的值和以前的不一样，但其实还是同一台设备
- keychain：是钥匙串的意思，是苹果公司Mac OS中的密码管理系统。keychain里保存的信息不会因App被删除而丢失，在用户重新安装App后依然有效，数据还在。所以我们可以将UUID存储到keychain里面，需要用到的时候从keychain中取，这样可以保证UUID的唯一性。

### 4.atomic` 修饰的属性是绝对安全的吗？为什么？
- 不一定安全，所谓的安全只是局限于 Setter、Getter 的访问器方法而言的
- 方法里加入一些互斥锁，目的就是防止多(条)线程访问同一个内存地址，造成数据错误。
- 但是不能保证多线程安全，当开启两个异步线程频繁的去对ojb执行+1操作的时候，就不是线程安全的，解决方法是加锁

### 5.实现 `isEqual` 和 `hash` 方法时要注意什么？
- hash
    * 对关键属性的hash值进行位或运算作为hash值
- isEqual
    * ==运算符判断是否是同一对象,因为同一对象必然完全相同
    * 判断是否是同一类型,这样不仅可以提高判等的效率, 还可以避免隐式类型转换带来的潜在风险
    * 判断对象是否是nil, 做参数有效性检查
    * 各个属性分别使用默认判等方法进行判断
    * 返回所有属性判等的与结果

### 6.`id` 和 `instanceType` 有什么区别？
- 相同点
    * instancetype 和 id 都是万能指针，指向对象。
- 不同点：
    * id 在编译的时候不能判断对象的真实类型，instancetype 在编译的时候可以判断对象的真实类型。
    * id 可以用来定义变量，可以作为返回值类型，可以作为形参类型；instancetype只能作为返回值类型。

### 7.简述事件传递、事件响应机制。
#### UIResponder的继承链
- 首先要先了解响应者对象UIResponder，只有继承UIResponder的的类，才能处理事件。
- 我们可以看出UIApplication，UIView，UIViewController都是继承自UIResponder类，可以响应和处理事件。

#### 事件响应的过程？
- 响应者：响应者为响应事件的UIResponder子类对象，如UIButton、UIView等；
- 响应链：响应链是由链接在一起的响应者（UIResponse子类）组成的。
- 事件传递：获得响应链后，将事件由第一响应者往application传递的过程；
- 事件的传递过程

![image](https://upload-images.jianshu.io/upload_images/4986510-8e8307e475ec486f.png)

- 苹果基于mach port注册了一个Source1用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。
- 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个Source1就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用内部的分发。
- _UIApplicationHandleEventQueue() 会把IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。
- 其实说白了就是：当iOS程序发生触摸事件后，系统会利用Runloop将事件加入到UIApplication的任务队列中；UIApplication分发触摸事件到UIWindow，然后UIWindow依次向下分发给UIView；UIView调用hitTest:withEvent:方法看看自己能否处理事件，以及触摸点是否在自己上面；如果满足条件，就遍历UIView上的子控件。重复上面的动作；直到找到最顶层的一个满足条件（既能处理触摸事件，触摸点又在上面）的子控件，此子控件就是我们需要找到的第一响应者。

```
// 此方法返回的View是本次点击事件需要的最佳View
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event

// 判断一个点是否落在范围内
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
//返回最适合处理事件的视图，最好在父视图中指定子视图的响应

// 因为所有的视图类都是继承BaseView
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
   // 1.判断当前控件能否接收事件
   if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha <= 0.01) return nil;
   // 2. 判断点在不在当前控件
   if ([self pointInside:point withEvent:event] == NO) return nil;
   // 3.从后往前遍历自己的子控件
   NSInteger count = self.subviews.count;
   for (NSInteger i = count - 1; i >= 0; i--) {
       UIView *childView = self.subviews[I];
       // 把当前控件上的坐标系转换成子控件上的坐标系
    CGPoint childP = [self convertPoint:point toView:childView];
      UIView *fitView = [childView hitTest:childP withEvent:event];
       if (fitView) { // 寻找到最合适的view
           return fitView;
       }
   }
   // 循环结束,表示没有比自己更合适的view
   return self;
   
}
```

#### 手势识别的过程？
- 当 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用Cancel将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的UIGestureRecognizer 标记为待处理。
- 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer 的回调。
- 当有 UIGestureRecognizer的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

### 8.说一下对 `Super` 关键字的理解。
- 使用super关键字发送消息会被编译器转化为调用objc_msgSendSuper以及相关函数

```
id objc_msgSendSuper(struct objc_super *super, SEL op, ...);
```
- 这里的super已经不再是我们调用时写的[super init]的super了，这里指代的是struct objc_super结构体指针。

### 9.了解 逆变 和 协变 吗？
- __covariant:协变, 子类转父类 
- __contravariant:逆变 父类转子类
- 协变和逆变的作用就是，对象相互赋值时，对象属性(泛型)的处理
- 协变:`对象(属性泛型子类)`赋予`对象( 属性泛型父类)`
- 逆变:`对象(属性泛型父类)`赋予`对象( 属性泛型子类)`

### 10.`@synthesize` 和 `@dynamic` 分别有什么作用？
- @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;
- @synthesize 的语义是如果你没有手动实现 setter 方法和 getter方法，那么编译器会自动为你加上这两个方法。
- @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。
- 假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var =someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

### 11.Obj-C 中的反射机制了解吗？
- iOS反射机制：运行时选择创建哪个实例，并动态选择调用哪个方法。
- 常用判断方法

```
// 当前对象是否这个类或其子类的实例
- (BOOL)isKindOfClass:(Class)aClass;
// 当前对象是否是这个类的实例
- (BOOL)isMemberOfClass:(Class)aClass;
// 当前对象是否遵守这个协议
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;
// 当前对象是否实现这个方法
- (BOOL)respondsToSelector:(SEL)aSelector;
```
- 获取Class的三种方法

```
// 通过字符串获取class  
Class class = NSClassFromString(@"NSString");  
NSLog(@"class type : %@", class);  

// 直接用class 来创建对象 ,通过对象来获取class 
id str = [[class alloc] init];   
NSLog(@"%@", [str class]);  

// 通过类来获取class  
NSLog(@"%d", class==NSString.class);   
```
- 实际应用
    * 根据后台推送过来的数据，进行动态页面跳转，跳转到页面后根据返回到数据执行对应的操作。
- OC中使用反射的优点
    * 松耦合，类与类之间不需要太多依赖
    * 构建灵活
- OC中使用反射的缺点
    * 不利于维护。使用反射模糊了程序内部实际发生的事情，隐藏了程序的逻辑。这种绕过源码的方式比直接代码更为复杂，增加了维护成本。
    * 性能较差。使用反射匹配字符串间接命中内存比直接命中内存的方式要慢。当然，这个程度取决于使用场景，如果只是作为程序中很少涉及的部分，这个性能上的影响可以忽略不计。但是，如果在性能很关键的应用核心逻辑中使用反射，性能问题就尤其重要了

### 12.`typeof` 和 `__typeof`，`typeof` 的区别?
#### typeof
- 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。
- 可以理解为：我们根据typeof（）括号里面的变量，自动识别变量类型并返回该类型。
- typeof 常见运用于Block中，避免循环引用发生的问题。

#### 补充：typeof、__typeof__、__typeof的区别
- 我们经常会看到有的人是这样使用的__weak __typeof__(self) wself = self;有的是这样使用的__weak typeof(self) wself = self;, 有的是这样使用的__weak __typeof(self) wself = self;, 这三种方式有什么区别呢
- __typeof__()和 typeof() 和 __typeof()等都是C语言的扩展, 要表达的意思都是一样的, 这个时候需要说到C的发展, 其中两个阶段, GNUC 和 标准C在GNUC环境下, 其扩展是支持直接写__typeof__()和typeof()和__typeof()而在标准C环境下, 其扩展是以__开头, 所以其只能写成__typeof__()和__typeof()

#### typedef：
- 定义一种类型的别名，而不只是简单的宏替换。
- typedef 常用于命名（枚举和Block）

### 补充：self + weakSelf + strongSelf ?

```
__weak __typeof(self)weakSelf = self;    //1

[self.context performBlock:^{      
    [weakSelf doSomething];          //2
     __strong __typeof(weakSelf)strongSelf = weakSelf;  //3
    [strongSelf doAnotherSomething];        
}];
```
- 1.使用__weak __typeof是在编译的时候,另外创建一个局部变量weak对象来操作self，引用计数不变。block 会将这个局部变量捕获为自己的属性，访问这个属性，从而达到访问 self的效果，因为他们的内存地址都是一样的。
- 2.因为weakSelf和self是两个变量,doSomething有可能就直接对self自身引用计数减到0了.所以在[weakSelf doSomething]的时候,你很难控制这里self是否就会被释放了.weakSelf只能看着.
- __strong __typeof在编译的时候,实际是对weakSelf的强引用.指针连带关系self的引用计数会增加.但是你这个是在block里面,生命周期也只在当前block的作用域.所以,当这个block结束,strongSelf随之也就被释放了.不会影响block外部的self的生命周期.
- 在 Block 内如果需要访问self的方法、变量，建议使用 weakSelf。
- 如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。

### 13.头文件导入的方式？
### 14.如何将 Obj-C 代码改变为 C++/C 的代码？
- clang -rewrite-objc -fobjc-arc -fobjc-runtime=macosx-10.13 main.m

### 15.知不知道在哪里下载苹果的源代码？
- https://opensource.apple.com/source

### 16.objc_getClass()、object_getClass()、Class 这三个方法用来获取类对象有什么不同？
- 全部返回 Class 类对象
- class 方法
    * class 方法无论是类对象还是实例对象都可以调用，可以嵌套，返回永远是自身的类对象。
- object_getClass 方法
    * object_getClass 和 class 同样可以嵌套，但是 object_getClass 得到的是他的 isa 指向的地址。
- objc_getClass 方法
    * objc_getClass 无法嵌套，因为参数 是 char 类型，效果和 class 相同

### 17.NSCache优于NSDictionary的几点？
- NSCache苹果提供的一套缓存机制
    * 主要作用于内存缓存的管理方面;
    * 在没有引入NSCache之前,我们要管理缓存,都是使用的NSMutableDictionary来管理,如:

```
// 定义下载操作缓存池
@property (nonatomic, strong) NSMutableDictionary *operationCache;
// 定义图片缓存池
@property (nonatomic, strong) NSMutableDictionary *imageCache;

```
然而,使用NSMutableDictionary来管理缓存是有些不妥的, 知道多线程操作原理的开发者都明白, NSMutableDictionary在线程方面来说是不安全,这也是苹果官方文档明确说明了的,而如果使用的是NSCache,那就不会出现这些问题.

- NSCache和NSMutableDictionary的相同点与区别
    * 相同点：
        * NSCache和NSMutableDictionary功能用法基本是相同的。
    * 区别：
        * NSCache是线程安全的，NSMutableDictionary线程不安全;NSCache线程是安全的，Mutable开发的类一般都是线程不安全的
        * 当内存不足时NSCache会自动释放内存(所以从缓存中取数据的时候总要判断是否为空)
        * NSCache可以指定缓存的限额，当缓存超出限额自动释放内存缓存限额：
            * 缓存数量
            
            @property NSUInteger countLimit;
            * 缓存成本
            
            @property NSUInteger totalCostLimit;
        * 苹果给NSCache封装了更多的方法和属性,比NSMutableDictionary的功能要强大很多

代码演示：

先定义缓存池,并懒加载初始化:


```
#import "ViewController.h"

@interface ViewController () <NSCacheDelegate>

// 定义缓存池
@property (nonatomic, strong) NSCache *cache;
@end

@implementation ViewController
- (NSCache *)cache {
if (_cache == nil) {
    _cache = [[NSCache alloc] init];
    // 缓存中总共可以存储多少条
    _cache.countLimit = 5;
    // 缓存的数据总量为多少
    _cache.totalCostLimit = 1024 * 5;
}
return _cache;
}

- (void)viewDidLoad {
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.

  //添加缓存数据
   for (int i = 0; i < 10; i++) {
    [self.cache setObject:[NSString stringWithFormat:@"hello %d",i] forKey:[NSString stringWithFormat:@"h%d",i]];
    NSLog(@"添加 %@",[NSString stringWithFormat:@"hello %d",i]);
   }

  //输出缓存中的数据
   for (int i = 0; i < 10; i++) {
    NSLog(@"%@",[self.cache objectForKey:[NSString stringWithFormat:@"h%d",i]]);
   }

}

```
控制台输出结果为:

![image](https://upload-images.jianshu.io/upload_images/1483059-7d13b9b81f721289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/455)

**通过输出结果可以看出: **

1.当我们使用NSCache来创建缓存池的时候,我们可以很灵活的设置缓存的限额,

2.当程序中的个数超过我们的限额的时候,会先移除最先创建的

3.如果已经移除了,那么当我们输出缓存中的数据的时候,就只剩下后面创建的数据了;

#### 演示NSCache的代理方法

先设置代理对象:
- (void)viewDidLoad {
[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
//设置NSCache的代理
self.cache.delegate = self;
调用代理方法: 这里我仅用一个方法来演示:


```
//当缓存被移除的时候执行
         - (void)cache:(NSCache *)cache willEvictObject:(id)obj{
        NSLog(@"缓存移除  %@",obj);
       }
```
![image](https://camo.githubusercontent.com/ba7de0659ecacb3d4d33d30ea1c4eb564b56a3bb/68747470733a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f696d672f3230313630322f31363232313531375f773432722e706e67)

通过结果可以看出: NSCache的功能要比NSMutableDictionary的功能要强大很多很多;

#### 当遇到内存警告的时候

```
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    //当收到内存警告，清除内存
    [self.cache removeAllObjects];
    //输出缓存中的数据
    for (int i = 0; i < 10; i++) {
        NSLog(@"%@",[self.cache objectForKey:[NSString stringWithFormat:@"h%d",i]]);
    }
}
```
控制台输出结果:

![image](https://camo.githubusercontent.com/9d0895f61d5c29f257092c7a32d5b5cce8043a9e/68747470733a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f696d672f3230313630322f31363232303331345f505064382e706e67)

通过结果可以看出: 当收到内存警告之后,清除数据之后,NSCache缓存池中所有的数据都会为空!

#### 当收到内存警告，调用removeAllObjects 之后，无法再次往缓存池中添加数据


```
- (void)didReceiveMemoryWarning {
    [super didReceiveMemoryWarning];
    //当收到内存警告，调用removeAllObjects 之后，无法再次往缓存中添加数据
    [self.cache removeAllObjects];
    //输出缓存中的数据
    for (int i = 0; i < 10; i++) {
        NSLog(@"%@",[self.cache objectForKey:[NSString stringWithFormat:@"h%d",i]]);
    }
}

// 触摸事件, 以便验证添加数据
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    [self.cache removeAllObjects];
    
    //添加缓存数据
    for (int i = 0; i < 10; i++) {
        [self.cache setObject:[NSString stringWithFormat:@"hello %d",i] forKey:[NSString stringWithFormat:@"h%d",i]];
//        NSLog(@"添加 %@",[NSString stringWithFormat:@"hello %d",i]);
    }
    
    //输出缓存中的数据
    for (int i = 0; i < 10; i++) {
        NSLog(@"%@",[self.cache objectForKey:[NSString stringWithFormat:@"h%d",i]]);
    }

}
```
控制台输出结果为: 

![image](https://camo.githubusercontent.com/c30bb9b1a4d03a949190145b441ed3ebc888504b/68747470733a2f2f7374617469632e6f736368696e612e6e65742f75706c6f6164732f696d672f3230313630322f31363232313931345f664678622e706e67)

通过输出结果,我们可以看出: 当收到内存警告，而我们又调用removeAllObjects 之后，则无法再次往缓存中添加数据;

### 补充：NSCache，NSDictionary，NSArray的区别
#### NSArray
- NSArray作为一个存储对象的有序集合，可能是被使用最多的集合类。
- 性能特征
    * 在数组的开头和结尾插入/删除元素通常是一个O(1)操作，而随机的插入/删除通常是 O(N)的。
- 有用的方法
    * NSArray的大多数方法使用isEqual:来检查对象间的关系(例如containsObject:)。有一个特别的方法

```
indexOfObjectIdenticalTo:
```
- 用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。

#### NSDictionary
- 一个字典存储任意的对象键值对。 由于历史原因，初始化方法使用相反的对象到值的方法

```
[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]
```
- 而新的快捷语法则从key开始

```
@{key : value, ...}
```
- NSDictionary中的键是被拷贝的并且需要是恒定的。如果在一个键在被用于在字典中放入一个值后被改变，那么这个值可能就会变得无法获取了。一个有趣的细节，在NSDictionary中键是被拷贝的，而在使用一个toll-free桥接的CFDictionary时却只被retain。CoreFoundation类没有通用对象的拷贝方法，因此这时拷贝是不可能的(*)。这只适用于使用CFDictionarySetValue()的时候。如果通过setObject:forKey使用toll-free桥接的CFDictionary，苹果增加了额外处理逻辑来使键被拷贝。反过来这个结论则不成立 — 转换为CFDictionary的NSDictionary对象，对其使用CFDictionarySetValue()方法会调用回setObject:forKey并拷贝键。

#### NSCache
- NSCache是一个非常奇怪的集合。在iOS 4/Snow Leopard中加入，默认为可变并且线程安全的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的成本清理自己。与NSDictionary相比，键是被retain而不是被拷贝的。
- NSCache的回收方法是不确定的，NSCache可以设置撑自动回收实现了NSDiscardableContent协议的对象。实现该属性的一个比较流行的类是同时间加入的NSPurgeableData，但是在OS X 10.9之前，是非线程安全的
- NSCache性能
    * 那么NSCache如何承受NSMutableDictionary的考验?加入的线程安全必然会带来一些消耗。

#### iOS 构建缓存时选 NSCache 而非NSDictionary
- 当系统资源将要耗尽时，NSCache可以自动删减缓存。如果采用普通的字典，那么就要自己编写挂钩，在系统通知时手动删减缓存，NSCache会先行删减时间最久为被使用的对象
- NSCache 并不会拷贝键，而是会保留它。此行为用NSDictionary也可以实现，但是需要编写比较复杂的代码。NSCache对象不拷贝键的原因在于，很多时候键都是不支持拷贝操作的对象来充当的。因此NSCache对象不会自动拷贝键，所以在键不支持拷贝操作的情况下，该类比字典用起来更方便
- NScache是线程安全的，NSDictionary不是。在开发者自己不编写加锁代码的前提下，多个线程可以同时访问NSCache。对缓存来说，线程安全通常是很重要的，因为开发者可能在某个线程中读取数据，此时如果发现缓存里找不着指定的键，那么就要下载该键对应的数据了

### 18.知不知道DesignatedInitializer？使用它的时候有什么需要注意的问题？
### 19.实现description方法能取到什么效果？


## iOS 内存管理
### 补充：为什么说Objective-C是一门动态的语言
- 首先动态类型语言和静态类型语言
    * 动态类型语言
        * 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。
    * 静态类型语言
        * 静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有C#、JAVA等。
- oc具有相当多的动态特性，表现在三个方面：动态类型、动态绑定、动态加载。之所以叫做动态，是因为必须到运行时才会做一些事情。
    * 动态类型：即运行时再决定对象的类型。这类动态类型在日常应用中非常常见。简单说就是id类型。实际上静态类型因为其固定性和可预知性而使用的非常广泛，静态类型是请类型，而动态类型属于弱类型。运行时决定接受者。
    * 动态绑定：基于动态类型，在某个实例对象被确定后，起类型就被确定了。该对象的属性和响应的消息也被完全确定，这就是动态绑定
    * 动态加载：根据需求加载所需要的资源，这点很容易理解，对于ios开发来说，基本就是根据不同的急性左适配。最经典的例子就是在Retina设备上加载@2X的图片，而在老一些的普通设备上加载原图。随着Retina iPad的推出，和之后可能的Retina Mac的出现，这个特性相信会被越来越多的使用。让程序在运行时添加代码块以及其他资源。用户可以根据需要加载一些课指向代码和资源，而不是在启动时就加载所有组件。可执行代码中可以含有和程序运行时整合的新类。

### 1.说一下对 retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解。
- Strong：修饰符表示指向并持有该对象，其修饰对象的引用计数会加1。该对象只要引用计数不为0就不会被销毁。当然可以通过将变量强制赋值 nil 来进行销毁。
- weak：修饰符指向但是并不持有该对象，引用计数也不会加1。在 Runtime 中对该属性进行了相关操作，无需处理，可以自动销毁。weak用来修饰对象，多用于避免循环引用的地方。weak 不可以修饰基本数据类型。
- assign：主要用于修饰基本数据类型，例如NSInteger，CGFloat，存储在栈中，内存不用程序员管理。assign是可以修饰对象的，但是会出现问题。
- copy：关键字和strong类似，copy多用于修饰有可变类型的不可变对象上NSString,NSArray,NSDictionary上。
- __unsafe_unretain：类似于weak，但是当对象被释放后，指针已然保存着之前的地址，被释放后的地址变为僵尸对象，访问被释放的地址就会出问题，所以说他是不安全的。
- __autoreleasing：将对象赋值给附有__autoreleasing修饰的变量等同于 ARC 无效时调用对象的autorelease方法,实质就是扔进了自动释放池。

### 2.简述下列属性的作用：readwrite、readonly、assign、retain、copy、nonatomic、weak、strong
- readwrite：可读可写特性,需要生成setter和getter方法时使用, 可被外界读取和修改；
- readonly：只读特性,只会生成getter方法,只可被外界读取, 不能修改；
- assign：赋值特性,作用于非OC对象的赋值,setter方法将参数传给变量；
- retain：持有特性,他的setter方法会释放旧址,然后引用住新值, 并且将新值的引用计数+1,只能作用于OC对象(基本数据类型和CoreFoundation对象没有引用计数的概念, 因此不能用retain)
- copy
    * 复制特性,此属性只对遵守了NSCopying协议的对象类型有效,一般作用于NSString,NSArray,NSDictionary等有可变类型的对象
    * 如果copy的是不可变类型,就不会开辟新的内存空间, 并且为指针拷贝, 指向同一个内存地址:浅拷贝
    * 如果copy的是可变类型, 就会开辟新的内存空间, 并且将内容copy下来单独保存: 深拷贝
    * 注意: 如果在系统中创建内容相同的不可变字符串, 系统会自动做出优化, 指向同一块内存空间
- nonatomic
    * 非原子性,即非线程安全的,不给变量提供线程锁保护, 这样会提高性能
    * 在iOS的移动端,一般不会出现多线程访问同一个属性的情况,就算发生情况,atomic也不能完美的保证安全, 并且还需要手动增加线程锁,因此对于变量都应该使用nonatomic
- atomic
    * atomic会给属性加上一个同步锁,这是为了防止多线程同时访问属性出现异常需要添加的属性,但是这样会增加额外的内存开销并且在变编程习惯中,我们都应该避免多线程访问统一资源
    * 即便是使用atomic,在多线程时也无法完全保证线程安全, 往往是需要手动添加线程锁

### 补充：assign 修饰对象可能存在的问题
- 对象开辟的空间是在堆空间，指针开辟的空间是在栈上，使用assign修饰，当对象销毁时并不会将指针置为nil。所以当堆空间的对象销毁时指向对象的指针仍然存在，会造成野指针，当访问该对象时会crash报错EXC_BAD_ACCESS。因为基本数据类型的空间开辟也在栈空间，同样由系统进行销毁，所以不存在野指针的情况。使用weak修饰对象时当对象销毁时指针也会被置为nil，所以用weak不会造成野指针。

### 3.automic的实现机制；
- 添加属性时使用了automic声明的，系统会自动在setter和getter方法中添加锁来实现读写安全。
- 通过源码查看发现automic的原理是使用OSSPinLock来实现的，这种自旋锁会出现优先级反转导致死锁的问题，所以不推荐automic。
- 在iOS 10之后系统推荐使用os_unfair_lock来代替OSSPinlock，并且automic在iOS10之后也使用os_unfair_lock来实现了。

### 4.atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？
- atomic 和 nonatomic 的区别在于，系统自动生成的 getter/setter 方法不一样。如果你自己写 getter/setter，那 atomic/nonatomic/retain/assign/copy 这些关键字只起提示作用，写不写都一样。
- 其实质就是，atomic比nonatomic多了一个互斥加锁代码，避免该变量的读写不同步问题。
- 对于atomic的属性，系统生成的 getter/setter 会保证 get、set 操作的完整性，不受其他线程影响。比如，线程 A 的 getter 方法运行到一半，线程 B 调用了 setter：那么线程 A 的 getter 还是能得到一个完好无损的对象。 而nonatomic就没有这个保证了。所以，nonatomic的速度要比atomic快。据说快大约20倍。
- 不过atomic可并不能保证线程安全。如果线程 A 调了 getter，与此同时线程 B 、线程 C 都调了 setter——那最后线程 A get 到的值，3种都有可能：可能是 B、C set 之前原始的值，也可能是 B set 的值，也可能是 C set 的值。同时，最终这个属性的值，可能是 B set 的值，也有可能是 C set 的值。
- 解决方案是加锁。

### 5.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的
- @property 的本质是什么？
    * @property = ivar + getter + setter;
- 下面解释下：
    * “属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。
    * “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:
    * 编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：
    * @property = getter + setter;
    * 例如下面这个类：

```
@interface Person : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end
```
上述代码写出来的类与下面这种写法等效：

```
@interface Person : NSObject
- (NSString *)firstName;
- (void)setFirstName:(NSString *)firstName;
- (NSString *)lastName;
- (void)setLastName:(NSString *)lastName;
@end
```
property在runtime中是objc_property_t定义如下:

```
typedef struct objc_property *objc_property_t;
```
而objc_property是一个结构体，包括name和attributes，定义如下：

```
struct property_t {
    const char *name;
    const char *attributes;
};
```
而attributes本质是objc_property_attribute_t，定义了property的一些属性，定义如下：

```
/// Defines a property attribute
typedef struct {
    const char *name;           /**< The name of the attribute */
    const char *value;          /**< The value of the attribute (usually empty) */
} objc_property_attribute_t;
```
而attributes的具体内容是什么呢？其实，包括：类型，原子性，内存语义和对应的实例变量。

例如：我们定义一个string的property@property (nonatomic, copy) NSString *string;，通过 property_getAttributes(property)获取到attributes并打印出来之后的结果为T@"NSString",C,N,V_string

其中T就代表类型，C就代表Copy，N代表nonatomic，V就代表对于的实例变量。

- ivar、getter、setter 是如何生成并添加到这个类中的?
    * “自动合成”( autosynthesis)
完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字.

```
@implementation Person
@synthesize firstName = _myFirstName;
@synthesize lastName = _myLastName;
@end
```
我为了搞清属性是怎么实现的,曾经反编译过相关的代码,他大致生成了五个东西
- OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
- setter 与 getter 方法对应的实现函数
- ivar_list ：成员变量列表
- method_list ：方法列表
- prop_list ：属性列表

也就是说我们每次在增加一个属性,系统都会在 ivar_list 中添加一个成员变量的描述,在 method_list 中增加 setter 与 getter 方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出 setter 与 getter 方法对应的实现,在 setter 方法中从偏移量的位置开始赋值,在 getter 方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.

### 6.@property 后面可以有哪些修饰符？
- 常用的修饰符有4类：
    * readonly,readwrite表示读写全线
    * retain,copy,assign,strong,weak表示引用方式,涉及属性自动创建的setter的实现
    * nonatomic,atomic意为原子特性,表示是否线程安全.
    * getter,setter表示自定义的获取/设置方法.

### 7.@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符
- 属性可以拥有的特质分为四类:

    * 原子性--- nonatomic 特质
    
        在默认情况下，由编译器合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用自旋锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的” ( atomic) )，但是仍然可以在属性特质中写明这一点，编译器不会报错。若是自己定义存取方法，那么就应该遵从与属性特质相符的原子性。

    * 读/写权限---readwrite(读写)、readonly (只读)

    * 内存管理语义---assign、strong、 weak、unsafe_unretained、copy

    * 方法名---getter=<name> 、setter=<name>
        * getter=<name>的样式：
```
@property (nonatomic, getter=isOn) BOOL on;
```
        
- - - setter=<name>一般用在特殊的情境下，比如：
    
    在数据反序列化、转模型的过程中，服务器返回的字段如果以 init 开头，所以你需要定义一个 init 开头的属性，但默认生成的 setter 与 getter 方法也会以 init 开头，而编译器会把所有以 init 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。

这时你就可以使用下面的方式来避免编译器报错：

```
@property(nonatomic, strong, getter=p_initBy, setter=setP_initBy:)NSString *initBy;
```
另外也可以用关键字进行特殊说明，来避免编译器报错：

```
@property(nonatomic, readwrite, copy, null_resettable) NSString *initBy;
- (NSString *)initBy __attribute__((objc_method_family(none)));
```

### 8.什么情况使用 weak 关键字，相比 assign 有什么不同？
- 什么情况使用weak关键字
    * 在ARC模式下，在有可能出现循环引用时，让其一端使用weak修饰。例如：delegate（代理）属性；
    * 自身已经对它强引用一次了，没有必再强引用一次使用weak解决。例如：自定义IBOutlet控件属性。当然，也可以使用strong。
 
- 相比assign有什么不同
    * weak只能用于修饰对象类型，基本数据类型不能使用，weak的特质表明，该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 但是在属性所指向的对象被摧毁时，属性值也会清空(nil out)。但是assign的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。
    * assign 可以用非 OC 对象,而 weak 必须用于 OC 对象。
    * ==注意:assign修饰的对象（一般编译的时候会产生警告：Assigning retained object to unsafe property; object will be released after assignment）在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil，造成野指针。对象一般分配在堆上的某块内存，如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。那为什么可以用assign修饰基本数据类型？因为基础数据类型一般分配在栈上，栈的内存会由系统自己自动处理，不会造成野指针。weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。==

### 9.@protocol 和 category 中如何使用 @property
- category和protocol都可以添加方法，也都可以添加@property 关键字
- 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性，也就是说，在实现这个protocol协议的类中，我们要自己手动添加实例变量，并且需要实现setter和getter方法
- category 使用 @property 也是只会生成 setter 和 getter 方法的声明,由于category不能添加实例变量，故必须通过运行时添加associated object的方法来添加实例变量，如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：
    * objc_setAssociatedObject
    * objc_getAssociatedObject

### 10.__weak 和 _Unsafe_Unretain 的区别
- weak 修饰的指针变量，在指向的内存地址销毁后，会在 Runtime 的机制下，自动置为 nil。
- _Unsafe_Unretain不会置为 nil，容易出现 悬垂指针，发生崩溃。但是 _Unsafe_Unretain 比 __weak 效率高。

### 11._weak 属性修饰的变量，如何实现在变量没有强引用后自动置为 nil
- 用的弱引用 - weak表。也是一张 哈希表。
- 被 weak 修饰的指针变量所指向的地址是 key ，所有指向这块内存地址的指针会被添加在一个数组里，这个数组是 Value。当内存地址销毁，数组里的所有对象被置为 nil。

### 12.runtime如何实现weak变量的自动置nil？
- 用的弱引用 - weak表。也是一张 哈希表。
- 被 weak 修饰的指针变量所指向的地址是 key ，所有指向这块内存地址的指针会被添加在一个数组里，这个数组是 Value。当内存地址销毁，数组里的所有对象被置为 nil。

### 13.weak属性需要在dealloc中置nil么？
- 不需要。
- 在ARC环境无论是强指针还是弱指针都无需在 dealloc 设置为 nil ， ARC 会自动帮我们处理
- 即便是编译器不帮我们做这些，weak也不需要在 dealloc 中置nil：
- 我们模拟下 weak 的 setter 方法，应该如下：

```
- (void)setObject:(NSObject *)object
{
   objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
   [object cyl_runAtDealloc:^{
       _object = nil;
   }];
}
```
也即:
在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。

### 14.runtime 如何实现 weak 属性
- 要实现 weak 属性，首先要搞清楚 weak 属性的特点：
    * weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同 assign 类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。
- 那么 runtime 如何实现 weak 变量的自动置nil？
    * runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
- 对象的内存销毁时间表，分四个步骤：

```
// 对象的内存销毁时间表
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
// 根据 WWDC 2011, Session 322 (36分22秒)中发布的内存销毁时间表 

 1. 调用 -release ：引用计数变为零
     * 对象正在被销毁，生命周期即将结束.
     * 不能再有新的 __weak 弱引用， 否则将指向 nil.
     * 调用 [self dealloc] 
 2. 子类 调用 -dealloc
     * 继承关系中最底层的子类 在调用 -dealloc
     * 如果是 MRC 代码 则会手动释放实例变量们（iVars）
     * 继承关系中每一层的父类 都在调用 -dealloc
 3. NSObject 调 -dealloc
     * 只做一件事：调用 Objective-C runtime 中的 object_dispose() 方法
 4. 调用 object_dispose()
     * 为 C++ 的实例变量们（iVars）调用 destructors 
     * 为 ARC 状态下的 实例变量们（iVars） 调用 -release 
     * 解除所有使用 runtime Associate方法关联的对象
     * 解除所有 __weak 引用
     * 调用 free()
```
- 先看下 runtime 里源码的实现：

```
/**
* The internal structure stored in the weak references table. 
* It maintains and stores
* a hash set of weak references pointing to an object.
* If out_of_line==0, the set is instead a small inline array.
*/
#define WEAK_INLINE_COUNT 4
struct weak_entry_t {
   DisguisedPtr<objc_object> referent;
   union {
       struct {
           weak_referrer_t *referrers;
           uintptr_t        out_of_line : 1;
           uintptr_t        num_refs : PTR_MINUS_1;
           uintptr_t        mask;
           uintptr_t        max_hash_displacement;
       };
       struct {
           // out_of_line=0 is LSB of one of these (don't care which)
           weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
       };
   };
};

/**
* The global weak references table. Stores object ids as keys,
* and weak_entry_t structs as their values.
*/
struct weak_table_t {
   weak_entry_t *weak_entries;
   size_t    num_entries;
   uintptr_t mask;
   uintptr_t max_hash_displacement;
};
```
具体完整实现参照 [objc/objc-weak.h](https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h) 。

- 我们可以设计一个函数（伪代码）来表示上述机制：
    * objc_storeWeak(&a, b)函数：
        * objc_storeWeak函数把第二个参数--赋值对象（b）的内存地址作为键值key，将第一个参数--weak修饰的属性变量（a）的内存地址（&a）作为value，注册到 weak 表中。如果第二个参数（b）为0（nil），那么把变量（a）的内存地址（&a）从weak表中删除，
        * 你可以把objc_storeWeak(&a, b)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。
        * 在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。
        * 而如果a是由 assign 修饰的，则： 在 b 非 nil 时，a 和 b 指向同一个内存地址，在 b 变 nil 时，a 还是指向该内存地址，变野指针。此时向 a 发送消息极易崩溃。
- 下面我们将基于objc_storeWeak(&a, b)函数，使用伪代码模拟“runtime如何实现weak属性”：

```
// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

 id obj1;
 objc_initWeak(&obj1, obj);
/*obj引用计数变为0，变量作用域结束*/
 objc_destroyWeak(&obj1);
```
- 下面对用到的两个方法objc_initWeak和objc_destroyWeak做下解释：
    * 总体说来，作用是： 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。
- 下面分别介绍下方法的内部实现：
    * objc_initWeak函数的实现是这样的：在将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。

```
obj1 = 0；
obj_storeWeak(&obj1, obj);
```
也就是说：weak 修饰的指针默认值是 nil 

（在Objective-C中向nil发送消息是安全的）
然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。

objc_storeWeak(&obj1, 0);

- 前面的源代码与下列源代码相同。

```
// 使用伪代码模拟：runtime如何实现weak属性
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong

id obj1;
obj1 = 0;
objc_storeWeak(&obj1, obj);
/* ... obj的引用计数变为0，被置nil ... */
objc_storeWeak(&obj1, 0);
```
objc_storeWeak 函数把第二个参数--赋值对象（obj）的内存地址作为键值，将第一个参数--weak修饰的属性变量（obj1）的内存地址注册到 weak 表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从 weak 表中删除，在后面的相关一题会详解。

- 使用伪代码是为了方便理解，下面我们“真枪实弹”地实现下：
- 如何让不使用weak修饰的@property，拥有weak的效果。
- 我们从setter方法入手：
    * 注意以下的 cyl_runAtDealloc 方法实现仅仅用于模拟原理，如果想用于项目中，还需要考虑更复杂的场景，想在实际项目使用的话，可以使用我写的一个小库，可以使用 CocoaPods 在项目中使用： CYLDeallocBlockExecutor ）

```
- (void)setObject:(NSObject *)object
{
   objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
   [object cyl_runAtDealloc:^{
       _object = nil;
   }];
}
```
- 也就是有两个步骤：
1. 在setter方法中做如下设置：
```
objc_setAssociatedObject(self, "object", object, OBJC_ASSOCIATION_ASSIGN);
```
2. 在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。做到这点，同样要借助 runtime：

```
//要销毁的目标对象
id objectToBeDeallocated;
//可以理解为一个“事件”：当上面的目标对象销毁时，同时要发生的“事件”。
id objectWeWantToBeReleasedWhenThatHappens;
objc_setAssociatedObject(objectToBeDeallocted,
                        someUniqueKey,
                        objectWeWantToBeReleasedWhenThatHappens,
                        OBJC_ASSOCIATION_RETAIN);
```
知道了思路，我们就开始实现 cyl_runAtDealloc 方法，实现过程分两部分：

第一部分：创建一个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助 block 执行“事件”。

// .h文件

```
// .h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

typedef void (^voidBlock)(void);

@interface CYLBlockExecutor : NSObject

- (id)initWithBlock:(voidBlock)block;

@end
```
// .m文件

```
// .m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 这个类，可以理解为一个“事件”：当目标对象销毁时，同时要发生的“事件”。借助block执行“事件”。

#import "CYLBlockExecutor.h"

@interface CYLBlockExecutor() {
   voidBlock _block;
}
@implementation CYLBlockExecutor

- (id)initWithBlock:(voidBlock)aBlock
{
   self = [super init];
   
   if (self) {
       _block = [aBlock copy];
   }
   
   return self;
}

- (void)dealloc
{
   _block ? _block() : nil;
}

@end
```
第二部分：核心代码：利用runtime实现cyl_runAtDealloc方法

```
// CYLNSObject+RunAtDealloc.h文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLBlockExecutor.h"

const void *runAtDeallocBlockKey = &runAtDeallocBlockKey;

@interface NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block;

@end


// CYLNSObject+RunAtDealloc.m文件
// http://weibo.com/luohanchenyilong/
// https://github.com/ChenYilong
// 利用runtime实现cyl_runAtDealloc方法

#import "CYLNSObject+RunAtDealloc.h"
#import "CYLBlockExecutor.h"

@implementation NSObject (CYLRunAtDealloc)

- (void)cyl_runAtDealloc:(voidBlock)block
{
   if (block) {
       CYLBlockExecutor *executor = [[CYLBlockExecutor alloc] initWithBlock:block];
       
       objc_setAssociatedObject(self,
                                runAtDeallocBlockKey,
                                executor,
                                OBJC_ASSOCIATION_RETAIN);
   }
}

@end
```
使用方法： 导入

```
#import "CYLNSObject+RunAtDealloc.h"
```
然后就可以使用了：

```
NSObject *foo = [[NSObject alloc] init];

[foo cyl_runAtDealloc:^{
   NSLog(@"正在释放foo!");
}];
```

### 15.怎么用 copy 关键字？
- 用途：
    * NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
    * block 也经常使用 copy 关键字，具体原因见官方文档：Objects Use Properties to Keep Track of Blocks：
- block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。你也许会感觉我这种做法有些怪异，不需要写依然写。如果你这样想，其实是你“日用而不知”，你平时开发中是经常在用我说的这种做法的，比如下面的属性不写copy也行，但是你会选择写还是不写呢？

```
@property (nonatomic, copy) NSString *userId;

- (instancetype)initWithUserId:(NSString *)userId {
   self = [super init];
   if (!self) {
       return nil;
   }
   _userId = [userId copy];
   return self;
}
```

![image](https://camo.githubusercontent.com/8a5fa34435801cc4c2715d8880f3abd45be6a6c5/687474703a2f2f692e696d6775722e636f6d2f566c564b6c384c2e706e67)

下面做下解释： copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
> 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

### 16.如何令自己所写的对象具有拷贝功能?
> 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
- 具体步骤：
    * 需声明该类遵从 NSCopying 协议
    * 实现 NSCopying 协议。该协议只有一个方法:

```
- (id)copyWithZone:(NSZone *)zone;
```
- 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。
- 以第一题的代码为例：

```
// .h文件
   // 修改完的代码

   typedef NS_ENUM(NSInteger, CYLSex) {
       CYLSexMan,
       CYLSexWoman
   };

   @interface CYLUser : NSObject<NSCopying>

   @property (nonatomic, readonly, copy) NSString *name;
   @property (nonatomic, readonly, assign) NSUInteger age;
   @property (nonatomic, readonly, assign) CYLSex sex;

   - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
   + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

   @end
```
然后实现协议中规定的方法：

```
- (id)copyWithZone:(NSZone *)zone {
	CYLUser *copy = [[[self class] allocWithZone:zone] 
		             initWithName:_name
 							      age:_age
						          sex:_sex];
	return copy;
}
```
但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:

```
// .h文件
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject<NSCopying>

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
```
// .m文件

```
// .m
//

@implementation CYLUser {
   NSMutableSet *_friends;
}

- (void)setName:(NSString *)name {
   _name = [name copy];
}

- (instancetype)initWithName:(NSString *)name
                        age:(NSUInteger)age
                        sex:(CYLSex)sex {
   if(self = [super init]) {
       _name = [name copy];
       _age = age;
       _sex = sex;
       _friends = [[NSMutableSet alloc] init];
   }
   return self;
}

- (void)addFriend:(CYLUser *)user {
   [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
   [_friends removeObject:user];
}

- (id)copyWithZone:(NSZone *)zone {
   CYLUser *copy = [[[self class] allocWithZone:zone]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [_friends mutableCopy];
   return copy;
}

- (id)deepCopy {
   CYLUser *copy = [[[self class] alloc]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                            copyItems:YES];
   return copy;
}

@end
```
以上做法能满足基本的需求，但是也有缺陷：
> 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。

在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:

```
- (id)deepCopy {
   CYLUser *copy = [[[self class] alloc]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                            copyItems:YES];
   return copy;
}
```

### 17.这个写法会出什么问题： @property (copy) NSMutableArray *array;
- 两个问题：
    * 1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的实例方法而崩溃.报
```
-[__NSArrayI addObject:]: unrecognized selector sent to instance 0x7ff240614b40
```
错误，因为 copy 就是复制一个不可变 NSArray 的对象；

 - - 2、使用了 atomic 属性会严重影响性能 ；

- 具体分析：
    * 第一个原因：copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString（或NSArray，NSDictionary） 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString（或NSMutableArray，NSMutableDictionary） 类的实例。这个类是 NSString（或NSArray，NSDictionary） 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。所以使用copy 就是复制一个不可变 NSArray 的对象；所以会报找不到对应的实例方法而崩溃。
    * 第二个原因：该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明 nonatomic 可以节省这些虽然很小但是不必要额外开销。在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用 atomic 属性通常都不会有性能瓶颈。

### 18.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？
- 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
- 如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.
- copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
- 举例说明：

定义一个以 strong 修饰的 array：

```
@property (nonatomic ,readwrite, strong) NSArray *array;
```
然后进行下面的操作：

```
NSArray *array = @[ @1, @2, @3, @4 ];
   NSMutableArray *mutableArray = [NSMutableArray arrayWithArray:array];
   
   self.array = mutableArray;
   [mutableArray removeAllObjects];;
   NSLog(@"%@",self.array);
   
   [mutableArray addObjectsFromArray:array];
   self.array = [mutableArray copy];
   [mutableArray removeAllObjects];;
   NSLog(@"%@",self.array);
```
打印结果如下所示：

```
2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] (
)
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (
   1,
   2,
   3,
   4
)
```
为了理解这种做法，首先要知道，两种情况：
- 对非集合类对象的 copy 与 mutableCopy 操作；
- 对集合类对象的 copy 与 mutableCopy 操作。

### 对非集合类对象的copy操作：
- 在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：

[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //深复制
[mutableObject copy] //深复制
[mutableObject mutableCopy] //深复制
比如以下代码：

```
NSMutableString *string = [NSMutableString stringWithString:@"origin"];//copy
NSString *stringCopy = [string copy];
```
查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：

```
[string appendString:@"origion!"]
```
stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，

- 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

### 集合类对象的copy与mutableCopy

集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：

```
NSArray *array = @[@[@"a", @"b"], @[@"c", @"d"]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
```
查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：

```
NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"],@"b",@"c",nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
```
查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：

在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：

```
[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制
```
这个代码结论和非集合类的非常相似。

参考链接：[iOS 集合的深复制与浅复制](https://www.zybuluo.com/MicroCai/note/50592)

### 19.如何让自己的类用copy修饰符？如何重写带 copy 关键字的 setter？
> 若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。
- 具体步骤：
    * 需声明该类遵从 NSCopying 协议
    * 实现 NSCopying 协议。该协议只有一个方法:

```
- (id)copyWithZone:(NSZone *)zone;
```
- 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。
- 以第一题的代码为例：

```
// .h文件
   // 修改完的代码

   typedef NS_ENUM(NSInteger, CYLSex) {
       CYLSexMan,
       CYLSexWoman
   };

   @interface CYLUser : NSObject<NSCopying>

   @property (nonatomic, readonly, copy) NSString *name;
   @property (nonatomic, readonly, assign) NSUInteger age;
   @property (nonatomic, readonly, assign) CYLSex sex;

   - (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
   + (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;

   @end
```
然后实现协议中规定的方法：

```
- (id)copyWithZone:(NSZone *)zone {
	CYLUser *copy = [[[self class] allocWithZone:zone] 
		             initWithName:_name
 							      age:_age
						          sex:_sex];
	return copy;
}
```
但在实际的项目中，不可能这么简单，遇到更复杂一点，比如类对象中的数据结构可能并未在初始化方法中设置好，需要另行设置。举个例子，假如 CYLUser 中含有一个数组，与其他 CYLUser 对象建立或解除朋友关系的那些方法都需要操作这个数组。那么在这种情况下，你得把这个包含朋友对象的数组也一并拷贝过来。下面列出了实现此功能所需的全部代码:

```
// .h文件
// 以第一题《风格纠错题》里的代码为例

typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};

@interface CYLUser : NSObject<NSCopying>

@property (nonatomic, readonly, copy) NSString *name;
@property (nonatomic, readonly, assign) NSUInteger age;
@property (nonatomic, readonly, assign) CYLSex sex;

- (instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
+ (instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;
- (void)addFriend:(CYLUser *)user;
- (void)removeFriend:(CYLUser *)user;

@end
```
// .m文件

```
// .m
//

@implementation CYLUser {
   NSMutableSet *_friends;
}

- (void)setName:(NSString *)name {
   _name = [name copy];
}

- (instancetype)initWithName:(NSString *)name
                        age:(NSUInteger)age
                        sex:(CYLSex)sex {
   if(self = [super init]) {
       _name = [name copy];
       _age = age;
       _sex = sex;
       _friends = [[NSMutableSet alloc] init];
   }
   return self;
}

- (void)addFriend:(CYLUser *)user {
   [_friends addObject:user];
}

- (void)removeFriend:(CYLUser *)user {
   [_friends removeObject:user];
}

- (id)copyWithZone:(NSZone *)zone {
   CYLUser *copy = [[[self class] allocWithZone:zone]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [_friends mutableCopy];
   return copy;
}

- (id)deepCopy {
   CYLUser *copy = [[[self class] alloc]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                            copyItems:YES];
   return copy;
}

@end
```
以上做法能满足基本的需求，但是也有缺陷：
> 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。

在例子中，存放朋友对象的 set 是用 “copyWithZone:” 方法来拷贝的，这种浅拷贝方式不会逐个复制 set 中的元素。若需要深拷贝的话，则可像下面这样，编写一个专供深拷贝所用的方法:

```
- (id)deepCopy {
   CYLUser *copy = [[[self class] alloc]
                    initWithName:_name
                    age:_age
                    sex:_sex];
   copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                            copyItems:YES];
   return copy;
}
```
至于***如何重写带 copy 关键字的 setter***这个问题，

如果抛开本例来回答的话，如下：

```
- (void)setName:(NSString *)name {
    //[_name release];
    _name = [name copy];
}
```
不过也有争议，有人说“苹果如果像下面这样干，是不是效率会高一些？”

```
- (void)setName:(NSString *)name {
   if (_name != name) {
       //[_name release];//MRC
       _name = [name copy];
   }
}
```
你可能会说：

之所以在这里做if判断 这个操作：是因为一个 if 可能避免一个耗时的copy，还是很划算的。 (在刚刚讲的：《如何让自己的类用 copy 修饰符？》里的那种复杂的copy，我们可以称之为 “耗时的copy”，但是对 NSString 的 copy 还称不上。)

但是你有没有考虑过代价：

你每次调用 setX: 都会做 if 判断，这会让 setX: 变慢，如果你在 setX:写了一串复杂的 if+elseif+elseif+... 判断，将会更慢。
要回答“哪个效率会高一些？”这个问题，不能脱离实际开发，就算 copy 操作十分耗时，if 判断也不见得一定会更快，除非你把一个“ @property他当前的值 ”赋给了他自己，代码看起来就像：

```
[a setX:x1];
[a setX:x1];    //你确定你要这么干？与其在setter中判断，为什么不把代码写好？
```
或者

```
[a setX:[a x]];   //队友咆哮道：你在干嘛？！！
```
不要在 setter 里进行像 if(_obj != newObj) 这样的判断。

什么情况会在 copy setter 里做 if 判断？ 例如，车速可能就有最高速的限制，车速也不可能出现负值，如果车子的最高速为300，则 setter 的方法就要改写成这样：

```
-(void)setSpeed:(int)_speed{
    if(_speed < 0) speed = 0;
    if(_speed > 300) speed = 300;
    _speed = speed;
}
```
回到这个题目，如果单单就上文的代码而言，我们不需要也不能重写 name 的 setter ：由于是 name 是只读属性，所以编译器不会为其创建对应的“设置方法”，用初始化方法设置好属性值之后，就不能再改变了。（ 在本例中，之所以还要声明属性的“内存管理语义”--copy，是因为：如果不写 copy，该类的调用者就不知道初始化方法里会拷贝这些属性，他们有可能会在调用初始化方法之前自行拷贝属性值。这种操作多余而低效）。

那如何确保 name 被 copy？在初始化方法(initializer)中做：

```
- (instancetype)initWithName:(NSString *)name 
   							 age:(NSUInteger)age 
   							 sex:(CYLSex)sex {
        if(self = [super init]) {
        	_name = [name copy];
        	_age = age;
        	_sex = sex;
        	_friends = [[NSMutableSet alloc] init];
        }
        return self;
   }
```

### 20.是否了解深拷贝和浅拷贝的概念，集合类深拷贝如何实现？
- 对不可变的非集合对象，copy是指针拷贝，mutablecopy是内容拷贝
- 对于可变的非集合对象，copy，mutablecopy都是内容拷贝
- 对不可变的数组、字典、集合等集合类对象，copy是指针拷贝，mutablecopy是内容拷贝
- 对于可变的数组、字典、集合等集合类对象，copy，mutablecopy都是内容拷贝
- 但是，对于集合对象的内容复制仅仅是对对象本身，但是对象的里面的元素还是指针复制。要想复制整个集合对象，就要用集合深复制的方法，有两种：
- 使用initWithArray:copyItems:方法，将第二个参数设置为YES即可

```
NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];
```
- 将集合对象进行归档（archive）然后解归档（unarchive）：

```
NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
```

### 21.完全深拷贝和不完全深拷贝
- 完全深拷贝:在做深拷贝的时候,我们拷贝的对象具有多层,每一层我们都需要拷贝对象,而不是简单的指针拷贝。
- 默认状态下深拷贝指的是不完全深拷贝,如要实现完全深拷贝, 则要重写copyWithZone:方法,自行实现完全深拷贝的

### 22.内存管理默认的关键字是什么？
- MRC

```
@property (atomic,readWrite,retain) UIView *view;
```
- ARC

```
@property (atomic,readWrite,strong) UIView *view;
```
- 如果改为基本数据类型，那就是 assign。

### 23.内存中的5大区分别是什么？
- 栈区：编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。
- 堆区：由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在iOS 中 alloc 都是存放在堆中。
- 全局区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。
- 文字常量区：存放常量字符串，程序结束后由系统释放程序结束释放。
- 代码区：存放函数的二进制代码

### 24.iOS程序内存的每个分区怎么存储（举例说明）
- 栈区：存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等，内存地址从高到低分配。
- 堆区：堆区的地址是从低到高分配，通过程序员通过alloc手动分配。
- 全局区：包含两个部分，未初始化区，初始化区域。全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；
- 代码区存放于低地址，栈区存放于高地址。区与区之间并不是连续的。堆区的内存是应用程序共享的，堆中的内存分配是系统负责的；当引用计数为0的时候，系统会回收该内存。

### 25.代码区存储的是什么？
- 代码区存放的是程序中函数编译后的CPU指令

### 26.什么是虚拟内存，虚拟内存和物理内存的关系和区别
- 操作系统有虚拟内存与物理内存之分
- 在虚拟内存出现之前，程序寻址用的都是物理地址，因此程序能寻址的范围是有限的，具体程序可以寻址的范围有多大取决于CPU的地址线条数。
- 比如在32位平台下，寻址的范围是2^32也就是4G，并且这是固定的，如果没有虚拟内存，且每次开启一个进程都分配出来4G的物理内存，就会出现很多问题：
    * 因为物理内存是有限的，当有多个进程要执行的时候，对每个进程都要分配4G内存，很显然你内存若小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的。
    * 由于指令都是直接访问物理内存的，那么进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的。
    * 因为内存是随机分配的，所以程序运行的地址也是不正确的。
- 为了解决上述问题，于是就出现了虚拟内存。

#### 虚拟内存原理及与物理内存的关系
- 一个进程运行时会被分配4G的虚拟内存。进程有了虚拟内存后，每个进程都认为自己拥有4G的内存空间，当然这只是每个进程认为的。但实际上，虚拟内存对应的实际物理内存，可能只对应的分配了一点点的物理内存，实际使用了多少内存，就会对应多少物理内存。
- 进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它的数据是存储在多个物理内存碎片的，还有一部分存储在外部磁盘存储器上，在需要时将数据交换进物理内存。
- 进程开始要访问一个地址，它可能会经历下面的过程
    * 进程每次要访问地址空间上的某一个地址时，都需要把地址翻译为实际物理内存地址。
    * 所有进程共享一整块物理内存，每个进程只把自己目前需要访问的虚拟地址空间映射到物理内存上。
    * 进程需要知道哪些虚拟内存地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），若在物理内存上存在，则需要进一步知道数据存储在物理内存上的具体位置，这都需要通过页表来记录。
    * 页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）。
    * 当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常。
    * 缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。

#### 总结
- 当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射关系（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去访问页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。
- 外在进程运行过程中，通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。
- 可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）

### 27.block一般存在哪里（分ARC和MRC）
- 在 MRC 下，Block 默认是分配在栈上的，除非进行显式执行的copy方法，只要block没有引用外部的局部变量，block放在全局区里面
- 在ARC的中，对象默认是用__strong修饰的，所以大部分情况下编译器都会将 block从栈自动复制到堆上。有一个特殊情况，如果仅仅定义了block没有赋值给变量的话，仍是在栈上。这种情况下随着作用域结束，block将会销毁回收。

### 28.讲一下 `iOS` 内存管理的理解？(三种方案的结合)
- OC中的内存管理主要有三种方式：ARC、MRC、自动释放池
- MRC（Mannul Reference Counting）手动引用计数
- ARC（automatic reference counting）自动引用计数
- 在5.0版本以前，OC内存管理遵循“谁创建、谁释放、谁引用、谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，其实这就是手动管理机制。
- 在5.0以后，引用自动管理机制，其实管理机制和手动管理机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。如果使用alloc、copy或者retain一个对象时，你就有义务，向它发送一条release或者autorelease消息。其他方法创建的对象，不需要由自己来管理内存
- 自动释放池：（NSAutoRealeasePool）可以通过创建和释放内存池控制内存申请和收回的时机。向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池子中每一个对象发送一条release消息，以此来释放对象。向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法，释放该对象和对象本身他所拥有的实例。
- 也就是说，iOS中对内存管理的机制（堆内存），是通过 retainCount 的机制来决定对象是否需要释放。每一个对象都有一个与之关联的retainCount， 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。

#### OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。retain引用计数+1，release反之。
例如

```
// MRC代码
NSObject * obj = [[NSObject alloc] init]; //引用计数为1

//不需要的时候
[obj release] //引用计数减1

//持有这个对象
[obj retain] //引用计数加1

//放到AutoReleasePool
[obj autorelease]//在auto release pool释放的时候，引用计数减1
```

```
// ARC代码
NSObject * obj;
{
    obj = [[NSObject alloc] init]; //引用计数为1
}
NSLog(@"%@",obj);
```
- 我们可以先来看看ratain和release内部是如何实现的。
##### retain

```
- (id)retain {
    return ((id)self)->rootRetain();
}

inline id objc_object::rootRetain()
{
    if (isTaggedPointer()) return (id)this;
    return sidetable_retain();
}
```
- 可以看出retain底层是调用了sidetable_retain()

```
id objc_object::sidetable_retain()
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];//获取引用计数表
    
    table.lock(); // 加锁
    size_t& refcntStorage = table.refcnts[this]; // 根据对象的引用计数
    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
        refcntStorage += SIDE_TABLE_RC_ONE;
    }
    table.unlock(); // 解锁

    return (id)this;
}
```
- SideTable数据结构：
- SideTable 这个结构体，我给他起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构：

```
struct SideTable {
// 保证原子操作的自旋锁
    spinlock_t slock;
    // 引用计数的 hash 表
    RefcountMap refcnts;
    // weak 引用全局 hash 表
    weak_table_t weak_table;

    // 省略...
};
```
- 通过代码可以看出，SideTable拥有一个自旋锁，一个引用计数map。这个引用计数的map以对象的地址作为key，引用计数作为value；对于 slock 和 refcnts 两个成员不用多说，第一个是为了防止竞争选择的自旋锁，第二个是协助对象的 isa 指针的 extra_rc 共同引用计数的变量。这里主要看 weak 全局 hash 表的结构与作用。

##### release

```
- (oneway void)release {
    ((id)self)->rootRelease();
}

inline bool objc_object::rootRelease()
{
    if (isTaggedPointer()) return false;
    return sidetable_release(true);
}
```

```
uintptr_t objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];

    bool do_dealloc = false;

    table.lock(); // 加锁
    RefcountMap::iterator it = table.refcnts.find(this); // 先找到对象的地址
    if (it == table.refcnts.end()) {
        do_dealloc = true; //引用计数小于阈值，最后执行dealloc
        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
    } else if (it->second < SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        do_dealloc = true;
        it->second |= SIDE_TABLE_DEALLOCATING;
    } else if (! (it->second & SIDE_TABLE_RC_PINNED)) {
        it->second -= SIDE_TABLE_RC_ONE; //引用计数减去1
    }
    table.unlock(); // 解锁
    if (do_dealloc  &&  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return do_dealloc;
}
```
- release过程：查找map，对引用计数减1，如果引用计数小于阈值，则调用SEL_dealloc

#### 关于内存管理的方案（三种方案的结合）
- 第一种方案：Tagged Pointer（标记指针）
    * 一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但像NSNumber、NSDate一类的对象所占用的内存会翻倍，进而浪费内存。为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。
    * 我们将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。
    * Tagged Pointer特点
        * Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
        * Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。
        * 在内存读取上有着3倍的效率，创建时比以前快106倍。
    * 总体来说，如果一个对象使用了Tagged Pointer技术（比如NSString，NSNumber等），指针里面会直接存数据内容，不会再作为“指针”指向其它地址，从Runtime来理解就是不会使用isa指针，也就不会继承苹果的内存管理方式（Reference Counting）。
    * 比如NSNumber，除了8位标志位外，其余56位则用来存储数值本身内容。当存储用的数值超过56位存储上限的时候，那么NSNumber才会用真正的64位内存地址存储数值，然后用指针指向该内存地址。
    * 注意：所有对象都有 isa 指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以如果你直接访问Tagged Pointer的isa成员的话，在编译时将会有如下警告：

 ![image](https://res.infoq.com/articles/deep-understanding-of-tagged-pointer/zh/resources/0519063.jpg)
 
 应该换成相应的方法调用，如 isKindOfClass 和 object_getClass。只要避免在代码中直接访问对象的isa变量，即可避免这个问题。
 * 第二种方案：isa 指针（NONPOINTER_ISA）
    - 指针的内存空间很大，有时候可以优化指针，在指针中存储一部分内容。
    - 不同架构下的64位环境中isa指针结构:

```
union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

#if SUPPORT_NONPOINTER_ISA
# if __arm64__
#   define ISA_MASK        0x00000001fffffff8ULL
#   define ISA_MAGIC_MASK  0x000003fe00000001ULL
#   define ISA_MAGIC_VALUE 0x000001a400000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000
        uintptr_t magic             : 9;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 19;
#       define RC_ONE   (1ULL<<45)
#       define RC_HALF  (1ULL<<18)
    };

# elif __x86_64__
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x0000000000000001ULL
#   define ISA_MAGIC_VALUE 0x0000000000000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 14;
#       define RC_ONE   (1ULL<<50)
#       define RC_HALF  (1ULL<<13)
    };

# else
    // Available bits in isa field are architecture-specific.
#   error unknown architecture
# endif

// SUPPORT_NONPOINTER_ISA
#endif

};
```
- 只有arm64架构的设备支持优化，下面列出了isa指针中变量对应的含义:
 
变量名 | 含义
---|---
indexed | 0 表示普通的isa指针，1 表示使用优化，存储引用计数
has_assoc | 表示该对象是否包含 associated object，如果没有，则析构时会更快
has_cxx_dtor | 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快
shiftcls | 类的指针
magic | 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化
weakly_referenced | 表示该对象是否有过weak对象，如果没有，则析构时更快
deallocating | 表示该对象是否正在析构
has_sidetable_rc | 表示该对象的引用计数值是否过大无法存储在isa指针
extra_rc | 存储引用计数值减一后的结果 

- 第三种方案：散列表
    * 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
    * 散列表就是把Key通过一个固定的算法函数既所谓的散列函数转换成一个整型数字即散列值，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。而当使用散列表进行查询的时候，就是再次使用散列函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。
    * 哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。
    * 散列表来存储引用计数具体是用DenseMap类来实现，实现中有锁保证其安全性。
    * DenseMap类中包含好多映射实例到其引用计数的键值对，并支持用 DenseMapIterator 迭代器快速查找遍历这些键值对。
    * 引用计数表、weak表都是散列表；

### 补充：对象引用计数放哪里？
- 采用散列表（引用计数表）来管理引用计数。

![image](http://upload-images.jianshu.io/upload_images/131615-d1212b1150b575e7.png)

- GNUstep将引用计数保存在对象占用内存块头部的变量中，而苹果的实现，则是保存在引用计数表的记录中。
- 通过内存卡头部管理引用计数的好处如下：
    * 少量代码即可完成
    * 能够统一管理引用计数用内存块与对象用内存块
- 通过引用计数表管理引用计数的好处如下：
    * 对象用内存块的分配无需考虑内存块头部
    * 引用计数表各记录中存有内存块地址，可从各个记录中追溯到各对象的内存块
- 即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置

### 29.使用自动引用计（ARC）数应该遵循的原则?
- ARC规则：
    * 不能使用retain/release/retainCount/autorelease
    * 不能使用NSAllocateObject/NSDeallocateObject
    * 必须遵守内存管理的方法命名规则
    * 不要显式调用dealloc
    * 使用@autoreleasepool块替代NSAutoreleasePool
    * 不能使用区域NSZone
    * 对象型变量不能作为c语言结构体的成员
    * 显式转换id和void*

### 30.ARC 自动内存管理的原则?
- 自己生成的对象，自己持有
- 非自己生成的对象，自己可以持有
- 自己持有的对象不再需要时，需要对其进行释放
- 非自己持有的对象无法释放

### 31.ARC 的 retainCount 怎么存储的？
- 采用散列表（引用计数表）来管理引用计数。

![image](http://upload-images.jianshu.io/upload_images/131615-d1212b1150b575e7.png)

- GNUstep将引用计数保存在对象占用内存块头部的变量中，而苹果的实现，则是保存在引用计数表的记录中。
- 通过内存卡头部管理引用计数的好处如下：
    * 少量代码即可完成
    * 能够统一管理引用计数用内存块与对象用内存块
- 通过引用计数表管理引用计数的好处如下：
    * 对象用内存块的分配无需考虑内存块头部
    * 引用计数表各记录中存有内存块地址，可从各个记录中追溯到各对象的内存块
- 即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置

### 32.ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？
- 对应基本数据类型默认关键字是 atomic,readwrite,assign
- 对于普通的 Objective-C 对象 atomic,readwrite,strong

### 33.ARC通过什么方式帮助开发者管理内存？
- 采用散列表（引用计数表）来管理引用计数。

![image](http://upload-images.jianshu.io/upload_images/131615-d1212b1150b575e7.png)

- GNUstep将引用计数保存在对象占用内存块头部的变量中，而苹果的实现，则是保存在引用计数表的记录中。
- 通过内存卡头部管理引用计数的好处如下：
    * 少量代码即可完成
    * 能够统一管理引用计数用内存块与对象用内存块
- 通过引用计数表管理引用计数的好处如下：
    * 对象用内存块的分配无需考虑内存块头部
    * 引用计数表各记录中存有内存块地址，可从各个记录中追溯到各对象的内存块
- 即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置

### 34.ARC 在编译时做了哪些工作？
- 主要是指 weak 关键字。weak 修饰的变量能够在引用计数为0 时被自动设置成 nil，显然是有运行时逻辑在工作的。
- 为了保证向后兼容性，ARC 在运行时检测到类函数中的 autorelease 后紧跟其后 retain，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。
objc_autoreleaseReturnValue会检视当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain ，而是改为执行 objc_retainAoutoreleasedReturnValue函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和retain更快。

### 35.ARC 在运行时做了哪些工作？
- 根据代码执行的上下文语境，在适当的位置插入 retain，release

### 36.简要说一下 @autoreleasePool 的数据结构？
- 简单说是双向链表，每张链表头尾相接，有parent、child指针
- 每创建一个池子，会在首部创建一个哨兵对象,作为标记
- 最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。

### 37.@autoreleasrPool 的释放时机？
- App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。
- 第一个 Observer监视的事件是Entry(即将进入Loop)，其回调内会调用_objc_autoreleasePoolPush()创建自动释放池。其 order是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。
- 第二个 Observer监视了两个事件：BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和_objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将退出Loop)时调用_objc_autoreleasePoolPop() 来释放自动释放池。这个Observer的order是2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。
- 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。
- 在子线程autoreleasePool的释放
    * 子线程执行完任务被释放
    * 当pthread_exit退出时，触发了_pthread_tsd_cleanup，触发AutoreleasePoolPage的tls_dealloc(void*)，然后回收autorelease对象

### 38.为什么已经有了 ARC ,但还是需要 @AutoreleasePool 的存在？
- 避免内存峰值，及时释放不需要的内存空间

### 39.函数返回一个对象时，会对对象 autorelease 么？为什么？
- 会 ，为了延长返回对象的生命周期，给其他使用者留足调用的时间

### 40.realease作用是什么和 autorelease 有什么区别？
- realease释放对象，防止内存泄漏；
- 如果插入，该函数若用weak指针持有函数返回值，马上会将其置为nil；为了解决这个问题，用Autorelease，就是用autorelease来代替release，将要释放的对象先放入一个“释放池”，而不是马上释放。

### 41.不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）
- 分两种情况：手动干预释放时机、系统自动去释放。
    * 手动干预释放时机—指定autoreleasepool 就是所谓的：当前作用域大括号结束时释放。
    * 系统自动去释放—不手动指定autoreleasepool
- Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。

![image](https://upload-images.jianshu.io/upload_images/1682758-4dd920572b80f29d?imageMogr2/auto-orient/strip|imageView2/2/w/730)

- 从程序启动到加载完成是一个完整的运行循环，然后会停下来，等待用户交互，用户的每一次交互都会启动一次运行循环，来处理用户所有的点击事件、触摸事件。
- 我们都知道： 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。但是如果每次都放进应用程序的 main.m 中的 autoreleasepool 中，迟早有被撑满的一刻。这个过程中必定有一个释放的动作。何时？在一次完整的运行循环结束之前，会被销毁。那什么时间会创建自动释放池？运行循环检测到事件并启动后，就会创建自动释放池。
- 如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。
- 自定义的 NSOperation 和 NSThread 需要手动创建自动释放池。比如： 自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则出了作用域后，自动释放对象会因为没有自动释放池去处理它，而造成内存泄露。
- 但对于 blockOperation 和 invocationOperation 这种默认的Operation ，系统已经帮我们封装好了，不需要手动创建自动释放池。
- @autoreleasepool 当自动释放池被销毁或者耗尽时，会向自动释放池中的所有对象发送 release 消息，释放自动释放池中的所有对象。

### 42.访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？
- 在访问__weak修饰的变量时，必定要访问注册到autoreleasepool的对象，这是因为：__weak修饰符只持有对象的弱引用，他不能持有对象实例，所以在超出其变量作用域时，对象即被释放。 而在访问引用对象的过程中，该对象可能被废弃，而如果把要访问的对象注册到autoreleasepool中，在@autoreleasepool块结束之前都能确保该对象存在。

### 43.在OC里 alloc 和 retain 语义相反的方法是？
- OC 使用了一种叫做引用计数的机制来管理对象，如果对一个对象使用了alloc、[Mutable]copy，retain，那么你必须使用相应的realease或者autorelease。也可以理解为自己生成的对象，自己持有。非自己生成的对象，自己也能持有。不在需要自己持有的对象时释放。非自己持有的对象无法释放。生成并持有对象<alloc,new,copy,mutableCopy 等>，持有对象<retain>，释放对象
<release>,废弃对象<dealloc>。

### 44.retain、release 的实现机制？
- Retain的实现机制。

```
SideTable& table = SideTables()[This];

size_t& refcntStorage = table.refcnts[This];

refcntStorage += SIZE_TABLE_RC_ONE;
```
- Release的实现机制。

```
SideTable& table = SideTables()[This];

size_t& refcntStorage = table.refcnts[This];

refcntStorage -= SIZE_TABLE_RC_ONE;
```
- 二者的实现机制类似，概括讲就是通过第一层 hash 算法，找到 指针变量 所对应的 sideTable。然后再通过一层 hash 算法，找到存储 引用计数 的 size_t，然后对其进行增减操作。retainCount 不是固定的 1，SIZE_TABLE_RC_ONE 是一个宏定义，实际上是一个值为 4 的偏移量。

### 45.能不能简述一下 Dealloc 的实现机制？
- Dealloc 调用流程
    * 首先调用 _objc_rootDealloc()
    * 接下来调用 rootDealloc()
    * 这时候会判断是否可以被释放，判断的依据主要有5个，判断是否有以上五种情况
        * NONPointer_ISA
        * weakly_reference
        * has_cxx_dtor
        * has_sidetable_rc
    * 如果有以上五中任意一种，将会调用 object_dispose()方法，做下一步的处理。
    * 如果没有之前五种情况的任意一种，则可以执行释放操作，C函数的 free()。
    * 执行完毕。
- object_dispose() 调用流程。
    * 直接调用 objc_destructInstance()。
    * 之后调用 C函数的 free()。
- objc_destructInstance() 调用流程
    * 先判断 hasCxxDtor，如果有 C++ 的相关内容，要调用 object_cxxDestruct() ，销毁 C++ 相关的内容。
    * 再判断 hasAssocitatedObjects，如果有的话，要调用 object_remove_associations()，销毁关联对象的一系列操作。
    * 然后调用 clearDeallocating()。
    * 执行完毕。
- clearDeallocating() 调用流程
    * 先执行 sideTable_clearDellocating()。
    * 再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。
    * 接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。
    * 至此为止，Dealloc 的执行流程结束。

### 46.在 MRC 下如何重写属性的 Setter 和 Getter?
- setter

```
-(void)setBrand:(NSString *)brand{
//如果实例变量指向的地址和参数指向的地址不同
    if (_brand != brand)
    {
        //将实例变量的引用计数减一
        [_brand release];
       //将参数变量的引用计数加一,并赋值给实例变量
        _brand = [brand retain];
    }
}
```
- getter

```
-(NSString *)brand{
    //将实例变量的引用计数加1后,添加自动减1
    //作用,保证调用getter方法取值时可以取到值的同时在完全不需要使用后释放
    return [[_brand retain] autorelease];
}
```
- 重写dealloc

```
//MRC下 手动释放内存 可重写dealloc但不要调用dealloc  会崩溃
-(void)dealloc{
    [_string release];
    //必须最后调用super dealloc
    [super  dealloc];
}
```

### 47.讲一下 @dynamic 关键字？
- @dynamic 意味着编译器不会帮助我们自动合成 setter 和 getter 方法。我们需要手动实现

### 48.@synthesize和@dynamic分别有什么作用？
- @property有两个对应的词，一个是@synthesize，一个是 @dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;
- @synthesize 的语义是如果你没有手动实现 setter 方法和 getter方法，那么编译器会自动为你加上这两个方法。
- @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供getter即可）。假如一个属性被声明为 @dynamic var，然后你没有提供@setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

### 49.@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？
在回答之前先说明下一个概念：

实例变量 = 成员变量 ＝ ivar
这些说法，笔者下文中，可能都会用到，指的是一个东西。

正如 Apple官方文档 You Can Customize Synthesized Instance Variable Names 所说：

![image](https://camo.githubusercontent.com/d562010accc0b123c355d48d56b4eb426b032641/687474703a2f2f692e696d6775722e636f6d2f443664307a474a2e706e67)

如果使用了属性的话，那么编译器就会自动编写访问属性所需的方法，此过程叫做“自动合成”( auto synthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法” (synthesized method)的源代码。除了生成方法代码之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。

```
@interface CYLPerson : NSObject 
@property NSString *firstName; 
@property NSString *lastName; 
@end
```
在上例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字:

```
@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
```
上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName ，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。

- 总结下 @synthesize 合成实例变量的规则，有以下几点：
    * 如果指定了成员变量的名称,会生成一个指定的名称的成员变量,
    * 如果这个成员已经存在了就不再生成了.
    * 如果是 @synthesize foo;              * 还会生成一个名称为foo的成员变量，也就是说：
        * 如果没有指定成员变量的名称会自动生成一个属性同名的成员变量,
    * 如果是 @synthesize foo = _foo; 就不会生成成员变量了.
假如 property 名为 foo，存在一个名为 _foo 的实例变量，那么还会自动合成新变量么？ 不会。如下图：

![image](https://camo.githubusercontent.com/8e11101c9fe0b3defc7fbd144c0dca9fdf0471d0/687474703a2f2f692e696d6775722e636f6d2f743238676534572e706e67)

### 50.在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？
- 回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？
    * 同时重写了 setter 和 getter 时
    * 重写了只读属性的 getter 时
    * 使用了 @dynamic 时
    * 在 @protocol 中定义的所有属性
    * 在 category 中定义的所有属性
    * 重载的属性
- 当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。
- 除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 @dynamic 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。
- 因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 @synthesize 来手动合成 ivar。
- 其实，@synthesize 语法还有一个应用场景，但是不太建议大家使用：
可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字:

```
@implementation CYLPerson 
@synthesize firstName = _myFirstName; 
@synthesize lastName = _myLastName; 
@end 
```
上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。

举例说明：应用场景：

```
//
// .m文件

// 打开第14行和第17行中任意一行，就可编译成功

@import Foundation;

@interface CYLObject : NSObject
@property (nonatomic, copy) NSString *title;
@end

@implementation CYLObject {
   //    NSString *_title;
}

//@synthesize title = _title;

- (instancetype)init
{
   self = [super init];
   if (self) {
       _title = @"微博@iOS程序犭袁";
   }
   return self;
}

- (NSString *)title {
   return _title;
}

- (void)setTitle:(NSString *)title {
   _title = [title copy];
}

@end
```
结果编译器报错：

![image](https://camo.githubusercontent.com/a569a90281598d8cc74156fe5f0e3a6ddbf8fc6b/687474703a2f2f692e696d6775722e636f6d2f6641454748496f2e706e67)

- 当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择：
    * 要么如第14行：手动创建 ivar
    * 要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。

### 补充：说 @synchronized 锁的实现原理，并说明其中可能存在的问题。

### 51.说一下什么是 悬垂指针？什么是 野指针?
- 悬垂指针：指针指向的内存已经被释放了，但是指针还存在，这就是一个 悬垂指针 或者说 迷途指针
- 野指针：没有进行初始化的指针，其实都是 野指针

### 52.objc中向一个nil对象发送消息将会发生什么？
- 在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:
- 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：

```
Person * motherInlaw = [[aPerson spouse] mother];
```
- 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 
- 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 
- 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 
- 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。

具体原因如下：
> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。

具体分析：

```
// runtime.h（类在runtime中的定义）

struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !__OBJC2__
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char *name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
```
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。

### 53.objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？
- objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
- 也就是该方法编译之后就是objc_msgSend()函数调用.
- 我们用 clang 分析下，clang 提供一个命令，可以将Objective-C的源码改写成C++语言，借此可以研究下[obj foo]和objc_msgSend()函数之间有什么关系。

以下面的代码为例，由于 clang 后的代码达到了10万多行，为了便于区分，添加了一个叫 iOSinit 方法，

```
//
//  main.m
//

#import "CYLTest.h"

int main(int argc, char * argv[]) {
    @autoreleasepool {
        CYLTest *test = [[CYLTest alloc] init];
        [test performSelector:(@selector(iOSinit))];
        return 0;
    }
}
```
在终端中输入

```
clang -rewrite-objc main.m
```
就可以生成一个main.cpp的文件，在最低端（10万4千行左右）

![image](https://camo.githubusercontent.com/bf346edc21ab4b3387906602249b357d250ab1c2/687474703a2f2f692e696d6775722e636f6d2f6541483559576e2e706e67)

我们可以看到大概是这样的：

```
((void ()(id, SEL))(void )objc_msgSend)((id)obj, sel_registerName("foo"));
```
也就是说：
- [obj foo];在objc编译时，会被转意为：objc_msgSend(obj, @selector(foo));。

### 54.BAD_ACCESS 在什么情况下出现?
 访问了已经被销毁的内存空间，就会报出这个错误。
根本原因是有 悬垂指针 没有被释放。

### 55.什么时候会报unrecognized selector的异常？
- 简单来说：
    * 当调用该对象上某个方法,而该对象上没有实现这个方法的时候， 
- 可以通过“消息转发”进行解决。
- 由于，objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。
- objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：
    * Method resolution
        * objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。
    * Fast forwarding
        * 如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点。
    * Normal forwarding
        * 这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。

### 56.objc使用什么机制管理对象内存？
- 通过 retainCount 的机制来决定对象是否需要释放。 每次 runloop 的时候，都会检查对象的retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了。

### 57.一个objc对象如何进行内存布局？（考虑有父类的情况）
- 所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中.
- 每一个对象内部都有一个isa指针,指向他的类对象,类对象中存放着本对象的
    * 对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）
    * 成员变量的列表,
    * 属性列表,
- 它内部也有一个isa指针指向元对象(meta class),元对象内部存放的是类方法列表,类对象内部还有一个superclass的指针,指向他的父类对象。

每个 Objective-C 对象都有相同的结构，如下图所示：

![image](https://camo.githubusercontent.com/f446a82030de175ad18c7af85f097e1eea3fe496/687474703a2f2f692e696d6775722e636f6d2f376d4a6c556a312e706e67)

翻译过来!

|  Objective-C 对象的结构图 | 
 ------------- |
 ISA指针 |
 根类的实例变量 |
 倒数第二层父类的实例变量 |
 ... |
 父类的实例变量 |
 类的实例变量 | 

- 根对象就是NSObject，它的superclass指针指向nil
- 类对象既然称为对象，那它也是一个实例。类对象中也有一个isa指针指向它的元类(meta class)，即类对象是元类的实例。元类内部存放的是类方法列表，根元类的isa指针指向自己，superclass指针指向NSObject类。

如图: 

![image](http://hi.csdn.net/attachment/201201/19/0_1326963670oeC1.gif)

### 58.一个objc对象的isa的指针指向什么？有什么作用？
- isa指针是什么？
    * 我们经常使用id来声明一个对象，本质上，我们创建的一个对象或实例其实就是一个struct objc_object结构体，而我们常用的id也就是这个结构体的指针。这个结构体只有一个成员变量，这是一个Class类型的变量isa，也是一个结构体									指针。面向对象中每一个对象都必须依赖一个类来创建，因此对象的isa指针就指向对象所属的类根据这个类模板能够创建出实例变量、实例方法等。
- 对象的isa指针
    * 每个实例对象有个isa的指针,他指向对象的类
- 类对象的isa指针
    * Class里也有个isa的指针, 指向meteClass(元类)。
- 元类的isa指针
    * 元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。

![image](http://hi.csdn.net/attachment/201201/19/0_1326963670oeC1.gif)

参考文献：
- [《iOS class深入理解： 实例对象、类对象、元类和isa指针》](http://www.zhimengzhe.com/IOSkaifa/253119.html)
- [《iOS中isa指针》](https://blog.csdn.net/miao_em/article/details/56671616)

### 59.能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
 不能向编译后得到的类中增加实例变量；
- 能向运行时创建的类中添加实例变量；
解释下：
- 原因：
    * 因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；
    * 运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。

### 60.在Obj-C中，如何检测内存泄漏？你知道哪些方式
- 目前我知道的方式有以下几种
    * Memory Leaks
    * Alloctions
    * Analyse
    * Debug Memory Graph
    * MLeaksFinder
- 泄露的内存主要有以下两种：
    * Laek Memory 这种是忘记 Release 操作所泄露的内存。
    * Abandon Memory 这种是循环引用，无法释放掉的内存。

## Runtime
### 1.实例对象的数据结构？
```
struct objc_object {
    isa_t isa;
    //...
}
```
- 本质上 objc_object 的私有属性只有一个 isa 指针。指向 类对象 的内存地址。

### 2.类对象的数据结构？
- 类对象就是 objc_class。

```
struct objc_class : objc_object {
    // Class ISA;
    Class superclass; //父类指针
    cache_t cache;             // formerly cache pointer and vtable 方法缓存
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags 用于获取地址

    class_rw_t *data() { 
        return bits.data(); // &FAST_DATA_MASK 获取地址值
    }
```
- 它的结构相对丰富一些。继承自objc_object结构体，所以包含isa指针
    * isa：指向元类
    * superClass: 指向父类
    * Cache: 方法的缓存列表
    * data: 顾名思义，就是数据。是一个被封装好的 class_rw_t 。

### 3.元类对象的数据结构?
- 元类对象和类对象的数据结构是一样的
- 类对象就是 objc_class。

```
struct objc_class : objc_object {
    // Class ISA;
    Class superclass; //父类指针
    cache_t cache;             // formerly cache pointer and vtable 方法缓存
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags 用于获取地址

    class_rw_t *data() { 
        return bits.data(); // &FAST_DATA_MASK 获取地址值
    }
```
- 它的结构相对丰富一些。继承自objc_object结构体，所以包含isa指针
    * isa：指向元类
    * superClass: 指向父类
    * Cache: 方法的缓存列表
    * data: 顾名思义，就是数据。是一个被封装好的 class_rw_t 。

### 4.Obj-C 对象、类的本质是通过什么数据结构实现的？
- 可以看到NSObject_IMPL内部的isa是指向struct objc_class，说明isa是一个指针，在64位系统中该对象占用8个字节，但是实际分配了16个字节。我们需要用到下面两个函数

### 5.类方法和实例方法有什么区别？
- 类方法：
    * 类方法是属于类对象的
    * 类方法只能通过类对象调用
    * 类方法中的self是类对象
    * 类方法可以调用其他的类方法
    * 类方法中不能访问成员变量
    * 类方法中不能直接调用对象方法
- 实例方法：
    * 实例方法是属于实例对象的
    * 实例方法只能通过实例对象调用
    * 实例方法中的self是实例对象
    * 实例方法中可以访问成员变量
    * 实例方法中直接调用实例方法
    * 实例方法中也可以调用类方法(通过类名)

### 6.Obj-C 中的类信息存放在哪里？
- 存放在类对象里面
- 实例对象在内存中存储的信息，主要包括：
    * isa指针
    * 其他成员变量(具体的值的信息等)
- 类对象在内存中存储的信息，主要包括：
    * isa指针
    * superclass指针
    * 类的成员变量信息（ivar）（变量名称之类）
    * 类的属性信息（@property）
    * 类的协议信息（protocol）
    * 类的对象方法信息（instance method）
- 元类对象和类对象的内存结构是一样的，但是用途不一样，在内存中存储的信息，主要包括：
    * isa指针
    * superclass指针
    * 类的类方法信息（class method）

### 7.一个 NSObject 对象占用多少内存空间？
- 受限于内存分配的机制，一个 NSObject对象都会分配 16byte 的内存空间。
- 但是实际上在 64位 下，只使用了 8byte;
- 在32位下，只使用了 4byte
- 一个 NSObject 实例对象成员变量所占的大小，实际上是 8 字节

```
#import <Objc/Runtime>
Class_getInstanceSize([NSObject Class])
```
- 本质是

```
size_t class_getInstanceSize(Class cls)
{
    if (!cls) return 0;
    return cls->alignedInstanceSize();
}
```
- 获取 Obj-C 指针所指向的内存的大小，实际上是16 字节

```
#import <malloc/malloc.h>
malloc_size((__bridge const void *)obj); 
```
- 对象在分配内存空间时，会进行内存对齐，所以在 iOS 中，分配内存空间都是 16字节 的倍数。

### 补充：如何计算一个结构体所占内存空间大小

![image](https://upload-images.jianshu.io/upload_images/4164767-5ff7b347b7f39c20.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/828)

- 例1：

```
struct WStruct {
    double a;//8
    int b;//4
    char c;//1
    short d;//2
}WStruct1;
```
- 这样我们计算出WStruct1结构体所占用的内存应该为15字节
- 因为系统自动做了内存对齐，内存对齐的规则：
    * 数据成员对⻬规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小(只要该成员有子成员，比如说是数组，结构体等)的整数倍开始（比如int为4字节,则要从4的整数倍地址开始存储）。
    * 结构体作为成员：如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)
    * 收尾工作：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补⻬
- 我们假设从位置0开始存储，double占用8个字节，所以占用0-7位置的内存空间，由于0-7已经被double占用，在存储int的时候至少要从8号位置开始，我们知道int占用4个字节，8正好是4的整数倍所以int占用8-11的内存空间，接下来存储char，char占用1个字节，所以直接放在12内存地址，short占用2个字节的内存，但是开始存储的位置13并不是2的整数倍，所以我们需要将short的存储位置后移一个字节，从14开始存储，占用14-15内存空间，通过这种方式，WStruct1结构体就会占用16个字节的内存空间。
- 例子2

```
struct WStruct2 {
    double a;
    char b;
    int c;
    short d;
    struct WStruct e;
}WStruct2;
```
- 我们假设从位置0开始存储，double占用8个字节，所以占用0-7位置的内存空间，由于0-7已经被double占用，在存储char的时候至少要从8号位置开始，我们知道char占用1个字节，然后开始储存int类型，是从9开始，但是9不是4的倍数，需要加3，是从12开始存储，int是4个字节，就到15位置，开始存储short，short是占2个字节，所以占用16，17位置，然后再储存WStruct结构体，第一个是double类型，占用8个字节，因为18不是8的倍数，所以需要加到23的位置，从24开始储存，然后用24加16是40，所以是占用40个字节；

### 8.说一下对 class_rw_t 的理解？
- rw代表可读可写。
- ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中：

```
// 可读可写
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro; // 指向只读的结构体,存放类初始信息

    /*
     这三个都是二位数组，是可读可写的，包含了类的初始内容、分类的内容。
     methods中，存储 method_list_t ----> method_t
     二维数组，method_list_t --> method_t
     这三个二位数组中的数据有一部分是从class_ro_t中合并过来的。
     */
    method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法）
    property_array_t properties; // 属性列表
    protocol_array_t protocols; //协议列表

    Class firstSubclass;
    Class nextSiblingClass;
    
    //...
    }
```

### 9.说一下对 class_ro_t 的理解？
- 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。

```
struct class_ro_t {  
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
};
```
- baseMethodList，baseProtocols，ivars，baseProperties三个都是以为数组。

### 10.介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？
- Category (分类、类别) 分类只能增加方法不能增加成员变量,可以声明属性,实际上会生成属性的set和get方法,但不会生成带下划线的成员变量,也不能添加成员变量（可以在不修改原来类模型的基础上拓充方法）
- 作用：
    * 可以在不修改原来类的基础上，为一个类扩展方法。
    * 将类的实现分散到多个不同文件或多个不同框架中。
    * 创建对私有方法的前向引用。
    * 向对象添加非正式协议。
- 最主要的用法：给系统自带的类扩展方法。
- 分类中可以访问原来类中的成员变量，但是只能访问@protect和@public形式的变量。如果想要访问本类中的私有变量，分类和子类一样，只能通过方法来访问。
- 如果一定要在分类中添加成员变量，可以通过getter，setter手段进行添加
- 声明：@interface 类名(分类名称) @end
- 实现：@implementation 类名(分类名称) @end
- 注意:
    * 在分类只能增加方法,不能增加成员变量，如果要增加成员变量的话该考虑用继承去实现
    * 在分类实现方法中可以访问类中的成员变量但是不能访问类中的属性@property
    * 在分类中可以重新实现原类中的方法，但会将原类中的方法覆盖而失效。
    * 如果一个类有多个分类，而且分类中有同名的方法那么最后编译的分类会将前面编译的分类覆盖而执行输出

```
struct _category_t {
    const char *name;//类名
    struct _class_t *cls;//类
    const struct _method_list_t *instance_methods;//category中所有给类添加的实例方法的列表（instanceMethods）
    const struct _method_list_t *class_methods;//category中所有添加的类方法的列表（classMethods）
    const struct _protocol_list_t *protocols;//category实现的所有协议的列表（protocols）
    const struct _prop_list_t *properties;//category中添加的所有属性（instanceProperties）
};

struct category_t {
    const char *name; // 类名
    classref_t cls;   // 分类所属的类
    struct method_list_t *instanceMethods;  // 实例方法列表
    struct method_list_t *classMethods;     // 类方法列表
    struct protocol_list_t *protocols;      // 遵循的协议列表
    struct property_list_t *instanceProperties; // 属性列表

    // 如果是元类，就返回类方法列表；否则返回实例方法列表
    method_list_t *methodsForMeta(bool isMeta) {
        if (isMeta) {
            return classMethods;
        } else {
            return instanceMethods;
        }
    }

    // 如果是元类，就返回 nil，因为元类没有属性；否则返回实例属性列表，但是...实例属性
    property_list_t *propertiesForMeta(bool isMeta) {
        if (isMeta) {
            return nil; // classProperties;
        } else {
            return instanceProperties;
        }
    }
};
```
- 它为什么会覆盖掉原来的方法
- 我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法

### 11.Category 的实现原理？
- 被添加在了 class_rw_t 的对应结构里。
- Category 实际上是 Category_t 的结构体，在运行时，新添加的方法，都被以倒序插入到原有方法列表的最前面，所以不同的Category，添加了同一个方法，执行的实际上是最后一个。
- 拿方法列表举例，实际上是一个二维的数组。
- Category 如果翻看源码的话就会知道实际上是一个 _catrgory_t 的结构体。
- 例如我们在程序中写了一个 Nsobject+Tools 的分类，那么被编译为 C++ 之后，实际上是：

```
static struct _catrgory_t _OBJC_$_CATEGORY_NSObject_$_Tools __attribute__ ((used,section),("__DATA,__objc__const"))
{
    // name
    // class
    // instance method list
    // class method list
    // protocol list
    // properties
}
```
- Category 在刚刚编译完的时候，和原来的类是分开的，只有在程序运行起来后，通过 Runtime ，Category 和原来的类才会合并到一起。
- mememove，memcpy：这俩方法是位移、复制，简单理解就是原有的方法移动到最后，根根新开辟的控件，把前面的位置留给分类，然后分类中的方法，按照倒序依次插入，可以得出的结论就就是，越晚参与编译的分类，里面的方法才是生效的那个。

### 12.如何给 Category 添加属性？关联对象以什么形式进行存储？
- 关联对象 以哈希表的格式，存储在一个全局的单例中。

```
@interface NSObject (Extension)

@property (nonatomic,copy  ) NSString *name;

@end


@implementation NSObject (Extension)

- (void)setName:(NSString *)name {
    
    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);
}


- (NSString *)name {
    
    return objc_getAssociatedObject(self,@selector(name));
}

@end
```

### 13.Category 有哪些用途？
- 给一个类添加新的方法，可以为系统的类扩展功能。
- 给系统类添加方法、属性（需要关联对象）。
- 对某个类大量的方法，可以实现按照不同的名称归类。

### 14.Category 中都可以添加哪些内容？
- 实例方法、类方法、协议、属性（只生成 setter 和 getter 方法的声明，不会生成 setter 和 getter 方法的实现以及下划线成员变量）；
- 默认情况下，由于分类底层结构的限制，不能添加成员变量到分类中，但可以通过关联对象来间接实现这种效果。

### 15.Category的优缺点
- 优点：
    * 可以按需加载不同的分类。
    * 有很多用途，见上面
- 缺点：
    * 不能直接添加成员变量，但可以通过关联对象实现这种效果；
    * 分类方法会“覆盖”同名的宿主类方法，如果使用不当会造成问题。
- 特点：
    * 运行时决议
    * 可以有声明，可以有实现
    * 可以为系统的类添加分类
    * 运行时决议：Category编译之后的底层结构时struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息，这时候分类中的数据还没有合并到类中，而是在程序运行的时候通过Runtime机制将所有分类数据合并到类（类对象、元类对象）中去。（这是分类最大的特点，也是分类和扩展的最大区别，扩展是在编译的时候就将所有数据都合并到类中去了）
- 注意点：
    * 分类方法会“覆盖”同名的宿主类方法，如果使用不当会造成问题；
    * 同名分类方法谁能生效取决于编译顺序，最后参与编译的分类中的同名方法会最终生效；
    * 名字相同的分类会引起编译报错。

### 16.Category 和 Extension 有什么区别？
- extension 在编译期决定，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement 一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如 NSString 添加 extension。
- 但是 category则完全不一样，它是在运行期决定的。就 category 和extension的区别来看，我们可以推导出一个明显的事实，extension 可以添加实例变量，而 category 是无法添加实例变量的
- category 的加载是发生在运行时，加载 category 的过程：
    * 把 category 的实例方法、协议以及属性添加到类上。
    * 把 category 的类方法和协议添加到类的 metaclass 上。
- 其中需要注意的是：
    * category 的方法没有「完全替换掉」原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么 category 附加完成之后，类的方法列表里会有两个 methodA。
    * category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category 的方法会「覆盖」掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会返回
- 在类和 category中都可以有+load方法，那么有两个问题：
    * 在类的 +load方法调用的时候，我们可以调用 category 中声明的方法么？答案是：可以调用，因为附加 category 到类的工作会先于 +load方法的执行。
    * 这么些个+load方法，调用顺序是咋样的呢？答案是：+load的执行顺序是先类，后 category，而 category 的+load 执行顺序是根据编译顺序决定的。虽然对于 +load的执行顺序是这样，但是对于「覆盖」掉的方法，则会先找到最后一个编译的 category 里的对应方法。
- 上面讲到的方法覆盖，还有一个补充问题：怎么调用到原来类中被 category 覆盖掉的方法？对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是 category 在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：

```
    // 假设被覆盖的方法名叫 printName。
    Class currentClass = [MyClass class];
    MyClass *my = [[MyClass alloc] init];

    if (currentClass) {
        unsigned int methodCount;
        Method *methodList = class_copyMethodList(currentClass, &methodCount);
        IMP lastImp = NULL;
        SEL lastSel = NULL;
        for (NSInteger i = 0; i < methodCount; i++) {
            Method method = methodList[i];
            NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding];
            if ([@"printName" isEqualToString:methodName]) {
                lastImp = method_getImplementation(method);
                lastSel = method_getName(method);
            }
        }
        typedef void (*fn)(id,SEL);

        if (lastImp != NULL) {
            fn f = (fn) lastImp;
            f(my, lastSel);
        }
        free(methodList);
    }
```

### 17.Category 可不可以添加实例对象？为什么？
- Category可以动态添加属性，但是不能直接添加实例变量。
- 原因：
    * 分类没有自己的isa指针.“类最开始生成了很多基本属性，比如IvarList，MethodList。分类只会将自己的method attach到主类，并不会影响到主类的IvarList。这就是为什么分类里面不能增加成员变量的原因”，实例变量没有setter和getter方法。也没有自己的isa指针。所以，就算系统不报错也不能用。
- runtime给Category动态添加属性，也就是关联对象

### 18.Category不能添加实例变量，那为什么能添加属性？
- 在分类转化为c++文件中可以看出_category_t结构体中，存放着类名，对象方法列表，类方法列表，协议列表，以及属性列表。

```
struct _category_t {
    const char *name;  //哪个类的分类 LSPerson
    struct _class_t *cls; //这个值没用到传的为0，要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象
    const struct _method_list_t *instance_methods;//对象方法列表，这个category所有的-方法
    const struct _method_list_t *class_methods;//类方法列表，这个category所有的+方法
    const struct _protocol_list_t *protocols;//协议列表，这个category实现的protocol，比较不常用在category里面实现协议，但是确实支持的
    const struct _prop_list_t *properties;//属性列表，这个category所有的property，这也是category里面可以定义属性的原因，不过这个property不会@synthesize实例变量，一般有需求添加实例变量属性时会采用objc_setAssociatedObject和objc_getAssociatedObject方法绑定方法绑定，不过这种方法生成的与一个普通的实例变量完全是两码事。
};
```

### 19.Category 在编译过后，是在什么时机与原有的类合并到一起的？
- 程序启动后，通过编译之后，Runtime 会进行初始化，调用 _objc_init。
- 然后会 map_images。
- 接下来调用 map_images_nolock。
- 再然后就是 read_images，这个方法会读取所有的类的相关信息。
- 最后是调用 reMethodizeClass:，这个方法是重新方法化的意思。
- 在 reMethodizeClass: 方法内部会调用 attachCategories: ，这个方法会传入 Class 和 Category ，会将方法列表，协议列表等与原有的类合并。最后加入到 class_rw_t 结构体中。

### 20.分类实现了类的initialize方法，那么类的方法initialize还会调用吗？为什么？
- 分类中实现的类的initialize方法，那么类的方法就不会调用了。
- 之所以出现这种覆盖的假象，是因为map_images操作方法的时候，加载顺序：先加载父类->再子类->所有类的分类。所以方法存进类的方法的顺序是：先添加类，后添加分类。但是在Runtime查找imp的时候，是倒序查找类的方法列表中第一个出现的方法，只要找到第一个就直接返回了，所以会出现分类方法覆盖类方法的假象。

### 21.分类与类中同样方法，调用顺序？
- 同样的方法优先调用分类。如果两个分类有同一个方法，调用顺序则取决于编译顺序。

### 22.分类的对象方法是如何添加到类对象方法列表中的？
- 首先内存扩充。扩展存对象方法的数组大小
- 其次内存移动。将原来类对象方法列表数据移到后面
- 最后内存拷贝。将分类中方法拷贝到原来列表指向位置。

### 23.memmove和memcpy的区别？
- memmove会根据内存大小，移动方向，数量来移动内存；
- memcpy是按照一定规则一个地址一个地址拷贝。
- memmove能保证原数据完整性，内部移动最好不要使用memcpy，外部内存移动可以使用。

### 24.分类和类拓展的区别
- category 是在运行时才会将数据合并到类信息中。
- class extension 在编译时就会将数 据编译到类信息中

### 25.动态库和静态库的区别
- 静态库在编译时期:commond+shift+N(即新建工程)----->FrameWork&library—>Cocoa Touch Static Libiary
- 动态库在运行时期:commond+shift+N(即新建工程)----->FrameWork&library—>Cocoa Touch Libiary
- 动态库和静态库的本质区别是，动态库是在程序运行时链接的，而静态库在编译时把代码加入目标程序，那么程序运行时就不需要了。所以使用静态库时生成的目标程序可以脱离源码运行，而动态库生成的目标程序，还需要先安装库才行
- 使用gcc编译的静态库，在生成目标程序链接的过程中也只能用gcc编译；同理使用g++编译的静态库在生成目标程序链接的过程中也只能用g++编译。否则会报错"undefined reference to 'Fun1()'
- 用gcc编译目标程序时，main.c中可以不需要#include "lib.h",会报warning,但是不会报error;但是用g++编译时，一定要加 #include "lib.h",不然编译不通过，因此用g++编译的静态库，还需要它的所有头文件才能使用。
- 当你更改库文件的一些宏定义或者其他东西时，需要重新编译静态库，不然你的修改没有起作用。

### 26.category 中有load 方法吗？ load 方法什么时候调用？ load 方法能继承吗？
- 有load
- 在runtime加载类、分类的时候调用。
- load方法可以继承，但是通常我们不会主动调用。都是系统自动调用。如果我们主动调用的，也就是[KCPerson load]手动调用，这样就变成消息发送机制流程了。

### 27.+load 和 initialized方法的区别
- 两个方法的调用方式
    * load是拿到函数地址直接进行调用
    * initialize是通过objc_msgSend()进行调用的
- 两个方法的调用时机
    * load是runtime加载类，分类的时候调用的(只调用一次)，在main函数之前
    * initialize是类第一次接收到消息时调用的，而且每个类只能被初始化一次(父类initialize方法可能被调用多次)，在main函数之后
- 两个方法的调用顺序
    * load
        * 先调用类的load方法，先编译的类优先调用，调用子类的load的之前，会先调用父类的load方法
        * 再调用分类的load方法，先编译的分类优先先调用(只看编译顺序，不区分是父类的分类还是子类的分类)
    * 先初始化父类，再初始化子类(可能最终调用的是父类的initialize方法)

### 28.+load的调用时机
- load方法调用时机其实就是在程序运行，Runtime进行load_images时调用的，在main函数之前，父类子类分类的调用顺序是：先调用类，后调用所有分类；调用类会先递归调用父类，后调用子类；分类和类的调用顺序没有关系，是根据Mach-O文件的顺序进行调用的。

### 29.+load分类中的处理
### 30.分类和类别的区别

### 31.关联对象的原理
- 关联对象的的api就只有三个

```
// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象;
  objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,
                         id _Nullable value, objc_AssociationPolicy policy)

// 用于获取关联对象                        
  objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)

// 移除所有的关联对象
  objc_removeAssociatedObjects(id _Nonnull object)
```
- 注: objc_removeAssociatedObjects 函数我们一般是用不上的, 因为这个函数会移除一个对象的所有关联对象, 将该对象恢复成“原始”状态. 这样做就很有可能把别人添加的关联对象也一并移除, 这并不是我们所希望的. 所以一般的做法是通过给 objc_setAssociatedObject 函数传入 nil 来移除某个已有的关联对象. 不过我猜测对象析构时系统会直接调用这个移除所有关联对象.
#### objc_setAssociatedObject
- AssociationsManager 是顶级管理者,维护了一个从 spinlock_t 锁到 AssociationsHashMap 哈希表的单例键值对映射;
- AssociationsHashMap 是一个无序的哈希表, 维护了从对象地址到 ObjectAssociationMap 的映射; ObjectAssociationMap 是一个 C++ 中的 map ，维护了从 key 到 ObjcAssociation 的映射，即关联记录;
- ObjcAssociation 是一个 C++ 的类,表示一个具体的关联结构, 主要包括两个实例变量, _policy 表示关联策略, _value表示关联对象.
- 每一个对象地址对应一个 ObjecAssociationMap 对象，而一个 ObjectAssociationMap 对象保存着这个对象的若干个关联记录ObjectAssociation, 每个 ObjectAssociation 则保存了被关联的对象和关联策略.

#### objc_getAssociatedObject
- objc_getAssociatedObject 函数对我们来说就是小菜一碟了.这个函数先根据对象地址在 AssociationsHashMap 中查找其对应的 ObjectAssociationMap 对象, 如果能找到则进一步根据 key 在 ObjectAssociationMap 对象中查找这个 key 所对应的关联结构 ObjcAssociation ,如果能找到则返回 ObjcAssociation 对象的 value 值，否则返回 nil .

#### objc_removeAssociatedObjects
- 这个函数负责移除一个对象的所有关联对象, 具体实现也是先根据对象的地址获取其对应的 ObjectAssociationMap 对象，然后将所有的关联结构保存到一个 vector 中, 最终释放 vector 中保存的所有关联对象.

### 32.说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?
- 简单说就是进行方法交换
- 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
- 每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP。
- 换方法的几种实现方式
    * 利用 method_exchangeImplementations 交换两个方法的实现
    * 利用 class_replaceMethod替换方法的实现
    * 利用 method_setImplementation 来直接设置某个方法的IMP

![image](https://upload-images.jianshu.io/upload_images/11034989-c18ff3c6e3ab50c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/648)

### 33.如何实现动态添加方法和属性？
- 动态添加属性

```
// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象;
  objc_setAssociatedObject(id _Nonnull object, const void * _Nonnull key,
                         id _Nullable value, objc_AssociationPolicy policy)

// 用于获取关联对象                        
  objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)

// 移除所有的关联对象
  objc_removeAssociatedObjects(id _Nonnull object)
```
- 动态添加方法
    * 为什么动态添加方法，为有些方法可能会就不会用到，所以OC都是懒加载机制

### 34.运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？
- 可以添加属性的，但必须我们实现它的getter和setter方法。但是没有添加带下滑线同名的成员变量，但是我们使用runtime我们就可以实现添加成员变量；

### 35.说一下对 isa 指针的理解， 对象的isa 指针指向哪里？isa 指针有哪两种类型？（注意区分不同对象）
- isa指针是什么？
    * 我们经常使用id来声明一个对象，本质上，我们创建的一个对象或实例其实就是一个struct objc_object结构体，而我们常用的id也就是这个结构体的指针。这个结构体只有一个成员变量，这是一个Class类型的变量isa，也是一个结构体									指针。面向对象中每一个对象都必须依赖一个类来创建，因此对象的isa指针就指向对象所属的类根据这个类模板能够创建出实例变量、实例方法等。
- 对象的isa指针
    * 每个实例对象有个isa的指针,他指向对象的类
- 类对象的isa指针
    * Class里也有个isa的指针, 指向meteClass(元类)。
- 元类的isa指针
    * 元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。

![image](http://hi.csdn.net/attachment/201201/19/0_1326963670oeC1.gif)

参考文献：
- [《iOS class深入理解： 实例对象、类对象、元类和isa指针》](http://www.zhimengzhe.com/IOSkaifa/253119.html)
- [《iOS中isa指针》](https://blog.csdn.net/miao_em/article/details/56671616)

### 36.objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）
- 在 Objective-C 中向 nil 发送消息是完全有效的——只是在运行时不会有任何作用:
- 如果一个方法返回值是一个对象，那么发送给nil的消息将返回0(nil)。例如：

```
Person * motherInlaw = [[aPerson spouse] mother];
```
- 如果 spouse 对象为 nil，那么发送给 nil 的消息 mother 也将返回 nil。 
- 如果方法返回值为指针类型，其指针大小为小于或者等于sizeof(void*)，float，double，long double 或者 long long 的整型标量，发送给 nil 的消息将返回0。 
- 如果方法返回值为结构体,发送给 nil 的消息将返回0。结构体中各个字段的值将都是0。 
- 如果方法的返回值不是上述提到的几种情况，那么发送给 nil 的消息的返回值将是未定义的。

具体原因如下：
> objc是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。

具体分析：

```
// runtime.h（类在runtime中的定义）

struct objc_class {
  Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object
  #if !__OBJC2__
  Class super_class OBJC2_UNAVAILABLE; // 父类
  const char *name OBJC2_UNAVAILABLE; // 类名
  long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0
  long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识
  long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小
  struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表
  struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表
  struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。
  struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表
  #endif
  } OBJC2_UNAVAILABLE;
```
objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，然后在发送消息的时候，objc_msgSend方法不会返回值，所谓的返回内容都是具体调用时执行的。 那么，回到本题，如果向一个nil对象发送消息，首先在寻找对象的isa指针时就是0地址返回了，所以不会出现任何错误。

### 37.利用Runtime交换方法
- Method Swizzling
- 有的时候，系统的类不能满足要求时,例如系统类(NSString,UIImage)可能并不能满足我们的要求,解决办法:
    * 往往是给系统自带的类添加分类，就是对原有的类进行扩充方法，但是切记扩充的方法不要和系统的类相同.
    * 或者自定义一个类继承系统的类，再重写父类底层的方法。可以达到给系统的类自定义某个功能的目的。
    * 要求外界调用的类方法必须是系统的类方法，上述两种情况就满足不了条件，可以使用Runtime运行时机制，方法：
        * 创建分类
        * 写一个这样功能的方法
        * 用系统的方法与有这个功能的方法交换
        * 调用imageNamed，先会调用分类的load方法，在load方法实现交换，然后才会去调用分类的ZBimageNamed
        * 具体步骤:在分类中调用load方法，导入runtime框架，load方法中写上获取两个交换的类的类名，然后写上method_exchangexxxxx,实现交换。外界调用imageNamed：的方法，实际上调用了ZBimageNamed。

### 38.说一下 Runtime 消息发送。

![image](https://upload-images.jianshu.io/upload_images/5796542-aae846adbc49d9c0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1021)

### 39.说一下 Runtime 消息解析。
- 在自己的类对象的缓存和方法列表中都没有找到方法，并且在父类的类对象的缓存和方法列表中都没有找到方法时，这时候就会启动动态方法解析。
- lookUpImpOrForward这个方法。在这个方法中前半部分是在自己的类对象以及父类对象中查找方法，后半部分就是处理在自己的类对象和父类对象中都找到不这个方法
- 其中_class_resolveMethod()的实现：就是判断是类对象还是元类对象，如果是类对象则说明调用的实例方法，则调用类的resolveInstanceMethod:方法，如果是元类对象，则说明是调用的类方法，则调用类的resolveClassMethod:方法。
- 动态方法解析是当第一步中方法查找失败时会进行的，当调用的是对象方法时，动态方法解析是在resolveInstanceMethod:方法中实现的，当调用的是类方法时，动态方法解析是在resolveClassMethod:方法中实现的。利用动态方法解析和runtime，我们可以给一个没有实现的方法添加方法实现。
- 当第一步方法查找找不到方法时，就会进行第二步动态方法解析，由于调用的是对象方法，所以会执行resolveInstanceMethod:方法中的代码，在这个方法中，使用runtime的API，给类对象中动态添加了test方法的实现，这个实现是test2方法的实现。当动态方法解析结束后还会返回去进行方法查找，这次能够查找到test方法及其实现了，也就能够成功调用test方法了。

![image](https://upload-images.jianshu.io/upload_images/5796542-e6ad23b13a86a4e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/921)

### 40.说一下 Runtime 消息转发。
- 进行动态方法解析结束之后，会从头开始再进行消息发送这一步，如果在动态方法解析的时候有动态添加方法实现，那么就能找到方法实现并返回方法实现，不再执行下面的代码；如果在动态方法解析的时候没有做什么事，那么就不能找到方法实现，这时候由于triedResolver标志位已经置为YES，也就不会再进入动态消息解析，而是会进入消息转发。
- 调用_objc_msgForward_impcache函数
- 消息转发首先依赖于- (id)forwardingTargetForSelector:(SEL)aSelector这个方法，若是这个方法直接返回了一个消息转发对象，则会通过objc_msgSend()把这个消息转发给消息转发对象了。若是这个方法没有实现或者实现了但是返回值为空，则会跑去执行后面的- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector这个函数以及- (void)forwardInvocation:(NSInvocation *)anInvocation这个函数。

![image](https://upload-images.jianshu.io/upload_images/5796542-b19c544c6b2be02e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1013)

### 41.如何运用 Runtime 字典转模型？
- 利用kvc，键值编码，字典转模型

### 42.如何运用 Runtime 进行模型的归解档？
- 类要遵从NSCoding协议就

### 43.在 Obj-C 中为什么叫发消息而不叫函数调用？
- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
- objc_msgSend底层有3大阶段，消息发送（当前类、父类中查找）、动态方法解析、消息转发

### 44.说一下对 runtime 的理解。（主要讲一下消息机制，是对上述的总结）
- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
- objc_msgSend底层有3大阶段，消息发送（当前类、父类中查找）、动态方法解析、消息转发

### 45.说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？
- cache_t增量扩展的哈希表结构。哈希表内部存储的 bucket_t。
- bucket_t 中存储的是 SEL 和 IMP的键值对。
    * 如果是有序方法列表，采用二分查找
    * 如果是无序方法列表，直接遍历查找
- cache_t结构体

```
// 缓存曾经调用过的方法，提高查找速率
struct cache_t {
    struct bucket_t *_buckets; // 散列表
    mask_t _mask; //散列表的长度 - 1
    mask_t _occupied; // 已经缓存的方法数量，散列表的长度使大于已经缓存的数量的。
    //...
}
```

```
struct bucket_t {
    cache_key_t _key; //SEL作为Key @selector()
    IMP _imp; // 函数的内存地址
    //...
}
```
- 散列表查找过程，在objc-cache.mm文件中

```
// 查询散列表，k
bucket_t * cache_t::find(cache_key_t k, id receiver)
{
    assert(k != 0); // 断言

    bucket_t *b = buckets(); // 获取散列表
    mask_t m = mask(); // 散列表长度 - 1
    mask_t begin = cache_hash(k, m); // & 操作
    mask_t i = begin; // 索引值
    do {
        if (b[i].key() == 0  ||  b[i].key() == k) {
            return &b[i];
        }
    } while ((i = cache_next(i, m)) != begin);
    // i 的值最大等于mask,最小等于0。

    // hack
    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));
    cache_t::bad_cache(receiver, (SEL)k, cls);
}
```
- 上面是查询散列表函数，其中cache_hash(k, m)是静态内联方法，将传入的key和mask进行&操作返回uint32_t索引值。do-while循环查找过程，当发生冲突cache_next方法将索引值减1。

### 46.是否了解 Type Encoding?
- 类型编码
- 为了完善 Runtime 机制，编译器将方法的返回值类型和参数的类型编码成字符串，并且将这个字符串与方法的选择器(selector)关联起来。这个字符串就是类型编码
- 通过编译指令@encode()，则可以获得对应的类型编码。传递的类型可以是基本数据类型，比如int，指针(pointer)，结构体(struct)或者联合(union),还可以是一个类名，任何类型都可以。事实上，适用于@sizeof()的类型都适用于@encode()。
- 常用的@encode指令：

![image](https://upload-images.jianshu.io/upload_images/11544062-818801b9af677f1a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

### 47.Objective-C 如何实现多重继承？
- Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现
- 通过组合实现：A和B组合，作为C类的组件
- 通过协议实现：C类实现A和B类的协议方法
- 消息转发实现：forwardInvocation:方法

### 48.runtime如何通过selector找到对应的IMP地址？
- 每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.

### 49.runtime具体应用
- 利用关联对象（AssociatedObject）给分类添加属性
- 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
- 交换方法实现（交换系统的方法）
- 利用消息转发机制解决方法找不到的异常问题
- KVC 字典转模型

### 50.使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？
- 无论在MRC下还是ARC下均不需要，被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放。

```
1、调用 -release ：引用计数变为零
对象正在被销毁，生命周期即将结束. 
不能再有新的 __weak 弱引用，否则将指向 nil.
调用 [self dealloc]

2、 父类调用 -dealloc 
继承关系中最直接继承的父类再调用 -dealloc 
如果是 MRC 代码 则会手动释放实例变量们（iVars）
继承关系中每一层的父类 都再调用 -dealloc

>3、NSObject 调 -dealloc 
只做一件事：调用 Objective-C runtime 中object_dispose() 方法

>4. 调用 object_dispose()
为 C++ 的实例变量们（iVars）调用 destructors
为 ARC 状态下的 实例变量们（iVars） 调用 -release 
解除所有使用 runtime Associate方法关联的对象 
解除所有 __weak 引用 
调用 free()

```

### 51.runtime如何实现weak变量的自动置nil？知道SideTable吗？
- runtime 对注册的类会进行布局，对于 weak 修饰的对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
- 更细一点的回答：
    * 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。
    * 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数，objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
    * 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
- SideTable结构体是负责管理类的引用计数表和weak表
#### 详解：
##### 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。

```
{
    NSObject *obj = [[NSObject alloc] init];
    id __weak obj1 = obj;
}
```
- 当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。

```
// 编译器的模拟代码
 id obj1;
 objc_initWeak(&obj1, obj);
/*obj引用计数变为0，变量作用域结束*/
 objc_destroyWeak(&obj1);
```
- 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。
##### 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数，objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
- objc_initWeak函数将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。

```
obj1 = 0；
obj_storeWeak(&obj1, obj);
```
- 也就是说：weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。

```
objc_storeWeak(&obj1, 0);
```
- 前面的源代码与下列源代码相同。

```
// 编译器的模拟代码
id obj1;
obj1 = 0;
objc_storeWeak(&obj1, obj);
/* ... obj的引用计数变为0，被置nil ... */
objc_storeWeak(&obj1, 0);
```
- objc_storeWeak函数把第二个参数的赋值对象（obj）的内存地址作为键值，将第一个参数__weak修饰的属性变量（obj1）的内存地址注册到weak表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址。可以把objc_storeWeak(&a,b)理解为：objc_storeWeak(value,key)，并且当key变nil，将value置nil。在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。
##### 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
- 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：
    * 调用objc_release
    * 因为对象的引用计数为0，所以执行dealloc
    * 在dealloc中，调用了_objc_rootDealloc函数
    * 在_objc_rootDealloc中，调用了object_dispose函数
    * 调用objc_destructInstance
    * 最后调用objc_clear_deallocating
- 对象被释放时调用的objc_clear_deallocating函数:
    * 从weak表中获取废弃对象的地址为键值的记录
    * 将包含在记录中的所有附有weak修饰符变量的地址，赋值为nil
    * 将weak表中该记录删除
    * 从引用计数表中删除废弃对象的地址为键值的记录
- 其实Weak表是一个hash（哈希）表，Key是weak所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。

## Runloop
### 1.RunLoop概念
- RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象。
    * 没有消息处理时，休眠已避免资源占用，由用户态切换到内核态(CPU-内核态和用户态)
    * 有消息需要处理时，立刻被唤醒，由内核态切换到用户态
- 为什么main函数不会退出？

```
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```
- UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段无限循环的代码（不是简单的for循环或while循环）

```
//无限循环代码模式(伪代码)
int main(int argc, char * argv[]) {        
    BOOL running = YES;
    do {
        // 执行各种任务，处理各种事件
        // ......
    } while (running);

    return 0;
}
```
- UIApplicationMain函数一直没有返回，而是不断地接收处理消息以及等待休眠，所以运行程序之后会保持持续运行状态。

### 补充：内核态和用户态
- CPU的两种工作状态：内核态和用户态
- 内核态
    * 系统中既有操作系统的程序，也由普通用户的程序。为了安全和稳定性操作系统的程序不能随便访问,这就是内核态
    * 内核态可以使用所有的硬件资源
- 用户态
    * 不能直接使用系统资源，也不能改变CPU的工作状态，并且只能访问这个用户程序自己的存储空间

### 2.RunLoop的数据结构
- NSRunLoop(Foundation)是CFRunLoop(CoreFoundation)的封装，提供了面向对象的API
RunLoop 相关的主要涉及五个类：
    * CFRunLoop：RunLoop对象
    * CFRunLoopMode：运行模式
    * CFRunLoopSource：输入源/事件源
    * CFRunLoopTimer：定时源
    * CFRunLoopObserver：观察者
- CFRunLoop
    * 由pthread(线程对象，说明RunLoop和线程是一一对应的)、currentMode(当前所处的运行模式)、modes(多个运行模式的集合)、commonModes(模式名称字符串集合)、commonModelItems(Observer,Timer,Source集合)构成
- CFRunLoopMode
    * 由name、source0、source1、observers、timers构成
    * 主要是4个Mode
        * NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态
        * UITrackingRunLoopMode：ScrollView滑动时
        * UIInitializationRunLoopMode：启动时
        * NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合
- CFRunLoopSource
    * 分为source0和source1两种
    * source0:即非基于port的，也就是用户触发的事件。需要手动唤醒线程，将当前线程从内核态切换到用户态
    * source1:基于port的，包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒RunLoop，接收分发系统事件。具备唤醒线程的能力
- CFRunLoopTimer
    * 基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒RunLoop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。
- CFRunLoopObserver
    * 监听以下时间点:CFRunLoopActivity
    * kCFRunLoopEntry：RunLoop准备启动
    * kCFRunLoopBeforeTimers ：RunLoop将要处理一些Timer相关事件
    * kCFRunLoopBeforeSources ：RunLoop将要处理一些Source事件
    * kCFRunLoopBeforeWaiting ：RunLoop将要进行休眠状态,即将由用户态切换到内核态
    * kCFRunLoopAfterWaiting：RunLoop被唤醒，即从内核态切换到用户态后
    * kCFRunLoopExit：RunLoop退出
    * kCFRunLoopAllActivities：监听所有状态
- 各数据结构之间的联系
    * 线程和RunLoop一一对应， RunLoop和Mode是一对多的，Mode和source、timer、observer也是一对多的
    * 一个RunLoop对象中包含若干个运行模式。而每一个运行模式下有3包含若干个输入源、定时源、观察者
    * 每次RunLoop启动时，只能指定其中一个运行模式，这个运行模式被称为当前运行模式
    * 如果需要切换运行模式，只能退出当前Loop，再重新制定一个运行模式进入，这样做主要是为了分隔开不同组的输入源、定时源、观察者，让其互不影响

### 3.猜想runloop内部是如何实现的？
> 一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑 是这样的：


```
function loop() {
    initialize();
    do {
        var message = get_next_message();
        process_message(message);
    } while (message != quit);
}
```
或使用伪代码来展示下:

```
// 
// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)
// https://github.com/ChenYilong
int main(int argc, char * argv[]) {
 //程序一直运行状态
 while (AppIsRunning) {
      //睡眠状态，等待唤醒事件
      id whoWakesMe = SleepForWakingUp();
      //得到唤醒事件
      id event = GetEvent(whoWakesMe);
      //开始处理事件
      HandleEvent(event);
 }
 return 0;
}
```
参考文献：
- [《深入理解RunLoop》](https://blog.ibireme.com/2015/05/18/runloop/#base)
- [CFRunLoop](https://github.com/ming1016/study/wiki/CFRunLoop)，原作者是微博@我就叫Sunny怎么了

### 4.runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？
- 总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。
- runloop 和线程的关系：
    * 主线程的run loop默认是启动的。
iOS的应用程序里面，程序启动后会有一个如下的main()函数

```
int main(int argc, char * argv[]) {
   @autoreleasepool {
       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
   }
}
```
重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
    * 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。
    * 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。

```
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
```
- 参考链接：[《Objective-C之run loop详解》](https://blog.csdn.net/wzzvictory/article/details/9237973)。

### 5.Runloop 和线程的关系？
- 总的说来，Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分， Cocoa 和 CoreFundation 都提供了 run loop 对象方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程（ main thread ）都有与之相应的 run loop 对象。
- runloop 和线程的关系：
    * 主线程的run loop默认是启动的。
iOS的应用程序里面，程序启动后会有一个如下的main()函数

```
int main(int argc, char * argv[]) {
   @autoreleasepool {
       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
   }
}
```
重点是UIApplicationMain()函数，这个方法会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
    * 对其它线程来说，run loop默认是没有启动的，如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。
    * 在任何一个 Cocoa 程序的线程中，都可以通过以下代码来获取到当前线程的 run loop 。

```
NSRunLoop *runloop = [NSRunLoop currentRunLoop];
```
- 参考链接：[《Objective-C之run loop详解》](https://blog.csdn.net/wzzvictory/article/details/9237973)。

### 6.讲一下 Runloop 的 Mode?(越详细越好)
- model主要是用来指定事件在运行循环中的优先级的，分为：
    * NSDefaultRunLoopMode（kCFRunLoopDefaultMode）：默认，空闲状态
    * UITrackingRunLoopMode：ScrollView滑动时
    * UIInitializationRunLoopMode：启动时
    * NSRunLoopCommonModes（kCFRunLoopCommonModes）：Mode集合
- 苹果公开提供的 Mode 有两个：
    * NSDefaultRunLoopMode（kCFRunLoopDefaultMode）
    * NSRunLoopCommonModes（kCFRunLoopCommonModes）

### 7.讲一下 Observer ？（Mode中的重点）
```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
};
```

### 8.讲一下 Runloop 的内部实现逻辑？（运行过程）
![image](https://upload-images.jianshu.io/upload_images/1782258-2f8dd696ecbf0275.png?imageMogr2/auto-orient/strip|imageView2/2/w/572)

- 对于RunLoop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。RunLoop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。
- RunLoop通过mach_msg()函数接收、发送消息。它的本质是调用函数mach_msg_trap()，相当于是一个系统调用，会触发内核状态切换。在用户态调用 mach_msg_trap()时会切换到内核态；内核态中内核实现的mach_msg()函数会完成实际的工作。
- 即基于port的source1，监听端口，端口有消息就会触发回调；而source0，要手动标记为待处理和手动唤醒RunLoop
- Mach消息发送机制，大致逻辑为：
    * 1.通知观察者 RunLoop 即将启动。
    * 2.通知观察者即将要处理Timer事件。
    * 3.通知观察者即将要处理source0事件。
    * 4.处理source0事件。
    * 5.如果基于端口的源(Source1)准备好并处于等待状态，进入步骤9。
    * 6.通知观察者线程即将进入休眠状态。
    * 7.将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。
        * 一个基于 port 的Source1 的事件(图里应该是source0)。
        * 一个 Timer 到时间了。
        * RunLoop 自身的超时时间到了。
        * 被其他调用者手动唤醒。
    * 8.通知观察者线程将被唤醒。
    * 9.处理唤醒时收到的事件。
        * 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。
        * 如果输入源启动，传递相应的消息。
        * 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2
    * 10.通知观察者RunLoop结束。

### 9.RunLoop实战使用
#### NSTimer的使用
- NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。
- 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。
- CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。

#### ImageView推迟显示
- 当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。
- 我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：
    * 监听UIScrollView的滚动
        * 因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。
    * 利用PerformSelector设置当前线程的RunLoop的运行模式
        * 利用performSelector方法为UIImageView调用setImage:方法，并利用inModes将其设置为RunLoop下NSDefaultRunLoopMode运行模式。

```
[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@"tupian"] afterDelay:4.0 inModes:NSDefaultRunLoopMode];
```

#### 后台常驻线程
* 为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）
* 向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）
* 启动该RunLoop

```
@autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
        
    }
```
[link](https://note.youdao.com/)
### 10.你所知的哪些三方框架使用了 Runloop?（AFNetworking、Texture 等）
- AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
```
- RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。

```
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
```
- 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。

### 11.autoreleasePool 在何时被释放？
- App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。
- 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。
- 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。
- 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。

### 12.介绍UIResponder的继承链。然后说事件响应链。
- 首先要先了解响应者对象UIResponder，只有继承UIResponder的的类，才能处理事件。
- 我们可以看出UIApplication，UIView，UIViewController都是继承自UIResponder类，可以响应和处理事件。

### 13.解释一下 事件响应 的过程？
- 响应者：响应者为响应事件的UIResponder子类对象，如UIButton、UIView等；
- 响应链：响应链是由链接在一起的响应者（UIResponse子类）组成的。
- 事件传递：获得响应链后，将事件由第一响应者往application传递的过程；
- 事件的传递过程

![image](https://upload-images.jianshu.io/upload_images/4986510-8e8307e475ec486f.png)

- 苹果基于mach port注册了一个Source1用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。
- 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个Source1就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用内部的分发。
- _UIApplicationHandleEventQueue() 会把IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。
- 其实说白了就是：当iOS程序发生触摸事件后，系统会利用Runloop将事件加入到UIApplication的任务队列中；UIApplication分发触摸事件到UIWindow，然后UIWindow依次向下分发给UIView；UIView调用hitTest:withEvent:方法看看自己能否处理事件，以及触摸点是否在自己上面；如果满足条件，就遍历UIView上的子控件。重复上面的动作；直到找到最顶层的一个满足条件（既能处理触摸事件，触摸点又在上面）的子控件，此子控件就是我们需要找到的第一响应者。

```
// 此方法返回的View是本次点击事件需要的最佳View
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event

// 判断一个点是否落在范围内
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
//返回最适合处理事件的视图，最好在父视图中指定子视图的响应

// 因为所有的视图类都是继承BaseView
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
   // 1.判断当前控件能否接收事件
   if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha <= 0.01) return nil;
   // 2. 判断点在不在当前控件
   if ([self pointInside:point withEvent:event] == NO) return nil;
   // 3.从后往前遍历自己的子控件
   NSInteger count = self.subviews.count;
   for (NSInteger i = count - 1; i >= 0; i--) {
       UIView *childView = self.subviews[I];
       // 把当前控件上的坐标系转换成子控件上的坐标系
    CGPoint childP = [self convertPoint:point toView:childView];
      UIView *fitView = [childView hitTest:childP withEvent:event];
       if (fitView) { // 寻找到最合适的view
           return fitView;
       }
   }
   // 循环结束,表示没有比自己更合适的view
   return self;
   
}
```

### 14.解释一下 手势识别 的过程？
- 当 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用Cancel将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的UIGestureRecognizer 标记为待处理。
- 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer 的回调。
- 当有 UIGestureRecognizer的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

### 15.解释一下 GCD 在 Runloop 中的使用？
- GCD由 子线程 返回到 主线程,只有在这种情况下才会触发 RunLoop。会触发 RunLoop 的 Source 1 事件。

### 16.解释一下 NSTimer，以及 NSTimer 的循环引用。
- NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。
- 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。
- CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。

### 17.NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?
#### 不准
#### 不准的原因如下：
- NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。
- 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。
- 当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。（DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。）
#### 解决方法：
- 方法一：
    * 在主线程中进行NSTimer操作，但是将NSTimer实例加到mainrunloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。
```
self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

```
    * 在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；
```
- (void)timerMethod2 { 
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
  [thread start];
  } 
- (void)newThread 
 { 
 @autoreleasepool 
 {
 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] run]; 
 } 
 }
 
```
- 总结：
    * 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。
    * 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop
 
- 方法二：    
    * 使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。

- 方法三：
    * 直接使用GCD替代！

### 18.AFNetworking 中如何运用 Runloop?
 AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
```
- RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。

```
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
```
- 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。

### 19.AFN为什么添加一条常驻线程？
### 20.PerformSelector 的实现原理？
- 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个Timer并添加到当前线程的 RunLoop 中。所以如果当前线程没有RunLoop，则这个方法会失效。
- 当调用 performSelector:onThread:时，实际上其会创建一个 Timer加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。
- PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？
    * 不起作用，子线程默认没有 Runloop，也就没有 Timer。
    * 解决的办法是可以使用 GCD 来实现：Dispatch_after

### 21.利用 runloop 解释一下页面的渲染的过程？
- 当我们调用 [UIView setNeedsDisplay]时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。
- 这等于给当前的layer打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的Runloop即将休眠，也就是 beforeWaiting 时才会进行绘制工作。
- 紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer层会判断自己的 delegate有没有实现异步绘制的代理方法displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。
- CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。
- 如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。
- 如果没有 delegate，那么会调用 [CALayer drawInContext:]。
- 以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。
- 至此绘制的过程结束。

### 22.如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？
* 为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）
* 向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）
* 启动该RunLoop

```
@autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
        
    }
```

### 23.NSThread+runloop实现常驻线程
- NSThread在实际开发中比较常用到的场景就是去实现常驻线程。
- 由于每次开辟子线程都会消耗cpu，在需要频繁使用子线程的情况下，频繁开辟子线程会消耗大量的cpu，而且创建线程都是任务执行完成之后也就释放了，不能再次利用，那么如何创建一个线程可以让它可以再次工作呢？也就是创建一个常驻线程。
- 首先常驻线程既然是常驻，那么我们可以用GCD实现一个单例来保存NSThread

```
+ (NSThread *)shareThread {
    
    static NSThread *shareThread = nil;
    
    static dispatch_once_t oncePredicate;
    
    dispatch_once(&oncePredicate, ^{
        
        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest) object:nil];

        [shareThread setName:@"threadTest"];
        
        [shareThread start];
    });
    
    return shareThread;
}
```
- 可以用runloop来让线程常驻

```
+ (NSThread *)shareThread {
    
    static NSThread *shareThread = nil;
    
    static dispatch_once_t oncePredicate;
    
    dispatch_once(&oncePredicate, ^{
        
        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest2) object:nil];
        
        [shareThread setName:@"threadTest"];
        
        [shareThread start];
    });
    
    return shareThread;
}

+ (void)threadTest
{
    @autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
    }
}
```

### 24.为什么 NSTimer 有时候不好使？（不同类型的Mode）
- 因为创建的 NSTimer 默认是被加入到了 defaultMode，所以当 Runloop 的 Mode 变化时，当前的 NSTimer 就不会工作了。

### 25.滑动tableView时，定时器还会生效吗？
- 默认情况下RunLoop运行在kCFRunLoopDefaultMode下，而当滑动tableVie时，RunLoop切换到UITrackingRunLoopMode，而Timer是在kCFRunLoopDefaultMode下的，就无法接受处理Timer的事件。
- 解决：把Timer添加到UITrackingRunLoopMode上并不能解决问题，因为这样在默认情况下就无法接受定时器事件了。所以我们需要把Timer同时添加到UITrackingRunLoopMode和kCFRunLoopDefaultMode上。
- 那么如何把timer同时添加到多个mode上呢？就要用到NSRunLoopCommonModes了

```
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```
- Timer就被添加到多个mode上，这样即使RunLoop由kCFRunLoopDefaultMode切换到UITrackingRunLoopMode下，也不会影响接收Timer事件

### 26.以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
- RunLoop只能运行在一种mode下，如果要换mode，当前的loop也需要停下重启成新的。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动：只能在NSDefaultRunLoopMode模式下处理的事件会影响ScrollView的滑动。
- 如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。
- 同时因为mode还是可定制的，所以：

Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：

```
// 

//将timer添加到NSDefaultRunLoopMode中
[NSTimer scheduledTimerWithTimeInterval:1.0
     target:self
     selector:@selector(timerTick:)
     userInfo:nil
     repeats:YES];
//然后再添加到NSRunLoopCommonModes里
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0
     target:self
     selector:@selector(timerTick:)
     userInfo:nil
     repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```

### 27.PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？
- 不起作用，子线程默认没有 Runloop，也就没有 Timer。
- 解决的办法是可以使用 GCD 来实现：Dispatch_after

### 28.什么是异步绘制？
- 异步绘制，就是可以在子线程把需要绘制的图形，提前在子线程处理好。将准备好的图像数据直接返给主线程使用，这样可以降低主线程的压力。
- 异步绘制的过程
    * 要通过系统的 [view.delegate displayLayer:] 这个入口来实现异步绘制。
        * 代理负责生成对应的 Bitmap
        * 设置该 Bitmap 为 layer.contents 属性的值。

### 29.如何检测 App 运行过程中是否卡顿？
#### 什么原因导致了卡顿
- 死锁
- 抢锁
- 大量的Ui绘制,复杂的UI，图文混排
- 主线程大量IO、大量计算

#### Analyze 静态分析
- Analyze静态分析是Xcode自带的一个强大的性能调优工具，它能够在不运行程序的情况下直接对代码进行分析。能够快速的分析出项目中的逻辑错误、内存管理错误、声明错误、API调用错误等。
- 使用方法：Xcode -> Product -> Analyze

#### Instruments 动态分析
- Instruments也是Xcode自带的性能调优工具，它能够在程序运行的情况下对代码进行分析。能够方便地分析出代码中出现的内存泄漏、僵尸对象等和程序性能、内存分配情况。
- 使用方法：Xcode -> Open Developer Tool -> Instruments

#### RunLoop方式
- 首先在主线程注册了runloop observer的回调myRunLoopObserver
每次小循环都会记录一下kCFRunLoopAfterWaiting的时间_waitStartTime，并且在kCFRunLoopBeforeWaiting制空。
- 另外开了一个子线程并开启他的runloop（模仿了AFNetworking的方式），并加上一个timer每隔1秒去进行监测。
- 如果当前时长与_waitStartTime差距大于2秒，则认为有卡顿情况，并记录了当前堆栈信息。

## 多线程
### 1.进程和线程、多进程和多线程、任务和队列、并行与串行、同步和异步
- 进程和线程的区别
    * 一个程序至少要有进程，一个进程至少要有一个线程
    * 进程：资源分配的最小独立单元，进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位
    * 线程:进程下的一个分支，是进程的实体，是cpu调度和分派的基本单元，它使比进程更小的能独立运行的基本单位，线程自己基本不拥有系统资源，只拥有一点在运行中必不可少的资源呢，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源
    * 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性
    * 进程和线程的主要差别在于它们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而进程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于这个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
    * 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

- 多进程，打开mac的活动监视器，可以看到很多个进程同时运行：
    * 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。
    * 进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程。进程是操作系统进行资源分配的单位。
    * 进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程。
- 多线程
    * 同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
    * 如果线程非常非常多，CPU会在N多线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）
    * 多线程的优点:
        * 能适当提高程序的执行效率
        * 能适当提高资源利用率（CPU、内存利用率）
    * 多线程的缺点:
        * 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能
        * 线程越多，CPU在调度线程上的开销就越大
        * 程序设计更加复杂：比如线程之间的通信、多线程的数据共享

- 任务
    * 就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：同步执行（sync）和异步执行（async）
    * 同步(Sync)：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。
    * 异步(Async)：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务
- 队列
    * 队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务
    * 在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。
    * 串行队列（Serial Dispatch Queue）：同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的
    * 并发队列（Concurrent Dispatch Queue）：同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效

- 同步和异步、并发和并行的区别？

1、并发：在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行。其中两种并发关系分别是同步和互斥

2、同步：进程之间的关系不是相互排斥临界资源的关系，而是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。具有同步关系的一组并发进程相互发送的信息称为消息或事件。

3、互斥：进程间相互排斥的使用临界资源的现象，就叫互斥。

4、并行：在单处理器中多道程序设计系统中，进程被交替执行，表现出一种并发的外部特种；在多处理器系统中，进程不仅可以交替执行，而且可以重叠执行。在多处理器上的程序才可实现并行处理。从而可知，并行是针对多处理器而言的。并行是同时发生的多个并发事件，具有并发的含义，但并发不一定并行，也亦是说并发事件之间不一定要同一时刻发生。

5、异步：异步和同步是相对的，同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。异步就是彼此独立,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。线程就是实现异步的一个方式。异步是让调用方法的主线程不需要同步等待另一线程的完成，从而可以让主线程干其它的事情。

6、串行和并行：串行是一次只能执行一个任务，并行是一次能执行多个任务；并行是CPU的多核芯同时执行多个任务  并发是单核CPU交替执行两个任务

7、同步异步关注的是消息通讯机制，所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。注意这个返回是指CUP返回执行的数据段部分，所以目前来看只是阻塞了CPU的数据段部分 并不耽误CPU干别的 所以即使是同步也不见得是阻塞模式。换句话说，就是由*调用者*主动等待这个*调用*的结果。而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。典型的异步编程模型比如Node.js

### 2.iOS线程间怎么通信？
线程间通信：在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信
 
线程间通信的体现
1个线程传递数据给另1个线程
在1个线程中执行完特定任务后，转到另1个线程继续执行任务
 
线程间通信常用方法
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait;
- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait;

 
线程间通信示例 – 图片下载


```
//
//  YYViewController.m
//  06-NSThread04-线程间通信
//

//

#import "YYViewController.h"
@interface YYViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *iconView;
@end

@implementation YYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
}

-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{

 // 在子线程中调用download方法下载图片
    [self performSelectorInBackground:@selector(download) withObject:nil];
}

 

 -(void)download
{
    //1.根据URL下载图片
    //从网络中下载图片
    NSURL *urlstr=[NSURL URLWithString:@"fdsf"];

    //把图片转换为二进制的数据
    NSData *data=[NSData dataWithContentsOfURL:urlstr];//这一行操作会比较耗时

    //把数据转换成图片
   UIImage *image=[UIImage imageWithData:data];
 
    //2.回到主线程中设置图片
    [self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];
}
 
 

 //设置显示图片
-(void)settingImage:(UIImage *)image
 {
    self.iconView.image=image;
 }

 @end
```

```
//
//  YYViewController.m
//  06-NSThread04-线程间通信
//
//  Created by apple on 14-6-23.
//  Copyright (c) 2014年 itcase. All rights reserved.
//

#import "YYViewController.h"
#import <NSData.h>
 
 @interface YYViewController ()
 @property (weak, nonatomic) IBOutlet UIImageView *iconView;
 @end
 
 @implementation YYViewController
 
 - (void)viewDidLoad
 {
     [super viewDidLoad];
 }
 
  
 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
 {
 // 在子线程中调用download方法下载图片
 
     [self performSelectorInBackground:@selector(download) withObject:nil];
 }
 
  
 -(void)download
 {
 
     //1.根据URL下载图片
     //从网络中下载图片
     NSURL *urlstr=[NSURL URLWithString:@"fdsf"];
 
     //把图片转换为二进制的数据
     NSData *data=[NSData dataWithContentsOfURL:urlstr];//这一行操作会比较耗时
 
     //把数据转换成图片
     UIImage *image=[UIImage imageWithData:data];
 
     //2.回到主线程中设置图片
     //第一种方式
 //    [self performSelectorOnMainThread:@selector(settingImage:) withObject:image waitUntilDone:NO];
 
     //第二种方式
     //    [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO];
 
     //第三种方式
    [self.iconView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];
}
 
 
//设置显示图片
//-(void)settingImage:(UIImage *)image
//{
//    self.iconView.image=image;
 //}
 
@end
```

### 3.谈谈你对多线程开发的理解(多线程的好处，多线程的作用)？ios中有几种实现多线程的方法？
- 好处：
    - 使用线程可以把占据时间长的程序中的任务放到后台去处理
    - 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度
    - 程序的运行效率可能提高
    - 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。
- 缺点：
    - 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。
    - 更多的线程需要更多的内存空间。
    - 线程的中止需要考虑其对程序运行的影响。
- 实现多线程的方法：
    - NSObject的类方法 
        - -(void)performSelectornBackground/OnMainThread:(SEL)aSelector withObject:(id)arg
    - NSThread
    - NSOperation
    - GCD
- NSThread:(两种创建方式)

```
[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];
 
NSThread *myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];
 
[myThread start];
```
- 优点：NSThread 比其他两个轻量级。 
- 缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。
- Cocoa Operation

```
NSOperationQueue*oprationQueue= [[NSOperationQueuealloc] init];
 
oprationQueueaddOperationWithBlock:^{
 
//这个block语句块在子线程中执行
 
}
```
- 优点：不需要关心线程管理，数据同步的事情。 Cocoa Operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行，我们会把我们的执行操作放在NSOperation中main函数中。
- GCD Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法，GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。它让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务，一个任务可以是一个函数(function)或者是一个block。 dispatch queue分为下面三种： private dispatch queues，同时只执行一个任务，通常用于同步访问特定的资源或数据。 global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。 Main dispatch queue 它是在应用程序主线程上执行任务的。

### 4.多线程容易出现的问题，怎么解决
- 线程安全问题，当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。加锁

### 补充：多线程的安全隐患+11种同步解决方案
#### 多线程的安全隐患
- 资源共享
    * 1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源
    * 比如多个线程访问同一个对象、同一个变量、同一个文件
    * 当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题

#### 多线程安全隐患的解决方案
- 解决方案：使用线程同步技术（同步，就是协同步调，按预定的先后次序进行）
- 常见的线程同步技术是：加锁

#### iOS中的线程同步方案
- OSSpinLock
- os_unfair_lock
- pthread_mutex
- dispatch_semaphore
- dispatch_queue(DISPATCH_QUEUE_SERIAL)
- NSLock
- NSRecursiveLock
- NSCondition
- NSConditionLock
- @synchronized

##### OSSpinLock
- OSSpinLock叫做”自旋锁”，等待锁的线程会处于忙等（busy-wait）状态，一直占用着CPU资源
- 目前已经不再安全，可能会出现优先级反转问题
- 如果等待锁的线程优先级较高，它会一直占用着CPU资源，优先级低的线程就无法释放锁
- 需要导入头文件#import <libkern/OSAtomic.h>
- 重要方法
    * OSSpinLock lock = OS_SPINLOCK_INIT; 初始化锁
    * bool result = OSSpinLockTry(&_lock); 尝试加锁(如果需要等待,就不尝试加锁,直接返回false,如果不需要等待就加锁,返回true)
    * OSSpinLockLock(&_lock);// 加锁
    * OSSpinLockUnlock(&_lock); //解锁
- 代码例子如下
```
#import <libkern/OSAtomic.h>
@property (assign, nonatomic) OSSpinLock lock;

// 初始化锁
self.lock = OS_SPINLOCK_INIT;

/** 卖1张票 */
- (void)saleTicket {
    // 加锁
    OSSpinLockLock(&_lock);
    
    int oldTicketsCount = self.ticketsCount;
    sleep(.2);
    oldTicketsCount--;
    self.ticketsCount = oldTicketsCount;
    
    NSLog(@"还剩%d张票 - %@", oldTicketsCount, [NSThread currentThread]);
    
    // 解锁
    OSSpinLockUnlock(&_lock);
}
```
- 执行结果

![image](https://upload-images.jianshu.io/upload_images/1653926-00a374659301b683.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

##### os_unfair_lock
- os_unfair_lock用于取代不安全的OSSpinLock ，从iOS10开始才支持
- 从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等
- 需要导入头文件#import <os/lock.h>
- 重要方法
    * os_unfair_lock moneyLock = OS_UNFAIR_LOCK_INIT; //初始化
    * os_unfair_lock_trylock(&_ticketLock); // 尝试加锁
    * os_unfair_lock_lock(&_ticketLock); // 加锁
    * os_unfair_lock_unlock(&_ticketLock); // 解锁

##### pthread_mute
- mutex叫做”互斥锁”，等待锁的线程会处于休眠状态
- 需要导入头文件#import <pthread.h>
- 重要方法

```
// 初始化属性
pthread_mutexattr_t attr;
pthread_mutexattr_init(&attr);
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
// 初始化锁
pthread_mutex_init(mutex, &attr);
// 尝试加锁
pthread_mutex_trylock(&_ticketMutex);
// 加锁
pthread_mutex_lock(&_ticketMutex);
// 解锁
pthread_mutex_unlock(&_ticketMutex);
// 销毁属性
pthread_mutexattr_destroy(&attr);
```

##### pthread_mutex递归锁实现

```
- (void)__initMutex:(pthread_mutex_t *)mutex {
    // 递归锁：允许同一个线程对一把锁进行重复加锁
    
    // 初始化属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&attr);
    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    // 初始化锁
    pthread_mutex_init(mutex, &attr);
    // 销毁属性
    pthread_mutexattr_destroy(&attr);
}
```
- 调用

```
- (void)otherTest {
    pthread_mutex_lock(&_mutex);
    NSLog(@"%s", __func__);
    
    static int count = 0;
    if (count < 10) {
        count++;
        [self otherTest];
    }
    
    pthread_mutex_unlock(&_mutex);
}
```
- 打印结果

![image](https://upload-images.jianshu.io/upload_images/1653926-c31e8cf6db0e5f33.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

##### pthread_mutex – 条件
![image](https://upload-images.jianshu.io/upload_images/1653926-93853471e6f19941.png?imageMogr2/auto-orient/strip|imageView2/2/w/578)

##### NSLock
- NSLock是对mutex普通锁的封装
- 重要方法如下
    * NSLock *lock = [[NSLock alloc] init];初始化
    * [lock lock] 加锁
    * [lock unlock] 解锁
    
##### NSRecursiveLock
- NSRecursiveLock也是对mutex递归锁的封装，API跟NSLock基本一致

##### NSCondition
- NSCondition是对mutex和cond的封装
- 重要方法

```
@interface NSCondition: NSObject <NSLocking>
- (void)wait;   // 等待
- (BOOL)waitUntilDate:(NSDate *)limit;  // 只等待到什么时候
- (void)signal; // 发信号
- (void)broadcast;  // 发广播
@end
```
- 代码例子如下

```
- (void)otherTest {
    // remove和add方法不确定谁先执行
    [[[NSThread alloc] initWithTarget:self selector:@selector(__remove) object:nil] start];
    
    [[[NSThread alloc] initWithTarget:self selector:@selector(__add) object:nil] start];
}

// 删除数组中的元素
- (void)__remove {
    [self.condition lock];
    NSLog(@"__remove - begin");
    
    if (self.data.count == 0) {
        // 等待
        [self.condition wait];
    }
    
    [self.data removeLastObject];
    NSLog(@"删除了元素");
    
    [self.condition unlock];
}

// 线程2
// 往数组中添加元素
- (void)__add {
    [self.condition lock];
    
    sleep(1);
    
    [self.data addObject:@"Test"];
    NSLog(@"添加了元素");
    
    // 信号
    NSLog(@"发出信号");
    [self.condition signal];
    // 广播
//    [self.condition broadcast];
    
    sleep(2);
    
    [self.condition unlock];
}
```
- 运行结果
![image](https://upload-images.jianshu.io/upload_images/1653926-1d04a525e9f81181.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
- 更改执行顺序

```
// 往数组中添加元素
- (void)__add {
    [self.condition lock];
    
    sleep(1);
    
    [self.data addObject:@"Test"];
    NSLog(@"添加了元素");
    
    [self.condition unlock];
    
    sleep(2);
    
    // 信号
    NSLog(@"发出信号");
    [self.condition signal];
    // 广播
//    [self.condition broadcast];
}
```
- 运行结果
![image](https://upload-images.jianshu.io/upload_images/1653926-0e9290e6d6d760d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
- wait不仅仅需要接受到信号后才能执行，而且必须具备加锁条件，这个时候才会接着往下执行。

##### NSConditionLock
- NSConditionLock是对NSCondition的进一步封装，可以设置具体的条件值

![image](https://upload-images.jianshu.io/upload_images/1653926-bd04c18c5f8dbbd0.png?imageMogr2/auto-orient/strip|imageView2/2/w/753)

- 代码例子如下
```
@property (strong, nonatomic) NSConditionLock *conditionLock;

- (instancetype)init {
    if (self = [super init]) {
//        [[NSConditionLock alloc] init]; // 默认为0
        self.conditionLock = [[NSConditionLock alloc] initWithCondition:1];
    }
    return self;
}

- (void)otherTest {
    [[[NSThread alloc] initWithTarget:self selector:@selector(__one) object:nil] start];
    
    [[[NSThread alloc] initWithTarget:self selector:@selector(__two) object:nil] start];
    
    [[[NSThread alloc] initWithTarget:self selector:@selector(__three) object:nil] start];
}

- (void)__one {
    [self.conditionLock lockWhenCondition:1];
    
    NSLog(@"__one");
    sleep(1);
    
    [self.conditionLock unlockWithCondition:2];
}

- (void)__two {
    [self.conditionLock lockWhenCondition:2];
    
    NSLog(@"__two");
    sleep(1);
    
    [self.conditionLock unlockWithCondition:3];
}

- (void)__three {
    [self.conditionLock lockWhenCondition:3];
    
    NSLog(@"__three");
    
    [self.conditionLock unlock];
}

```
- 执行结果

![image](https://upload-images.jianshu.io/upload_images/1653926-c179931160d4bcd5.png?imageMogr2/auto-orient/strip|imageView2/2/w/998)

##### dispatch_queue
- 直接使用GCD的串行队列，也是可以实现线程同步的

![image](https://upload-images.jianshu.io/upload_images/1653926-d43b964b97ab65c8.png?imageMogr2/auto-orient/strip|imageView2/2/w/847)

- 代码例子如下

```
@property (strong, nonatomic) dispatch_queue_t ticketQueue;

self.ticketQueue = dispatch_queue_create("ticketQueue", DISPATCH_QUEUE_SERIAL);

- (void)__saleTicket {
    dispatch_sync(self.ticketQueue, ^{
        [super __saleTicket];
    });
}
```

##### dispatch_semaphore
- semaphore叫做信号量
- 信号量的初始值，可以用来控制线程并发访问的最大数量
- 信号量的初始值为1，代表同时只允许1条线程访问资源，保证线程同步

![image](https://upload-images.jianshu.io/upload_images/1653926-aa2f430448fe4d91.png?imageMogr2/auto-orient/strip|imageView2/2/w/669)

- 代码例子如下

```
@property (strong, nonatomic) dispatch_semaphore_t ticketSemaphore;
@property (strong, nonatomic) dispatch_semaphore_t moneySemaphore;

self.ticketSemaphore = dispatch_semaphore_create(1);
self.moneySemaphore = dispatch_semaphore_create(1);

- (void)__drawMoney {
    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);
    
    [super __drawMoney];
    
    dispatch_semaphore_signal(self.moneySemaphore);
}

- (void)__saveMoney {
    dispatch_semaphore_wait(self.moneySemaphore, DISPATCH_TIME_FOREVER);
    
    [super __saveMoney];
    
    dispatch_semaphore_signal(self.moneySemaphore);
}

- (void)__saleTicket {
    dispatch_semaphore_wait(self.ticketSemaphore, DISPATCH_TIME_FOREVER);
    
    [super __saleTicket];
    
    dispatch_semaphore_signal(self.ticketSemaphore);
}
```

##### @synchronized
- @synchronized是对mutex递归锁的封装
- 源码查看：objc4中的objc-sync.mm文件
- @synchronized(obj)内部会生成obj对应的递归锁，然后进行加锁、解锁操作

```
@synchronized(obj) {
    任务
}
```
- obj 可以是同一个实例对象，类对象，静态变量
- 代码例子如下

```
- (void)__drawMoney {
    @synchronized([self class]) {
        [super __drawMoney];
    }
}

- (void)__saveMoney {
    @synchronized([self class]) { // objc_sync_enter
        [super __saveMoney];
    } // objc_sync_exit
}

- (void)__saleTicket {
    static NSObject *lock;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        lock = [[NSObject alloc] init];
    });
    
    @synchronized(lock) {
        [super __saleTicket];
    }
}

// 递归锁 - 可以递归
- (void)otherTest {
    @synchronized([self class]) {
        NSLog(@"123");
        [self otherTest];
    }
}
```


### 5.NSThread相关知识？
- NSThread创建线程，有三种创建方式：
    * init方式
    * detachNewThreadSelector创建好之后自动启动
    * performSelectorInBackground创建好之后也是直接启动

```
/** 方法一，需要start */
NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething1:) object:@"NSThread1"];
// 线程加入线程池等待CPU调度，时间很快，几乎是立刻执行
[thread1 start];
    
/** 方法二，创建好之后自动启动 */
[NSThread detachNewThreadSelector:@selector(doSomething2:) toTarget:self withObject:@"NSThread2"];
    
/** 方法三，隐式创建，直接启动 */
[self performSelectorInBackground:@selector(doSomething3:) withObject:@"NSThread3"];

- (void)doSomething1:(NSObject *)object {
    // 传递过来的参数
    NSLog(@"%@",object);
    NSLog(@"doSomething1：%@",[NSThread currentThread]);
}

- (void)doSomething2:(NSObject *)object {
    NSLog(@"%@",object);
    NSLog(@"doSomething2：%@",[NSThread currentThread]);
}

- (void)doSomething3:(NSObject *)object {
    NSLog(@"%@",object);
    NSLog(@"doSomething3：%@",[NSThread currentThread]);
}
```
- NSThread的类方法
- 返回当前线程

```
// 当前线程
[NSThread currentThread];
NSLog(@"%@",[NSThread currentThread]);

// 如果number=1，则表示在主线程，否则是子线程
打印结果：<NSThread: 0x608000261380>{number = 1, name = main}
```
- 阻塞休眠

```
//休眠多久
[NSThread sleepForTimeInterval:2];
//休眠到指定时间
[NSThread sleepUntilDate:[NSDate date]];
```
- 类方法补充

```
//退出线程
[NSThread exit];
//判断当前线程是否为主线程
[NSThread isMainThread];
//判断当前线程是否是多线程
[NSThread isMultiThreaded];
//主线程的对象
NSThread *mainThread = [NSThread mainThread];
```
- NSThread的一些属性

```
//线程是否在执行
thread.isExecuting;
//线程是否被取消
thread.isCancelled;
//线程是否完成
thread.isFinished;
//是否是主线程
thread.isMainThread;
//线程的优先级，取值范围0.0到1.0，默认优先级0.5，1.0表示最高优先级，优先级高，CPU调度的频率高
 thread.threadPriority;
```

### 6.GCD 相关知识？
- GCD的特点
    * GCD会自动利用更多的CPU内核
    * GCD自动管理线程的生命周期（创建线程，调度任务，销毁线程等）
    * 程序员只需要告诉 GCD 想要如何执行什么任务，不需要编写任何线程管理代码
- GCD的基本概念
    * 任务（block）：任务就是将要在线程中执行的代码，将这段代码用block封装好，然后将这个任务添加到指定的执行方式（同步执行和异步执行），等待CPU从队列中取出任务放到对应的线程中执行。
    * 同步（sync）：一个接着一个，前一个没有执行完，后面不能执行，不开线程。
    * 异步（async）：开启多个新线程，任务同一时间可以一起执行。异步是多线程的代名词
    * 队列：装载线程任务的队形结构。(系统以先进先出的方式调度队列中的任务执行)。在GCD中有两种队列：串行队列和并发队列。
    * 并发队列：线程可以同时一起进行执行。实际上是CPU在多条线程之间快速的切换。（并发功能只有在异步（dispatch_async）函数下才有效）
    * 串行队列：线程只能依次有序的执行。
    * GCD总结：将任务(要在线程中执行的操作block)添加到队列(自己创建或使用全局并发队列)，并且指定执行任务的方式(异步dispatch_async，同步dispatch_sync)
- 队列的创建方法
    * 使用dispatch_queue_create来创建队列对象，传入两个参数，第一个参数表示队列的唯一标识符，可为空。第二个参数用来表示串行队列（DISPATCH_QUEUE_SERIAL）或并发队列（DISPATCH_QUEUE_CONCURRENT）。

```
// 串行队列
dispatch_queue_t queue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
// 并发队列
dispatch_queue_t queue1 = dispatch_queue_create("test", DISPATCH_QUEUE_CONCURRENT);
```
- GCD的队列还有另外两种：
    * 主队列：主队列负责在主线程上调度任务，如果在主线程上已经有任务正在执行，主队列会等到主线程空闲后再调度任务。通常是返回主线程更新UI的时候使用。dispatch_get_main_queue()

```
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // 耗时操作放在这里
        
        dispatch_async(dispatch_get_main_queue(), ^{
            // 回到主线程进行UI操作
            
        });
    });
```
- 
    * 全局并发队列：全局并发队列是就是一个并发队列，是为了让我们更方便的使用多线程。dispatch_get_global_queue(0, 0)

```
//全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
//全局并发队列的优先级
#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高优先级
#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）优先级
#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低优先级
#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台优先级
//iOS8开始使用服务质量，现在获取全局并发队列时，可以直接传0
dispatch_get_global_queue(0, 0);
```
- 同步/异步/任务、创建方式
    * 同步（sync）使用dispatch_sync来表示。
    * 异步（async）使用dispatch_async。
    * 任务就是将要在线程中执行的代码，将这段代码用block封装好。

```
    // 同步执行任务
    dispatch_sync(dispatch_get_global_queue(0, 0), ^{
        // 任务放在这个block里
        NSLog(@"我是同步执行的任务");

    });
    // 异步执行任务
    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        // 任务放在这个block里
        NSLog(@"我是异步执行的任务");

    });
```
- GCD的使用：由于有多种队列（串行/并发/主队列）和两种执行方式（同步/异步），所以他们之间可以有多种组合方式。
    * 串行同步：执行完一个任务，再执行下一个任务。不开启新线程。
    * 串行异步：开启新线程，但因为任务是串行的，所以还是按顺序执行任务。
    * 并发同步：因为是同步的，所以执行完一个任务，再执行下一个任务。不会开启新线程。
    * 并发异步：任务交替执行，开启多线程。
    * 主队列同步：如果在主线程中运用这种方式，则会发生死锁，程序崩溃。
        * 主队列同步造成死锁的原因：如果在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。而同步对于任务是立刻执行的，那么当把第一个任务放进主队列时，它就会立马执行。可是主线程现在正在处理syncMain方法，任务需要等syncMain执行完才能执行。syncMain执行到第一个任务的时候，又要等第一个任务执行完才能往下执行第二个和第三个任务。这样syncMain方法和第一个任务就开始了互相等待，形成了死锁。
    * 主队列异步：在主线程中任务按顺序执行。

### 7.说一下 GCD 并发队列实现机制
- Dispatch queue是一个对象，它可以接收任务，并将任务以先到先执行的顺序来执行。
- Dispatch queue可以使并发的或串行的。并发任务会基于系统负载来合适地并发执行，串行队列同一时间只执行单一任务。
- GCD共有三种队列类型：
    * mainqueue：通过dispatch_get_main_queue()获得，这是一个与主线程相关的串行队列。
    * global queue：全局队列是并发队列，由整个进程共享。存在着高、中、低三种优先级的全局队列。调用dispath_get_global_queue并传入优先级来访问队列。
    * 用户队列：通过函数dispatch_queue_create创建的队列，这些队列是串行的。
- 串行队列，一次只执行一个任务，在队列中采用先入先出的方式从runloop中取出任务
- 并发队列，可一次性执行多个任务，同样也是采用先入先出的方式取出任务，但是利用多线程来实现并发

### 8.GCD的并行队列一定会开辟新的线程？
- 同步执行:在GCD里是sync,不会开启新线程,只会在当前线程进行操作.
- 异步执行:在GCD里是async,可以另外开启一个新的线程执行任务.

### 9.如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）
- 使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。

```
-(void)test
{
    //获取并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    //获取组
    dispatch_group_t group = dispatch_group_create();
    
    dispatch_group_async(group, queue, ^{

        NSLog(@"线程：%@--加载图片1", [NSThread currentThread]);
        });
    
    dispatch_group_async(group, queue, ^{
        
      NSLog(@"线程：%@--加载图片2", [NSThread currentThread]);;
    });
    
    dispatch_group_async(group, queue, ^{
        
        NSLog(@"线程：%@--加载图片3", [NSThread currentThread]);
    });
    
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
      
      NSLog(@"线程：%@--合并图片", [NSThread currentThread]);
    });
    
}
```

### 10.GCD的一些常用的函数？（group，barrier，信号量，线程同步）
- Grand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的Dispatch Queue中，GCD就能生成必要的线程并计划执行任务。由于线程管理是作为系统的一部分来实现的，因此可统一管理，也可执行任务，这样就比以前的线程更有效率
-dispatch_group_t（队列组）
    * dispatch_group是GCD的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知。常用场景比如说，下载一个大的文件，分块下载，全部下载完成后再合成一个文件。再比如同时下载多个图片，监听全部下载完后的动作
    * 创建group
        * dispatch_group_t group = dispatch_group_create();
    * 添加任务
        * dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 将一个任务添加到指定group中
        * dispatch_group_enter(dispatch_group_t group); dispatch_group_leave(dispatch_group_t group);这两个函数同上边一样的效果，不过一定要注意这两个函数必须成对出现！否则这一组任务就永远执行不完。
    * 监听任务完成
        * timeout参数表示函数在等待dispatch group执行完毕后，应该阻塞多久。如果执行dispatch group所需的时间小于timeout，则返回0，否则返回非0值.此参数可以取常量DISPATCH_TIME_FOREVER，这表示函数会一直等着dispatch group 执行完，而不会超时。此方法会阻塞线程。
            * dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block); 开发者可以传入block，等dispatch group 执行完毕之后，块会在特定的线程上执行，而不阻塞线程。
            * long dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout);
方式一：
```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{

    //创建一个队列组
    dispatch_group_t group = dispatch_group_create();

    //创建两个不同的队列来测试
    dispatch_queue_t queue1 = dispatch_get_global_queue(0, 0);

    dispatch_queue_t queue2 = dispatch_queue_create("yuxuan", DISPATCH_QUEUE_CONCURRENT);

    //dispatch_group_async 异步函数
    //系统会先把任务放入队列中,然后把队列放入组中
    //从组中把队列取出来,在从队列里取任务执行
    dispatch_group_async(group, queue1, ^{
    [NSThread sleepForTimeInterval:1.0];
        NSLog(@"download 1");
    });

    dispatch_group_async(group, queue2, ^{
        [NSThread sleepForTimeInterval:1.0];
        NSLog(@"download 2");
    });
    //给group添加一个通知,异步函数
    //当group队列中所有任务执行完毕,就会通知group执行block
    /*
     * 第一个参数: 为那个队列组添加通知
     * 第二个参数: 决定block在什么线程中执行
     * 第三个参数: block 代码块
     */
    dispatch_group_notify(group, dispatch_queue_create("yuxuan1",DISPATCH_QUEUE_CONCURRENT), ^{
        NSLog(@"OK");
    });
   NSLog(@"end");
}

```
方式二：

```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    /*
     dispatch_group_async底层实现:
     void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
     {
         dispatch_retain(group);
         dispatch_group_enter(group);
         dispatch_async(queue, ^{
             block();
             dispatch_group_leave(group);
             dispatch_release(group);
         });
     }
     */
    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);

    //创建一个队列组
    dispatch_group_t group =  dispatch_group_create();

    //通知队列组进入队列组
    dispatch_group_enter(group);

    dispatch_async(queue, ^{
        NSLog(@"111");
        //任务执行完毕
        //通知队列组离开队列组
        dispatch_group_leave(group);
    });

    //通知队列组进入队列组
    dispatch_group_enter(group);

    dispatch_async(queue, ^{
        NSLog(@"222");
        //任务执行完毕
        //通知队列组离开队列组
        dispatch_group_leave(group);
    });

    //等待所有任务执行完毕,一直等待.会阻塞线程
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);

    //    dispatch_group_notify(group, queue, ^{
    //        NSLog(@"over");
    //    });
}

```


例子：从网络上下载两张图片，把两张图片合并成一张最终显示在view上。

方法一：
```
 //  04-GCD基本使用（队列组下载图片）
 //
 //  Created by apple on 14-6-25.
 //  Copyright (c) 2014年 itcase. All rights reserved.
 //
 
 #import "YYViewController.h"
 //宏定义全局并发队列
 #define global_quque    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
 //宏定义主队列
 #define main_queue       dispatch_get_main_queue()
 
 @interface YYViewController ()
 @property (weak, nonatomic) IBOutlet UIImageView *imageView1;
 @property (weak, nonatomic) IBOutlet UIImageView *imageView2;
 @property (weak, nonatomic) IBOutlet UIImageView *imageView3;
 
 @end
 
 @implementation YYViewController
 
 - (void)viewDidLoad
 {
     [super viewDidLoad];
 }
 -(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
 {
     //获取全局并发队列
 //    dispatch_queue_t queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
     //获取主队列
 //    dispatch_queue_t queue= dispatch_get_main_queue();
     
 //    图片1：http://d.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2b9a12172df5e0fefa1581533d095fcd/cefc1e178a82b9019115de3d738da9773912ef00.jpg
 //    图片2：http://h.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f47fd63ca41ea8d39e2f7c56f6635b2b/1e30e924b899a9018b8d3ab11f950a7b0308f5f9.jpg
     dispatch_async(global_quque, ^{
         //下载图片1
        UIImage *image1= [self imageWithUrl:@"http://d.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2b9a12172df5e0fefa1581533d095fcd/cefc1e178a82b9019115de3d738da9773912ef00.jpg"];
         NSLog(@"图片1下载完成---%@",[NSThread currentThread]);
     
         //下载图片2
        UIImage *image2= [self imageWithUrl:@"http://h.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f47fd63ca41ea8d39e2f7c56f6635b2b/1e30e924b899a9018b8d3ab11f950a7b0308f5f9.jpg"];
         NSLog(@"图片2下载完成---%@",[NSThread currentThread]);
         
         //回到主线程显示图片
         dispatch_async(main_queue, ^{
              NSLog(@"显示图片---%@",[NSThread currentThread]);
             self.imageView1.image=image1;
             self.imageView2.image=image2;
             //合并两张图片
             UIGraphicsBeginImageContextWithOptions(CGSizeMake(200, 100), NO, 0.0);
             [image1 drawInRect:CGRectMake(0, 0, 100, 100)];
             [image2 drawInRect:CGRectMake(100, 0, 100, 100)];
             self.imageView3.image=UIGraphicsGetImageFromCurrentImageContext();
             //关闭上下文
             UIGraphicsEndImageContext();
                NSLog(@"图片合并完成---%@",[NSThread currentThread]);
         });
         //
     });
 }
 
 //封装一个方法，传入一个url参数，返回一张网络上下载的图片
 -(UIImage *)imageWithUrl:(NSString *)urlStr
 {
     NSURL *url=[NSURL URLWithString:urlStr];
     NSData *data=[NSData dataWithContentsOfURL:url];
     UIImage *image=[UIImage imageWithData:data];
     return image;
 }
 @end
```
方法二：使用队列组
步骤：

创建一个组

开启一个任务下载图片1

 开启一个任务下载图片2

同时执行下载图片1\下载图片2操作

等group中的所有任务都执行完毕, 再回到主线程执行其他操作

```
//
//  04-GCD基本使用（队列组下载图片）
//
//  Created by apple on 14-6-25.
//  Copyright (c) 2014年 itcase. All rights reserved.
//

#import "YYViewController.h"
//宏定义全局并发队列
#define global_quque    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
//宏定义主队列
#define main_queue       dispatch_get_main_queue()
 
@interface YYViewController ()
@property (weak, nonatomic) IBOutlet UIImageView *imageView1;
@property (weak, nonatomic) IBOutlet UIImageView *imageView2;
@property (weak, nonatomic) IBOutlet UIImageView *imageView3;

@end

@implementation YYViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
}
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event
{
    //    图片1：http://d.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2b9a12172df5e0fefa1581533d095fcd/cefc1e178a82b9019115de3d738da9773912ef00.jpg
   //    图片2：http://h.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f47fd63ca41ea8d39e2f7c56f6635b2b/1e30e924b899a9018b8d3ab11f950a7b0308f5f9.jpg
    
    
    //1.创建一个队列组
         dispatch_group_t group = dispatch_group_create();
     
    //2.开启一个任务下载图片1
    __block UIImage *image1=nil;
    dispatch_group_async(group, global_quque, ^{
        image1= [self imageWithUrl:@"http://d.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=2b9a12172df5e0fefa1581533d095fcd/cefc1e178a82b9019115de3d738da9773912ef00.jpg"];
         NSLog(@"图片1下载完成---%@",[NSThread currentThread]);
     });
    
     //3.开启一个任务下载图片2
    __block UIImage *image2=nil;
    dispatch_group_async(group, global_quque, ^{
        image2= [self imageWithUrl:@"http://h.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=f47fd63ca41ea8d39e2f7c56f6635b2b/1e30e924b899a9018b8d3ab11f950a7b0308f5f9.jpg"];
        NSLog(@"图片2下载完成---%@",[NSThread currentThread]);
    });
    
   //同时执行下载图片1\下载图片2操作
    
   //4.等group中的所有任务都执行完毕, 再回到主线程执行其他操作
    dispatch_group_notify(group,main_queue, ^{
        NSLog(@"显示图片---%@",[NSThread currentThread]);
         self.imageView1.image=image1;
         self.imageView2.image=image2;
         
         //合并两张图片
         //注意最后一个参数是浮点数（0.0），不要写成0。
        UIGraphicsBeginImageContextWithOptions(CGSizeMake(200, 100), NO, 0.0);
         [image1 drawInRect:CGRectMake(0, 0, 100, 100)];
         [image2 drawInRect:CGRectMake(100, 0, 100, 100)];
         self.imageView3.image=UIGraphicsGetImageFromCurrentImageContext();
         //关闭上下文
         UIGraphicsEndImageContext();
         
        NSLog(@"图片合并完成---%@",[NSThread currentThread]);
    });
    
 }
 -(void)download2image
 {
     //获取全局并发队列
 //    dispatch_queue_t queue= dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
     //获取主队列
 //    dispatch_queue_t queue= dispatch_get_main_queue();
     
     dispatch_async(global_quque, ^{
        //下载图片1
        UIImage *image1= [self imageWithUrl:@"http://news.baidu.com/z/resource/r/image/2014-06-22/2a1009253cf9fc7c97893a4f0fe3a7b1.jpg"];
        NSLog(@"图片1下载完成---%@",[NSThread currentThread]);
    
        //下载图片2
       UIImage *image2= [self imageWithUrl:@"http://news.baidu.com/z/resource/r/image/2014-06-22/2a1009253cf9fc7c97893a4f0fe3a7b1.jpg"];
        NSLog(@"图片2下载完成---%@",[NSThread currentThread]);
        
        //回到主线程显示图片
        dispatch_async(main_queue, ^{
             NSLog(@"显示图片---%@",[NSThread currentThread]);
            self.imageView1.image=image1;
            self.imageView2.image=image2;
            //合并两张图片
            UIGraphicsBeginImageContextWithOptions(CGSizeMake(200, 100), NO, 0.0);
            [image1 drawInRect:CGRectMake(0, 0, 100, 100)];
            [image2 drawInRect:CGRectMake(0, 0, 100, 100)];
            self.imageView3.image=UIGraphicsGetImageFromCurrentImageContext();
            //关闭上下文
            UIGraphicsEndImageContext();
               NSLog(@"图片合并完成---%@",[NSThread currentThread]);
        });
        //
    });
 }

//封装一个方法，传入一个url参数，返回一张网络上下载的图片
-(UIImage *)imageWithUrl:(NSString *)urlStr
{
   NSURL *url=[NSURL URLWithString:urlStr];
    NSData *data=[NSData dataWithContentsOfURL:url];
    UIImage *image=[UIImage imageWithData:data];
    return image;
 }
 @end
```
- dispatch_barrier_async/dispatch_barrier_sync（栅栏函数）
    * 作用：与并发队列结合，可以高效率的避免数据竞争的问题
    * 相同点：dispatch_barrier_sync和dispatch_barrier_async函数功能一样就是在并发队列中将此代码插入的地方上下隔开，如果栅栏一样，两部分不影响。只有上边的并发队列都执行结束之后，下边的并发队列才能够执行。
    * 不同点:dispatch_barrier_sync代码后边的任务直到dispatch_barrier_sync执行完才能被追加到队列中；dispatch_barrier_async不用代码执行完，后边的任务也会被追加到队列中。代码上的体现就是dispatch_barrier_sync后边的代码不会执行，dispatch_barrier_async后边的代码会执行，但是Block不会被执行。
    * dispatch_barrier_async
        * dispatch_async将指定的Block异步的追加到指定的Dispatch Queue中。dispatch_async函数不会做任何等待
        * dispatch_async代表异步任务，意思不是一定会生成一条线程。如果在MainQueue中执行，则不会生成线程；如果在Global Queue中有可能会生成。因为线程有一个线程池，会重用已经完成任务了的线程。
    * dispatch_barrier_sync
        * dispatch_sync将指定的Block同步的追加到指定的Dispatch Queue。此时dispatch_sync会一直等待Block执行结束之后，才会返回。线程才能接着继续执行其他代码。
        * 当前queue是串行队列。 当前queue上调用sync函数，并且sync函数中指定的queue也是当前queue。需要执行的block被放到当前queue的队尾等待执行，因为这是一个串行的queue，调用sync函数会阻塞当前队列,等待block执行 这个block永远没有机会执行sync函数不返回，所以当前队列就永远被阻塞了，这就造成了死锁。（这就是问题中在主线程调用sync函数，并且在sync函数中传入main_queue作为queue造成死锁的情况）
        * 当前queue是并行队列。 在并行的queue上面调用sync函数，同时传入当前queue作为参数，并不会造成死锁，因为block会马上被执行，所以sync函数也不会一直等待不返回造成死锁。（并且Block是在当前线程上执行。例如如果是在主线程上调用了dispatch_sync,则Block是在主线程上执行的）
例子：

```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{

   dispatch_queue_t queue = dispatch_queue_create("yuxuan", DISPATCH_QUEUE_CONCURRENT);

   dispatch_async(queue, ^{
       NSLog(@"任务1");
   });

    dispatch_async(queue, ^{
       NSLog(@"任务2");
    });

    //栅栏函数(同步函数就没必要控制顺序了,因为它是有序的)
            //dispatch_barrier_async 是异步函数不会阻塞线程
            //dispatch_barrier_sync 是同步函数 会阻塞线程
    //如果所有任务都在同一个并行队列中,并且这个并行队列不是系统自带全局并行队列
    //哪么在barrier之前添加的方法会先被执行,只有等barrier之前的任务执行完毕后才会执行barrier任务
    //只有barrier任务执行完毕后,才会执行后添加的任务
    dispatch_barrier_async(queue, ^{
        NSLog(@"我是个可爱的路障");
    });

    dispatch_async(queue, ^{
       NSLog(@"任务3");
    });

    dispatch_async(queue, ^{
       NSLog(@"任务4");
    });

    NSLog(@"end");
}

```
- 信号量
    * 就是一种可用来控制访问资源的数量的标识，设定了一个信号量，在线程访问之前，加上信号量的处理，则可告知系统按照我们指定的信号量数量来执行多个线程。
    * 其实，这有点类似锁机制了，只不过信号量都是系统帮助我们处理了，我们只需要在执行线程之前，设定一个信号量值，并且在使用时，加上信号量处理方法就行了。
    * 信号量主要有3个函数，分别是：
        * dispatch_semaphore_create（信号量值）//创建信号量，参数：信号量的初值，如果小于0则会返回NULL
        * dispatch_semaphore_wait（信号量，等待时间）//等待降低信号量
        * dispatch_semaphore_signal(信号量)//提高信号量
        * 注意，正常的使用顺序是先降低然后再提高，这两个函数通常成对使用。
- 线程同步
    * 我们使用GCD的时候如何让线程同步，目前我能想到的就三种
        * dispatch_group
        * dispatch_barrier
        * dispatch_semaphore
- dispatch_group
    * 用户下载一个图片，图片很大，需要分成很多份进行下载，
    * 使用Dispatch Group追加block到Global Group Queue，这些block如果全部执行完毕，就会执行通过dispatch_group_notify添加到主队列中的block，进行图片的合并处理。
        
```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片… …
});
```

- dispatch_barrier
    * 通过dispatch_barrier_async添加的操作会暂时阻塞当前队列，即等待前面的并发操作都完成后执行该阻塞操作，待其完成后后面的并发操作才可继续。可以将其比喻为一根霸道的独木桥，是并发队列中的一个并发障碍点，或者说中间瓶颈，临时阻塞并独占。注意dispatch_barrier_async只有在并发队列中才能起作用，在串行队列中队列本身就是独木桥，将失去其意义。
    * 可见使用dispatch_barrier_async可以实现类似dispatch_group_t组调度的效果,同时主要的作用是避免数据竞争，高效访问数据。
    
```
/* 创建并发队列 */
dispatch_queue_t concurrentQueue = dispatch_queue_create("test.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);
/* 添加两个并发操作A和B，即A和B会并发执行 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationA");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationB");
});
/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */
dispatch_barrier_async(concurrentQueue, ^(){
    NSLog(@"OperationBarrier!");
});
/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationC");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationD");
});
```

- dispatch_semaphore
    * 信号量机制主要是通过设置有限的资源数量来控制线程的最大并发数量以及阻塞线程实现线程同步等。
    * 使用信号量实现任务2依赖于任务1，即任务2要等待任务1结束才开始执行
    * 方法很简单，创建信号量并初始化为0，让任务2执行前等待信号，实现对任务2的阻塞。然后在任务1完成后再发送信号，从而任务2获得信号开始执行。需要注意的是这里任务1和2都是异步提交的，如果没有信号量的阻塞，任务2是不会等待任务1的,实际上这里使用信号量实现了两个任务的同步。
    
```
/* 创建一个信号量 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

/* 任务1 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 耗时任务1 */
    NSLog(@"任务1开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务1结束");
    /* 任务1结束，发送信号告诉任务2可以开始了 */
    dispatch_semaphore_signal(semaphore);
});

/* 任务2 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 等待任务1结束获得信号量, 无限等待 */
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    /* 如果获得信号量则开始任务2 */
    NSLog(@"任务2开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务2结束");
});
[NSThread sleepForTimeInterval:10];
```
- 通过信号量控制最大并发数量：
    * 通过信号量控制最大并发数量的方法为：创建信号量并初始化信号量为想要控制的最大并发数量，例如想要保证最大并发数为5，则信号量初始化为5。然后在每个新任务执行前进行P操作，等待信号使信号量减1；每个任务结束后进行V操作，发送信号使信号量加1。这样即可保证信号量始终在5以内，当前最多也只有5个以内的任务在并发执行。
    
```
/* 创建一个信号量并初始化为5 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(5);

/* 模拟1000个等待执行的任务，通过信号量控制最大并发任务数量为5 */
for (int i = 0; i < 1000; i++) {
    /* 任务i */
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        /* 耗时任务1，执行前等待信号使信号量减1 */
        dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
        NSLog(@"任务%d开始", i);
        [NSThread sleepForTimeInterval:10];
        NSLog(@"任务%d结束", i);
        /* 任务i结束，发送信号释放一个资源 */
        dispatch_semaphore_signal(semaphore);
    });
}
[NSThread sleepForTimeInterval:1000];

打印结果为每次开启五个并发任务
2017-06-02 21:45:27.409067+0800 OC[7234:336757] 任务1开始
2017-06-02 21:45:27.409069+0800 OC[7234:336758] 任务2开始
2017-06-02 21:45:27.409103+0800 OC[7234:336759] 任务3开始
2017-06-02 21:45:27.409268+0800 OC[7234:336761] 任务4开始
2017-06-02 21:45:27.409887+0800 OC[7234:336756] 任务0开始

2017-06-02 21:45:37.415217+0800 OC[7234:336757] 任务1结束
2017-06-02 21:45:37.415370+0800 OC[7234:336759] 任务3结束
2017-06-02 21:45:37.415217+0800 OC[7234:336761] 任务4结束
2017-06-02 21:45:37.415217+0800 OC[7234:336758] 任务2结束
2017-06-02 21:45:37.415442+0800 OC[7234:336756] 任务0结束

2017-06-02 21:45:37.415544+0800 OC[7234:336760] 任务5开始
2017-06-02 21:45:37.415548+0800 OC[7234:336762] 任务6开始
2017-06-02 21:45:37.415614+0800 OC[7234:336765] 任务9开始
2017-06-02 21:45:37.415620+0800 OC[7234:336764] 任务8开始
2017-06-02 21:45:37.415594+0800 OC[7234:336763] 任务7开始

... ...
```
- 延迟函数dispatch_after(.....)

```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
NSLog(@"start");
//dispatch_after 是异步执行的
//队列只决定在哪个线程中执行任务 并不能决定执行时间
/**
 * 第一个参数: 在哪个时间点执行
 *            dispatch_time(从哪个时间点开始,经历多少纳秒)
 * 第二个参数: 在哪个队列中执行block任务
 * 第三个参数: block任务
 */
dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    NSLog(@"%@",[NSThread currentThread]);
});
NSLog(@"end");
}

```

- 定时器

```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
 //创建一个队列,创建GCD定时器时使用
  dispatch_queue_t queue = dispatch_queue_create("yuxuan", DISPATCH_QUEUE_SERIAL);
  //创建一个GCD定时器(触发器)
  //第四个参数:传入一个队列,决定了定时器回调任务执行方式.
  dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
  //dispatch_source_t其实本质是一个类,由于是局部变量,方法执行完,就会被释放.
  self.timer = timer;
  //设置定时器
  /*
   第一个参数:给那个定时器设置
   第二个参数:什么时候启动
   第三个参数:间隔多久执行一次
   第四个参数:设置精准度:0 代表最高精准(尽量让定时器精准), 大于0的的话代表是在多少秒内接受.
   第四个参数存在意义:主要是为了提高程序性能, 设置越大,能减轻CPU的压力
   注意:GCD定时器传入的时间都是纳秒
   */
  dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0.0 * NSEC_PER_SEC);
   //第一个参数:给那个定时器设置
  //第二个参数:设置定时器回调block
  //异步执行的,具有创建新线程的能力
  //具体是否创建线程,创建几条线程是由定时任务创建时,传入的queue决定的
  dispatch_source_set_event_handler(timer, ^{
      NSLog(@"%@",[NSThread currentThread]);
  });
      //启动定时器
  dispatch_resume(timer);
}

```

- 一次性执行dispatch_once(...)

```
-(void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    //一次性执行的机制,能保证在程序启动后只会执行一次,并且是线程安全的,在主线程中执行
    //一般使用dispatch_once来做一次性执行,效率高, 在单例模式中使用.
    //可以利用互斥锁在实现此功能,但不建议使用,因为效率非常低!!!!
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        NSLog(@"");
    });
}


```

### 11.GCD的队列（dispatch_queue_t）分哪两种类型？
- 串行队列Serial Dispatch Queue
- 并行队列Concurrent Dispatch Queue

### 12.dispatch_barrier_async的作用是什么？
- 栅栏函数
- 毫无疑问,dispatch_barrier_async函数的作用与barrier的意思相同,在进程管理中起到一个栅栏的作用,在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。 dispatch_barrier_async 函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等 dispatch_barrier_async 追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。
- 实现高效率的数据库访问和文件访问
- 避免数据竞争

### 13.苹果为什么要废弃dispatch_get_current_queue？
- dispatch_get_current_queue容易造成死锁。
- 在iOS6.0被删除的。
- 造成死锁的原因：
    * 可重入的概念：若一个程序或子程序可以“安全的被并行执行(Parallel computing)”，则称其为可重入（reentrant或re-entrant）的。即当该子程序正在运行时，可以再次进入并执行它。
    * 若一个函数是可重入的，则该函数：
        * 不能含有静态（全局）非常量数据
        * 不能返回静态（全局）非常量数据的地址
        * 只能处理由调用者提供的数据
        * 不能依赖于单实例模式资源的锁
        * 不能调用(call)不可重入的函数(有呼叫(call)到的函数需满足前述条件)
    * 有时候我们很希望知道当前执行的queue是谁，比如UI操作需要放在main queue中执行。如果可以知道当前工作的queue是谁，就可以很方便的指定一段代码操作在特定的queue中执行。 dispatch_get_current_queue() 正好能帮上忙。于是乎，在指定的queue中做一些操作，就可以非常清晰的实现：
    
```
void func(dispatch_queue_t queue, dispatch_block_t block)  
{  
    if (dispatch_get_current_queue() == queue) {  
        block();  
    }else{  
        dispatch_sync(queue, block);  
    }  
} 

```
    
然后潜意识里，觉得这个函数是可重入的。但当target queue恰好是current queue时，同步阻塞会导致死锁。

### 14.NSOperation 和 NSOperationQueue相关知识？
- 操作（Operation）：
    * 执行操作的意思，换句话说就是你在线程中执行的那段代码。
    * 在 GCD 中是放在 block 中的。在 NSOperation 中，使用 NSOperation子类NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。
- 操作队列（Operation Queues）：
    * 这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。
    * 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。
    * NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。

### 15.如何自定义 NSOperation ?
- 自定义NSOperation分两种，一种是自定义非并发的NSOperation，一种是定义并发的NSOperation的。

#### 定义非并发的NSOperation
- 实现main方法，在main方法中执行自定义的任务

#### 自定义并发的NSOperation
- 自定义并发的NSOperation需要以下步骤：
    * start方法：该方法必须实现，
    * main:该方法可选，如果你在start方法中定义了你的任务，则这个方法就可以不实现，但通常为了代码逻辑清晰，通常会在该方法中定 义自己的任务
    * isExecuting isFinished 主要作用是在线程状态改变时，产生适当的KVO通知
    * isConcurrent :必须覆盖并返回YES;

### 16.NSOperationQueue的优点
- NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。
- 可以添加任务依赖，方便控制执行顺序
- 可以设定操作执行的优先级
- 任务执行状态控制:isReady,isExecuting,isFinished,isCancelled如果只是重写NSOperation的main方法，由底层控制变更任务执行及完成状态，以及任务退出，如果重写了NSOperation的start方法，自行控制任务状态
系统通过KVO的方式移除isFinished==YES的NSOperation
- 可以设置最大并发量

### 17.NSOperation与GCD的关系？
- GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
- GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便
- GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序
- NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂
- NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）
- 实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选
- 如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持
- 不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销

### 18.GCD 与 NSOperationQueue 有哪些异同？
- GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
- GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便
- GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序
- NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂
- NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）
- 实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选
- 如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持
- 不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销
- 使用场合：
    * 任务之间不太相互依赖：GCD
    * 任务之间有依赖或要监听任务的执行情况：NSOperationQueue

### 19.你们项目中为什么多线程用GCD而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?
### 20.如何使用队列来避免资源抢夺？
- dispatch_barrior_async 作用是在并行队列中，等待前面两个操作并行操作完成。

### 21.dispatch_sync 和 dispatch_async 区别
- dispatch_async(queue,block) async 异步队列，dispatch_async 函数会立即返回, block会在后台异步执行。
- dispatch_sync(queue,block) sync 同步队列，dispatch_sync函数不会立即返回，及阻塞当前线程,等待 block同步执行完成。

### 22.NSLock？是否会出现死锁？
- NSLock是非递归锁，当同一线程重复获取同一非递归锁时，就会发生死锁。

```
      NSLock *m_lock;
      [m_lock lock]; // 成功上锁
      do something....
      [m_lock lock]; // 上面已经上锁，这里阻塞等待锁释放，不会再执行下面，锁永远得不到释放，即死锁
      do something....
      [m_lock unlock]; // 不会执行到
      do something....
      [m_lock unlock];

   于是，断点跟踪堆栈中相关问题函数的调用关系，企图找到如上所示的嵌套上锁代码，结果如下：
```
- 另一方面，用NSRecursiveLock或者@synchronized替代NSLock，就可以成功登录了。因为同一线程重复获取同一递归锁，不会发生死锁。

### 23.NSContion
- NSCondition的对象实际上作为一个锁和一个线程检查器，锁上之后其他线程也能上锁，而之后可以根据条件决定是否继续运行线程，即线程是否要进入waiting状态，经测试，直接进入waiting状态，当其他中线程的该锁执行signal或者broadcast方法时，线程被唤醒，继续运行之后的方法

### 24.条件锁 - NSContionLock]
- NSConditionLock状语从句：NSLock类似，遵循都NSLocking协议，方法都类似，多只是一个了condition属性，每个以及操作都多了一个关于condition属性的方法，例如tryLock，tryLockWhenCondition:，NSConditionLock可以称为条件锁，只有condition参数与初始化时候的condition相等，lock才能正确进行加锁操作。而unlockWithCondition:并非当Condition符合条件时才解锁，否则解锁之后，修改Condition的值

### 25.递归锁 - NSRecursiveLock
- NSRecursiveLock是递归归锁，他和NSLock的区别在于，NSRecursiveLock可以在一个线程中重复加锁（反正单线程内部任务是按顺序执行的，不会出现资源竞争问题），NSRecursiveLock会记录上锁和解锁的次数，当两者平衡的时候，才会释放锁，其他线程才可以上锁成功。

### 26.同步锁 - Synchronized(self) {// code}
- 一些注意事项:
    * @synchronized既是互斥锁也是递归锁
    * @synchronized(NSObject) 括号里可以是任意NSObject, 一般传入VC的self
    * @synchronized(NSObject) 只有当NSObject是同一个时, 才满足互斥
如果在@synchronized(NSObject) 内部 NSObject 被释放或被设为 nil, 不影响结果; 但如果 NSObject 一开始就是 nil, 则失去了锁的功能
    * @synchronized会自动释放互斥锁
    * @synchronized很耗性能, 应谨慎使用

### 27.信号量 - dispatch_semaphore
- 如果获取不到`锁`，重置当前线程中断，暂停，直到其他线程释放`锁`时，会唤醒当前线程。

### 28.自旋锁 - OSSpinLock
- 是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。
在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。
- 自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。

### 29.互斥锁
- 当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。
- 互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。

### 30.互斥锁和自旋锁区别及应用场景
 - 互斥锁会休眠:    
    * 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。
- 自旋锁会忙等:                              
    * 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。
- 什么情况使用自旋锁比较划算？
    * 预计线程等待锁的时间很短
    * 加锁的代码（临界区）经常被调用，但竞争情况很少发生
    * CPU资源不紧张
    * 多核处理器
- 什么情况使用互斥锁比较划算？
    * 预计线程等待锁的时间较长
    * 单核处理器
    * 临界区有IO操作
    * 临界区代码复杂或者循环量大
    * 临界区竞争非常激烈

### 31.多功能锁 - pthread_mutex
- 如果函数存在递归调用,那么重复pthread_mutex_lock()加锁会导致死锁. 我们可以改变初始化时的属性, 将锁类型改为递归锁.
- 锁的默认属性是PTHREAD_MUTEX_NORMAL,不能用于递归实现.
- 将属性改成PTHREAD_MUTEX_RECURSIVE后称为递归锁.

### 32.分步锁 - NSDistributedLock
- 在引用计数表的数据结构里，一张sideTable表利用分离锁被分成了多个部分。
- 这样可以对一张表的多个部分，同时进行操作，提升了效率

### 33.如何确保线程安全？
- 加锁

### 34.NSMutableArray、和 NSMutableDictionary是线程安全的吗？NSCache呢？
- 在做缓存时，优先使用NSCache而不是NSDictionary，我们熟悉的框架SDWebimage就是采用的NSCache。
- NSCache 优点如下：
    * 系统资源将要减少时，它可以自动减少减去缓存。
    * 可以设置最大缓存数量。
    * 可以设置最大占用内存值。
    * NSCache 线程是安全的

### 35.解释一下多线程中的死锁？
- 死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：
    * 互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
    * 请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
    * 不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
    * 环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

### 36.列举几种进程的同步机制、进程的通信途径、死锁及死锁的处理方法。
- 死锁：死锁就是队列引起的循环等待
    * 主队列同步，在主线程中运用主队列同步，也就是把任务放到了主线程的队列中。同步对于任务是立刻执行的，那么当把任务放进主队列时，它就会立马执行,只有执行完这个任务，viewDidLoad才会继续向下执行。而viewDidLoad和任务都是在主队列上的，由于队列的先进先出原则，任务又需等待viewDidLoad执行完毕后才能继续执行，viewDidLoad和这个任务就形成了相互循环等待，就造成了死锁。
想避免这种死锁，可以将同步改成异步dispatch_async,或者将dispatch_get_main_queue换成其他串行或并行队列，都可以解决。

### 37.子线程是否会出现死锁？说一下场景？
### 38.请说明同步请求与异步请求的区别?
- 同步请求：使用主线程一次性获得所有请求数据，这就导致一个比较容易出现的问题，当请求的数据比较大时，就会出现卡顿现象，也就是阻塞主线程
- 异步请求：异步请求就是再创建一个线程，使用这个线程进行请求数据，逐步请求数据，这样就可以不断获得数据然后进行界面更新，不至于造成卡顿现象

### 39.默认最大并发？
- dispatch_semaphore_creat SignalCount = dispatch_semaphore_creat(10).
- 这个地方后面的这个10，是一个整数，可以是1，2，3，。。。表示在信号等待的时候，下一次收到的的信号量，说白了，就是这个数字控制的最大并发数。
- 队列的最大并发数控制在10。

### 补充：FMDB如何保证线程安全
- FMDatabaseQueue队列采用单例，只创建一个实例对象
- FMDB内部如何保证线程安全
- 采用 GCD 的串行队列实现的，内部实现如下

```
- (void)inDatabase:(__attribute__((noescape)) void (^)(FMDatabase *db))block {
#ifndef NDEBUG
    /* Get the currently executing queue (which should probably be nil, but in theory could be another DB queue
     * and then check it against self to make sure we're not about to deadlock. */
    FMDatabaseQueue *currentSyncQueue = (__bridge id)dispatch_get_specific(kDispatchQueueSpecificKey);
    assert(currentSyncQueue != self && "inDatabase: was called reentrantly on the same queue, which would lead to a deadlock");
#endif
    
    FMDBRetain(self);
    
    dispatch_sync(_queue, ^() {
        
        FMDatabase *db = [self database];
        
        block(db);
        
        if ([db hasOpenResultSets]) {
            NSLog(@"Warning: there is at least one open result set around after performing [FMDatabaseQueue inDatabase:]");
            
#if defined(DEBUG) && DEBUG
            NSSet *openSetCopy = FMDBReturnAutoreleased([[db valueForKey:@"_openResultSets"] copy]);
            for (NSValue *rsInWrappedInATastyValueMeal in openSetCopy) {
                FMResultSet *rs = (FMResultSet *)[rsInWrappedInATastyValueMeal pointerValue];
                NSLog(@"query: '%@'", [rs query]);
            }
#endif
        }
    });
    
    FMDBRelease(self);
}
```

### 40.dispatch_once如何实现一次性代码？
- 单例模式（singleton）对Objective-C开发者来说并不陌生，常见的实现方式为：在类中编写名为sharedInstance的方法，该方法只会返回全类共用的单例实例，而不会在每次调用时都创建新的实例。共享实例的方法一般又会这样写：

```
@implementation EOCClass

+ (instancetype)sharedInstance
{
    static EOCClass *sharedInstance = nil;
    @synchronized (self) {
        if (!sharedInstance) {
            sharedInstance = [[self alloc] init];
        }
    }
    return sharedInstance;
}
@end
```
- 不过GCD引入了一项特性，能使单例实现起来更为容易。所用的函数是：

```
void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);
```
- 此函数接受类型为dispatch_once_t的特殊参数，笔者称其为“标记”（token），此外还接受参数。对于给定的标记来说，该函数保证相关的块必定会执行，且仅执行一次。首次调用该函数时，必然会执行块中的代码，最重要的一点在于，此操作完全是线程安全的。请注意，对于只需执行一次的块来说，每次调用函数时传入的标记都必须完全相同。因此，开发者通常将标记变量声明在static或global作用域里。
- 刚才实现单例模式所用的sharedInstance方法，可以用此函数来改写：

```
+ (instancetype)sharedInstance
{
    static EOCClass *sharedInstance = nil;
    static dispatch_once_t onceToken;

    dispatch_once(&onceToken, ^{
        sharedInstance = [[self alloc] init];
    });

    return sharedInstance;
}
```

### 41.Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?
### 42.如何把异步线程转换成同步任务进行单元测试？
### 43.如何实现线性编程？

## 网络
### 1.你了解的网络协议
- 协议是网络中计算机或设备之间进行通信的一系列规则的集合。常用协议有IP、TCP、HTTP、POP3、SMTP等。
- TCP/IP协议
    * 中译名为传输控制协议/因特网互联协议，又名网络通讯协议，是Internet最基本的协议
    * 不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族
- IP
    * Internet层协议
    * Internet协议,负责TCP/IP主机间提供数据报服务，进行数据封装并产生协议头,IP数据包中含有发送它的主机的地址（源地址）和接收它的主机的地址（目的地址）
- ICMP
    * Internet层协议
    * Internet控制报文协议。ICMP协议其实是IP协议的的附属协议，IP协议用它来与其它主机或路由器交换错误报文和其它的一些网络情况，在ICMP包中携带了控制信息和故障恢复信息
    * PING是最常用的基于ICMP的服务
- ARP
    * Internet层协议
    * 地址解析协议
- RARP
    * Internet层协议
    * 逆向地址解析协议
- TCP
    * 传输层(主机-主机层)协议
    * 传输控制协议
    * 面向连接的可靠通信协议，通过三次握手建立连接
    * 由于TCP是面向连接的所以只能用于端到端的通讯
- UDP
    * 传输层(主机-主机层)协议
    * 用户数据报协议
    * 面向无连接的不可靠通讯协议
    * 由于通讯不需要连接，所以可以实现广播发送
- HTTP
    * 应用层协议
    * 超文本传输协议,默认端口80
    * 是用于从WWW服务器传输超文本到本地浏览器的传输协议
    * 是客户端浏览器或其他程序与Web服务器之间的应用层通信协议
    * HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”“短连接”。
- FTP
    * 应用层协议
    * 文件传输协议

### 2.NSUrlConnect相关知识。
- NSURLConnection 是 iOS 开发中最经典的网络请求方案。虽然在苹果公司推出 NSURLSession 后已经不推荐使用 NSURLConnection 了（NSURLConnection 在 iOS 9 被宣布弃用了），但是在一些早先构建的项目和框架中可能任使用了 NSURLConnection 技术，所以还是有必要了解 NSURLConnection。
- NSURLConnection 使用步骤
    * 创建一个 NSURL 对象，用于设置请求路径。
    * 创建一个 NSURLRequest 对象，并设置请求头、请求体等请求参数。
    * 创建一个 NSURLResponse 对象用于接收响应数据，一般用 NSURLResponse 的子类 NSHPPTURLResponse。
    * 使用 NSURLConnection 发送同步或异步请求。
    * 可以使用 NSURLConnectionDelegate 监听网络请求的响应。

### 3.NSURLSession GET 请求方法
- 确定请求路径（一般由公司的后台开发人员以接口文档的方式提供），GET请求参数直接跟在URL后面。
- 创建请求对象（默认包含了请求头和请求方法【GET】），此步骤可以省略。
- 创建会话对象（NSURLSession）。
- 根据会话对象创建请求任务（NSURLSessionDataTask）。
- 执行请求 Task。
- 当得到服务器返回的响应后，解析数据（XML 或者 JSON）。
- 第一种方法：
```
-(void)getByNSURLSession1
{
    //对请求路径的说明
    //http://120.25.226.186:32812/login?username=520it&pwd=520&type=JSON
    //协议头+主机地址+接口名称+？+参数1&参数2&参数3
    //协议头(http://)+主机地址(120.25.226.186:32812)+接口名称(login)+？+参数1(username=520it)&参数2(pwd=520)&参数3(type=JSON)
    //GET请求，直接把请求参数跟在URL的后面以？隔开，多个参数之间以&符号拼接
    
    //1.确定请求路径
    NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&pwd=520it&type=JSON"];
    
    //2.创建请求对象
    //请求对象内部默认已经包含了请求头和请求方法（GET）
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    
    //3.获得会话对象
    NSURLSession *session = [NSURLSession sharedSession];
      
    //4.根据会话对象创建一个Task(发送请求）
    /*
     第一个参数：请求对象
     第二个参数：completionHandler回调（请求完成【成功|失败】的回调）
               data：响应体信息（期望的数据）
               response：响应头信息，主要是对服务器端的描述
               error：错误信息，如果请求失败，则error有值
     */
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
        if (error == nil) {
            //6.解析服务器返回的数据
            //说明：（此处返回的数据是JSON格式的，因此使用NSJSONSerialization进行反序列化处理）
            NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];
            
            NSLog(@"%@",dict);
        }
    }];
    
    //5.执行任务
    [dataTask resume];
}

//这是 NSURLSession 发送GET请求的第一种方法
```
- 第二种方法：

```
-(void)getByNSURLSession2
{
    //1.确定请求路径
    NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login?username=520it&pwd=520it&type=JSON"];
    
    //2.获得会话对象
    NSURLSession *session = [NSURLSession sharedSession];
    
    //3.根据会话对象创建一个Task(发送请求）
    /*
     第一个参数：请求路径
     第二个参数：completionHandler回调（请求完成【成功|失败】的回调）
               data：响应体信息（期望的数据）
               response：响应头信息，主要是对服务器端的描述
               error：错误信息，如果请求失败，则error有值
     注意：
        1）该方法内部会自动将请求路径包装成一个请求对象，该请求对象默认包含了请求头信息和请求方法（GET）
        2）如果要发送的是POST请求，则不能使用该方法
     */
    NSURLSessionDataTask *dataTask = [session dataTaskWithURL:url completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
        //5.解析数据
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];
        NSLog(@"%@",dict);
        
    }];
    
    //4.执行任务
    [dataTask resume];
}

//这是 NSURLSession 发送GET请求的第二种方法

```

### 4.NSUrlSession相关知识。
- 在 iOS 9.0 之后，以前使用的 NSURLConnection 被弃用，苹果推荐使用 NSURLSession 来替换NSURLConnection 完成网路请求相关操作。
- NSURLSession 使用步骤
    * NSURLSession 的使用非常简单，先根据会话对象创建一个请求Task，然后执行该Task即可。
    * NSURLSessionTask 本身是一个抽象类，在使用的时候，通常是根据具体的需求使用它的几个子类。

### 5.NSURLSession POST请求方法
- 确定请求路径（一般由公司的后台开发人员以接口文档的方式提供）。
- 创建可变的请求对象（因为需要修改），此步骤不可以省略。
- 修改请求方法为POST。
- 设置请求体，把参数转换为二进制数据并设置请求体。
- 创建会话对象（NSURLSession）。
- 根据会话对象创建请求任务（NSURLSessionDataTask）。
- 执行任务 Task。
- 当得到服务器返回的响应后，解析数据（XML 或者 JSON）。

```
-(void)postByNSURLSession
{
    //对请求路径的说明
    //http://120.25.226.186:32812/login
    //协议头+主机地址+接口名称
    //协议头(http://)+主机地址(120.25.226.186:32812)+接口名称(login)
    //POST请求需要修改请求方法为POST，并把参数转换为二进制数据设置为请求体
    
    //1.创建会话对象
    NSURLSession *session = [NSURLSession sharedSession];
    
    //2.根据会话对象创建task
    NSURL *url = [NSURL URLWithString:@"http://120.25.226.186:32812/login"];
    
    //3.创建可变的请求对象
    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];
    
    //4.修改请求方法为POST
    request.HTTPMethod = @"POST";
    
    //5.设置请求体
    request.HTTPBody = [@"username=520it&pwd=520it&type=JSON" dataUsingEncoding:NSUTF8StringEncoding];
    
    //6.根据会话对象创建一个Task(发送请求）
    /*
     第一个参数：请求对象
     第二个参数：completionHandler回调（请求完成【成功|失败】的回调）
                data：响应体信息（期望的数据）
                response：响应头信息，主要是对服务器端的描述
                error：错误信息，如果请求失败，则error有值
     */
    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
        //8.解析数据
        NSDictionary *dict = [NSJSONSerialization JSONObjectWithData:data options:kNilOptions error:nil];
        NSLog(@"%@",dict);
        
    }];
    
    //7.执行任务
    [dataTask resume];
}

// 发送POST请求的方法
```

### 6.简要说一下http
- HTTP协议
    * HTTP（Hypertext Transfer Protocol）协议是超文本传输协议，是互联网上应用最为广泛的一种网络协议。简单来说，HTTP 是客户端和服务器端之间请求和应答的标准。
- HTTP 协议工作过程，分为4个步骤：
    * 客户端与服务器需要建立连接。例如，单击某个超链接，浏览器和服务器将建立通信连接。
    * 建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容。
    * 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后面是 MIME 信息包括服务器信息、实体信息和可能的内容。
    * 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

### 补充：补充：Http2.0如1.x的区别
#### HTTP1.0和HTTP1.1的区别
- 长连接
    * HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象；
    * HTTP 1.1支持持久连接，也就是说长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。HTTP1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。基于HTTP1.1协议的客户机与服务器的信息交换过程。
    * HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
    * 什么是Keep-Alive模式？
        * 我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。
        * http1.0中默认是关闭的，需要在http头加入"Connection:Keep-Alive"，才能启用Keep-Alive；http1.1中默认启用Keep-Alive，如果加入"Connection:close"，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。
    * 启用Keep-Alive的优点
        * 从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。
        * HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
- 缓存
    * 在HTTP/1.0中，使用Expire头域来判断资源的fresh或stale，并使用条件请求（conditional request）来判断资源是否仍有效。例如，cache服务器通过If-Modified-Since头域向服务器验证资源的Last-Modefied头域是否有更新，源服务器可能返回304（Not Modified），则表明该对象仍有效；也可能返回200（OK）替换请求的Cache对象。
    * 此外，HTTP/1.0中还定义了Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。
    * HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。
    * HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。
    * 而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化。
    * 为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为。
    * Cache使用关键字索引在磁盘中缓存的对象，在HTTP/1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了支持这种内容协商机制(content negotiation mechanism)，HTTP/1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。
- 节约带宽
    * HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。例如，客户端只需要显示一个文档的部分内容，又比如下载大文件时需要支持断点续传功能，而不是在发生断连后不得不重新下载完整的包。
    * HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。
    * 另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。
    * HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。
    * 节省带宽资源的一个非常有效的做法就是压缩要传送的数据。Content-Encoding是对消息进行端到端（end-to-end）的编码，它可能是资源在服务器上保存的固有格式（如jpeg图片格式）；在请求消息中加入Accept-Encoding头域，它可以告诉服务器客户端能够解码的编码方式。
    * 而Transfer-Encoding是逐段式（hop-by-hop）的编码，如Chunked编码。在请求消息中加入TE头域用来告诉服务器能够接收的transfer-coding方式
- Host域
    * 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
    * HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。
- 消息传递
    * HTTP消息中可以包含任意长度的实体，通常它们使用Content-Length来给出消息结束标志。但是，对于很多动态产生的响应，只能通过缓冲完整的消息来判断消息的大小，但这样做会加大延迟。如果不使用长连接，还可以通过连接关闭的信号来判定一个消息的结束。
    * HTTP/1.1中引入了Chunkedtransfer-coding来解决上面这个问题，发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。
    * 在HTTP/1.0中，有一个Content-MD5的头域，要计算这个头域需要发送方缓冲完整个消息后才能进行。而HTTP/1.1中，采用chunked分块传递的消息在最后一个块（零长度）结束之后会再传递一个拖尾（trailer），它包含一个或多个头域，这些头域是发送方在传递完所有块之后再计算出值的。发送方会在消息中包含一个Trailer头域告诉接收方这个拖尾的存在。
- 内容协商
- 错误提示
    * HTTP/1.0中只定义了16个状态响应码，对错误或警告的提示不够具体。HTTP/1.1引入了一个Warning头域，增加对错误或警告信息的描述。
    * 此外，在HTTP/1.1中新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

#### HTTP1.1与HTTP2.0的区别
- 多路复用
    * HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
    * 当然HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。
    * TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。
- 数据压缩
    * 我们知道，http请求和响应都是由【状态行、请求/响应头部、消息主题】三部分组成的。 一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件（如图片、音频等），但是状态行和头部多是没有经过任何压缩，而是直接以纯文本的方式进行传输的。
    * 然而，随着web功能越来越复杂，请求数量越来越多，随之而来的就是头部的流量越来越多，并且在建立初次链接之后的链接也要发送user-agent等信息，是在是一种浪费。
    * 因此，http2提出了对请求和响应的头部进行压缩，即不再只是压缩主题部分，这种压缩方式就是HAPCK 。
    * 通过压缩，头部大小可以减少一半之多，如果后面重复发送请求，那么可能压缩后的头部大小只有原始大小的 1/10。
    * HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务器推送
    * 当代网页使用了许多资源:HTML、样式表、脚本、图片等等。在HTTP/1.x中这些资源每一个都必须明确地请求。这可能是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。
    * 为了改善延迟，HTTP/2引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前。一个服务器经常知道一个页面需要很多附加资源，在它响应浏览器第一个请求的时候，可以开始推送这些资源。这允许服务端去完全充分地利用一个可能空闲的网络，改善页面加载时间。
    * 服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。
    * 在协议层，HTTP/2 server push被push_promise 帧所驱动，一个PUSH_PROMISE描述了一个请求，即服务端预测浏览器将马上要发出的请求。浏览器一收到PUSH_PROMISE，它马上知道服务端将要传输这个资源。如果浏览器后续发现它需要这个资源，它会等待这个推送完成，而不是发送一个新的请求。这减少了浏览器花费在网络等待上的时间 。

### 7.说一下传输控制协议 - TCP ?
- TCP协议(Transport control Protocol)是一种面向连接的、可靠的、基于字节流的传输层通信协议。
- TCP的工作原理
    * TCP的原理分为三部分：TCP建立连接，报文传输以及TCP连接释放。其中TCP连接建立需要经过“三次握手”。
    * TCP连接建立，”三次握手“如下：
        * 一开始客户端TCO进程是处于closed状态。当客户端准备发起一次TCP连接时，进入SYN-SEND（准备发送）的状态，客户端首先先处于LISTEN（监听）状态的服务器端TCP进程发送第一个控制位SYN=1的“连接请求报文”。
        * 服务器端在接收到”连接请求报文“之后，如果对方同意建立连接，则向客户端发送第二个控制位SYN=1，ACK=1的”连接建立请求确认报文“。
        * 在接收到”连接建立请求确认报文“之后，客户端发送第三个控制位ACK=1”连接建立请求确认报文“。这时，客户端进入了ESTABLISHED（已建立连接）状态，服务器在接受到ACK报文之后也进入了ESTABLISHED（已建立连接）状态。
- 报文传输
    * 当客户进程与服务器进程之间的TCP传输连接建立之后，客户端的应用进程与服务器端的应用进程就可以使用这个连接，进行全双工的字节流传输。为了保证TCP工作正常、有序地进行，TCP设置了保持计时器（keep timer），用来防止TCP连接处以长时期空闲。
- TCP连接释放
    * TCP传输连接的释放过程比较复杂，客户端与服务器都可以主动提出连接释放的请求。下面是客户主动提出请求的连接释放“四次握手”的过程。
        * 当客户准备结束一次数据传输，主动提出释放TCP连接时，进入FIN-WAIT-1（释放等待-1）状态。它向服务器端发送第一个控制位FIN=1的“连接释放请求报文”，提出连接释放请求，停止发送数据。
        * 服务器在接受到“连接释放请求报文”之后，需要向客户端发回“连接释放请求确认报文”，表示对接收第一个连接释放请求报文的确认。
        * 服务器的高层应用没有数据需要发送时，它会通知TCP可以释放连接，这时服务器向客户端发送“连接释放请求报文”。
        * 客户在收到FIN报文之后，向服务器发送“连接释放请求确认报文”，表示对服务器“连接释放请求报文”的确认。
- ACK（确认位）：TCP在确认连接建立后发送的所有报文段的ACK都要置1.
- SYN（同步位）：同步位在连接建立时用来同步序号。例如：当SYN=1，ACK=0时，表示这是一个建立连接的请求报文；当SYN=1，ACK=1时，表示这是一个同一连接建立的相应报文。
- FIN（终止位）：FIN=1时表示发送端的报文发送完毕，请求释放TCP连接。

### 8.说一下用户数据报协议 - UDP ?
- UDP --- 用户数据报协议，是一个无连接的简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。
- UDP是一种面向无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。
- 特点：
    * UDP是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。
    * UDP传输数据时有大小限制，每个被传输的数据报必须限定在64KB之内。
    * UDP是一个不可靠的协议，发送方所发送的数据报并不一定以相同的次序到达接收方。
- UDP是面向消息的协议，通信时不需要建立连接，数据的传输自然是不可靠的，UDP一般用于多点通信和实时的数据业务，比如：语音广播，视频，

### 9.HTTP和TCP、UDP的联系
#### HTTP和TCP
- Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接
- 随着时间的推移，html页面变得复杂了,每次都需要建立一次tcp连接就显得低效了,从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性.简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭,但是Keep-Alive不会永久保持连接,它有一个保持时间.后来，通过Session,Cookie等相关技术，也能保持一些用户的状态。但是还是每次都使用一个连接，依然是无状态连接。
- http是应用层协议，tcp是传输层。http使用tcp传输文本数据

#### HTTP和UDP

### 补充：TCP 协议如何保证可靠传输
- 应用数据被分割成TCP最认为适合发送的数据块大小；
- TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层；
- 校验和： TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段；
- TCP 的接收端会丢弃重复的数据；
- 流量控制： TCP连接的每一方都有固定大小的缓冲空间，TCP 接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议 （ TCP 利用滑动窗口实现流量控制）；
- 拥塞控制： 当网络拥塞时，减少数据的发送；
- ARQ 协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，并等待对方确认，在收到确认之后，再发下一个分组；
- 超时重传： 当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到这个确认，那么将重发这个报文段。

### 补充：说一下可靠数据传输、流量控制(滑动窗口)、拥塞控制
#### 可靠数据传输
- 网络层服务（IP服务）是不可靠的。IP不保证数据报的交付，不保证数据报的按序交付，也不保证数据报中数据的完整性。
- TCP则是在IP服务上创建了一种可靠数据传输服务
- TCP的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、无间隔、无冗余、按序的数据流。即该字节流与连接的另一端发出的字节流是完全相同的。
- 作为TCP接收方，有三个与发送和重传有关的主要事件

##### 从上层应用数据接收数据
- 将数据封装到一个报文段中，并把报文段交付给IP。每个报文段都包含一个序号Seq，即该报文段第一个数据字节的字节流编号。如果定时器还没有为其他报文段而运行，则启动定时器(即不是每条报文段都会启动一个定时器，而是一共只启动一个定时器)，定时器的过期间隔是TimeoutInterval是由EstimatedRTT和DevRTT计算得来的:TCP的往返时间的估计与超时

##### 超时
- TCP通过重传引起超时的报文段来响应超时事件，然后重启定时器。
- 而发送端超时有两种情况：发送数据超时，接收端发送ACK超时。这两种情况都会导致发送端在TimeoutInterval内接收不到ACK确认报文段。
    * 如果是发送数据超时，直接重传即可。
    * 而如果是接收端发送ACK超时，这种情况接收端实际上已经接收到发送端的数据了。那么当发送端超时重传时，接收端会丢弃重传的数据，同时再次发送ACK。
- 而如果在TimeoutInterval后接收到了ACK，会收下ACK，但不做任何处理
- TCP不会为没有数据的ACK超时重传
- 以下两种情况：
    * 如果在发送两条或多条数据报文段都超时，那么只会重传序号最小的那个，并重启定时器。只要其余报文段的ACK在新重启的定时器超时前到达，就不会重传。
    * 如果发送序号为100和120的两条数据报文段，序号100的ACK丢失，但收到了序号120的ACK，由于累积确认机制，可以得出接收方已经接收到了序号100的报文段，这种情况也不会去重传。

##### 接收到ACK
- 用TCP状态变量SendBase指最早未被确认的字节的序号。则SendBase-1指接收方已正确按序接收到的数据的最后一个字节的序号。
- 当收到ACK确认报文段后，会将ACK的值Y与SendBase比较。TCP采用累计确认的方法，所以Y确认来字节编号在Y之前的所有字节都已经收到。如果Y比SendBase小，不用理会；而如果Y比SendBase大，则该ACK是在确认一个或多个先前未被确认的报文段，因此要更新SendBase变量，如果当前还有未被确认的报文段，TCP还要重启定时器。
- 通过超时重传，能保证接收到的数据是无损坏、无冗余的数据流，但并不能保证按序。
- 而通过TCP滑动窗口，能够有效保证接收数据有序

#### 流量控制
- TCP连接的双方主机都会为该TCP连接分配缓存和变量。当该TCP连接收到正确、按序的字节后，就将数据放入接收缓存。上层的应用进程会从该缓存中读取数据，但不必是数据一到达就立即读取，因为此时应用程序可能在做其他事务。而如果应用层读取数据相对缓慢，而发送方发送得太多、太快，发送的数据就会很容易地使该连接的接收缓存溢出。
- 所以，TCP为应用程序提供了流量控制服务（flow-control service），以消除发送方使接收方缓存溢出的可能性。
- 流量控制是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。
作为全双工协议，TCP会话的双方都各自维护一个发送窗口和一个接收窗口（receive window）的变量来提供流量控制。而发送窗口的大小是由对方接收窗口来决定的，接收窗口用于给发送方一个指示--该接收方还有多少可用的缓存空间。

![image](https://upload-images.jianshu.io/upload_images/11034989-6d17c5078d1357de.png?imageMogr2/auto-orient/strip|imageView2/2/w/1000)

##### 发送窗口
- 发送方的发送缓存内的数据都可以被分为4类:
    * 已发送，已收到ACK
    * 已发送，未收到ACK
    * 未发送，但允许发送
    * 未发送，但不允许发送
- 则2和3属于发送窗口，发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界

##### 接收窗口
- 接收方的缓存数据分为3类：
    * 已接收
    * 未接收但准备接收
    * 未接收而且不准备接收
- 则2 属于接收窗口（这里的接收指接收数据并确认）
- 接收窗口只有在前面所有的报文段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，会先接收下来，接收窗口不会移动，并不对后续字节发送ACK确认报文，以此确保发送端会对这些数据重传。
- 我们定义以下变量：
    * LastByteRead：接收方应用程序读取的数据流的最后一个字节编号。可以得知，这是接收缓存的起点
    * LastByteRcvd：从网络中到达的并且已放入接收缓存中的数据流的最后一个自己的的编号。
    * 可以得知：LastByteRcvd - LastByteRead <= RcvBuffer(接收缓存大小)
    * 那么接收窗口rwnd =RcvBuffer - （LastByteRcvd - LastByteRead）
    * rwnd是随时间动态变化的，如果rwnd为0，则意味着接收缓存已经满了。
    * 接收端在回复给发送端的ACK中会包含该rwnd，发送端则会根据ACK中的接收窗口的值来控制发送窗口。
    * 有一个问题，如果当发送rwnd为0的ACK后，发送端停止发送数据。等待一段时间后，接收方应用程序读取了一部分数据，接收端可以继续接收数据，于是给发送端发送报文告诉发送端其接收窗口大小，但这个报文不幸丢失了，我们知道，不含数据的ACK是不会超时重传的，于是就出现发送端等待接收端的ACK通知||接收端等待发送端发送数据的死锁状态。
    * 为了处理这种问题，TCP引入了持续计时器（Persistence timer），当发送端收到对方的rwnd=0的ACK通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。

#### 拥塞控制
- TCP除了可靠传输服务外，另一个关键部分就是拥塞控制。
- TCP让每一个发送方根据所感知到的网络拥塞程度来限制其能向连接发送流量的速率。
- 可能有三个疑问：
    * TCP发送方如何感知网络拥塞？
    * TCP发送方如何限制其向连接发送流量的速率？
    * 发送方感知到网络拥塞时，采用何种算法来改变其发送速率？
- 这就是TCP的拥塞控制机制。
- 前边说到，TCP连接的每一端都是由一个接收缓存、一个发送缓存和几个变量（LastByteRead、LastByteRcvd、rwnd等）组成。而运行在发送方的TCP拥塞控制机制会跟踪一个额外的变量，即拥塞窗口cwnd（congestion window）。它对一个TCP发送方能向网络中发送流量的速率进行了限制。
- 发送方中未被确认的数据量不会超过cwnd和rwnd的最小值:min(rwnd,cwnd)

##### TCP发送方如何感知网络拥塞？
- 冗余ACK（duplicate ACK）：就是再次确认某个报文段的ACK，而发送方先前已经收到对该报文段的确认。
- 冗余ACK的产生原因：
    * 当接收端接收到失序报文段时，即该报文段序号大于下一个期望的、按序的报文段，检测到数据流中的间隔，即由报文段丢失，并不会对该报文段确认。TCP不使用否定确认，所以不能向发送方发送显式的否定确认，为了使接收方得知这一现象，会对上一个按序字节数据进行重复确认，这也就产生了一个冗余ACK。
    * 因为发送方经常发送大量的报文段，如果其中一个报文段丢失，可能在定时器过期前，就会收到大量的冗余ACK。一旦收到3个冗余ACK（3个以下很可能是链路层的乱序引起的，无需处理），说明在这个已被确认3次的报文段之后的报文段已经丢失，TCP就会执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。
- 将TCP发送方的丢包事件定义为：要么出现超时，要么收到来自接收方的3个冗余ACK。
- 当出现过度的拥塞时，路由器的缓存会溢出，导致一个数据报被丢弃。丢弃的数据报接着会引起发送方的丢包事件。那么此时，发送方就认为在发送方到接收方的路径上出现了网络拥塞。

##### TCP发送方如何限制其向连接发送流量的速率？
- 当出现丢包事件时：应当降低TCP发送方的速率。
- 当对先前未确认报文段的确认到达时，即接收到非冗余ACK时，应当增加发送方的速率。

##### 发送方感知到网络拥塞时，采用何种算法来改变其发送速率？
- 即TCP拥塞控制算法（TCP congestion control algorithm）
- 包括三个主要部分：慢启动、拥塞避免、快速恢复，其中快速恢复并非是发送方必须的，慢启动和拥塞避免则是TCP强制要求的
    * 慢启动
        * 当一条TCP连接开始时，拥塞窗口cwnd的值通常置为一个MSS的较小值，这就使初始发送速率大约为MSS/RTT（RTT：往返时延，报文段从发出到对该报文段的确认被接收之间的时间量）。
        * 而对TCP发送方来说，可用带宽可能比MSS/RTT大得多,TCP发送方希望迅速找到可用带宽的数量。因此，在慢启动状态，cwnd以一个MSS的值开始并且每当收到一个非冗余ACK就增加一个MSS。
        * 最初cwnd值为1MSS，发送一个报文段M1。收到M1的确认后，cwnd增加为2MSS，这时可以发送两个报文段M2，M3。收到这两个报文段的确认后，cwnd则增加为4MSS，可以发送四个报文段，以此类推...
        * 因此，TCP虽然发送速率起始慢，但在慢启动阶段以指数增长。
        * 这种指数增长很显然不是无限制的，那么何时结束呢？
            * 如果出现丢包事件，TCP发送方将ssthresh（慢启动阈值）设置为cwnd/2
            * 发生由超时引起的丢包事件，并将cwnd重置为1MSS，重启慢启动
            * 当TCP发送方的cwnd值达到或超过ssthresh，再继续翻倍显然不合适。这时将结束慢启动转移到拥塞避免模式。
            * TCP发送方检测到3个冗余ACK，会结束慢启动，并快速重传，即在该报文段的定时器过期之前重传丢失的报文段。且进入快速恢复状态。
    * 拥塞避免
        * 一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，即距离拥塞并不遥远。因此，TCP无法每过一个RTT就将cwnd翻倍。而是每个RTT只增加1MSS，即每收到一个非冗余ACK，就将cwnd增加1/cwnd。即假如此时cwnd为10MSS，则每收到一个非冗余ACK，cwnd就增加1/10MSS，在10个报文段都收到确认后，拥塞窗口的值就增加了1MSS。
        * 那么何时结束拥塞避免的线性增长（每RTT 1MSS）呢？
            * 和慢启动一样，如果出现丢包事件，TCP发送方将ssthresh（慢启动阈值）设置为cwnd/2（加法增大， 乘法减小）
            * 发生由超时引起的丢包事件，拥塞避免和慢启动处理的方式相同。即TCP发送方将ssthresh（慢启动阈值）设置为cwnd/2，并将cwnd重置为1MSS，重启慢启动
            * TCP发送方检测到3个冗余ACK，cwnd为原来的一半加上3MSS，进入快速恢复状态。
    * 快速恢复
        * 快速恢复是由3个冗余ACK引起的。
        * 在快速恢复中，对引起TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd增加1个MSS。最终，当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。
        * 如果出现超时，和之前一样，即TCP发送方将ssthresh（慢启动阈值）设置为cwnd/2，并将cwnd重置为1MSS，重启慢启动
        * 快速恢复并非是必须的。
        * TCP的拥塞控制是：每个RTT内cwnd线性（加性增）增加1MSS，然后出现3个冗余ACK事件时cwnd减半（乘性减），因此TCP拥塞控制常被称为加性增，乘性减拥塞控制方式。

### 补充：TCP 的拥塞控制主要是四个算法
- TCP 的拥塞控制主要是四个算法：1）慢启动；2）拥塞避免；3）拥塞发生；4）快速恢复。
- 慢启动算法
    * 慢启动的算法如下(cwnd 全称 Congestion Window)：
        * 连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS（Max Segment Size）大小的数据。
        * 每当收到一个 ACK，cwnd++; 呈线性上升。
        * 每当过了一个 RTT，cwnd = cwnd*2; 呈指数上升。
        * 还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd >= ssthresh 时，就会进入「拥塞避免算法」。
    * 所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。
- 拥塞避免算法
    * 前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd >= ssthresh 时，就会进入拥塞避免算法。一般来说 ssthresh 的值是 65535 字节，当 cwnd 达到这个值时后，算法如下：
        * 收到一个 ACK 时，cwnd = cwnd + 1/cwnd。
        * 当每过一个 RTT 时，cwnd = cwnd + 1。
    * 这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。
- 拥塞状态时的算法
    * 当丢包的时候，会有两种情况：
        * 等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。
            * sshthresh = cwnd/2。
            * cwnd 重置为 1。
            * 进入慢启动过程。
        * 快速重传（Fast Retransmit）算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。
            * TCP Tahoe 的实现和 RTO 超时一样。
            * TCP Reno的实现是：
                * cwnd = cwnd/2。
                * sshthresh = cwnd。
                * 进入快速恢复算法（Fast Recovery）。
    * 上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd<=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。
- 快速恢复算法
    * TCP Reno 这个算法定义在 RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新：
        * cwnd = cwnd /2
        * sshthresh = cwnd
    * 然后，真正的 Fast Recovery 算法如下：
        * cwnd = sshthresh + 3 * MSS （3 的意思是确认有 3 个数据包被收到了）。
        * 重传 Duplicated ACKs 指定的数据包。
        * 如果再收到 duplicated ACKs，那么 cwnd = cwnd + 1。
        * 如果收到了新的 ACK，那么 cwnd = sshthresh，然后就进入了拥塞避免的算法了。
- 如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是它依赖于 3 个重复的 ACKs。注意，3 个重复的 ACKs 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时。于是，进入了恶梦模式：超时一个窗口就减半一下。多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。
- 1995 年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法：
    * 当 sender 这边收到了 3 个 Duplicated ACKs，进入 Fast Retransimit 模式，开发重传重复 ACKs 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 ACK 会把整个已经被 sender 传输出去的数据 ACK 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。
    * 一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial ACK，才真正结束 Fast Recovery 这个过程。
    * 这个 Fast Recovery 的变更是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。

### 10.简要说一下Https；
### 11.HTTPS的原理
- https涉及了多种加密方式
    * 对称加密：加密和解密共用一把密钥，多用AES,DES算法；
    * 非对称加密：一个公钥和一个私钥，密钥要对，本质上公钥和私钥指定的是一对反函数的，常用就是RSA公钥加密算法；y = f(x) , x = g(y) x = g(f(x)) 相当于你用私钥（f(x)函数）加密了x之后，用公钥（g(y)函数）再解密，就可以把x还原。
    * RSA加密利用了单向函数正向求解很简单，反向求解很复杂的特性。
    * 散列/hash算法加密：这种是不可逆算法，为什么？简单来说，hash本质上是利用因式分解。
- https = http + ssl/tls
- “Secure Sockets Layer”的缩写，中文叫做“安全套接层”
- TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”
#### 两个重要部分
- 身份验证
- 对称加密的密钥的生成过程
##### 身份验证：
- 数字证书有三个作用
    * 身份授权。确保浏览器访问的网站是经过CA验证的可信任的网站。
    * 分发公钥。每个数字证书都包含了注册者生成的公钥（验证确保是合法的，非伪造的公钥）。在SSL握手时会通过certificate消息传输给客户端。
    * 验证证书合法性。客户端接收到数字证书后，会对证书合法性进行验证。只有验证通过后的证书，才能够进行后续通信过程。
- 数字签名是证书的防伪标签，目前使用最广泛的SHA-RSA（SHA用于哈希算法，RSA用于非对称加密算法）
- SSL利用基于MD5或SHA的MAC算法来保证消息的完整性
- 证书包括的内容：签发者，证书用途，公钥，加密算法，用的HASH算法，证书的到期时间等。
- 把以上内容做一次HASH，得到一个固定长度（比如128位的HASH），然后再用CA的私钥加密，就得到了数字签名，附在以上证书的末尾，一起传输给sever。
- 设想一下，如果不加密那个HASH，任何人都可以先篡改证书，然后再计算HASH，附在证书的后面，传给server时，server无法发现是否有人篡改过。而用CA私钥加密后，就生成了类似人体指纹的签名，任何篡改证书的尝试，都会被数字签名发现。
##### 对称加密的密钥的生成过程
- https 数据的加密用的对称加密，但是对称加密的预密钥（pre-master secret）用的非对称加密；原因：1.因为对称计算量小，加密解密速度快，而非对称加密计算量大，90%，2. RSA对加密数据长度有限制
- RSA对加密数据长度有限制，TLS握手 tls和ssl都是加密协议

#### 完整流程
- 第一步：三次握手成功后，浏览器与sever建立TCP连接，
- 第二步：ssl握手的client hello 阶段，客户端发送一个随机数和告知server客户端支持的ssl协议版本号，支持的加密方法；
- 第三步：服务器会弹出一个页面提醒安装数字证书，确定安装之后服务器发来了自己的数字证书，除此之外还有一个server random；
- 第四步：浏览器接到数字证书，从系统获取CA公钥值（网上说ca机构的公钥是维护在系统内部的），可以解密数字证书末尾的数字签名（CA私钥加密，可以用CA公钥解密，此为非对称加密），得到原始的HASHs然后自己也按照证书的HASH算法，自己也计算一个HASHc，如果HASHc== HASHs，则认证通过，否则认证失败。假设认证成功，否则故事无法编下去了…
- 第五步：双方会运行 Diffie Hellman 算法，简称 DH算法。通俗地说：双方会协商一个master-key，这个master-key 不会在网络上传输、交换，它们独立计算出来的，其值是相同的，只有它们自己双方知道，任何第三方不会知道，俗称的天不知，地不知，你知，我知。然后以master-key推导出session-key，用于双方SSL数据流的加密/解密，采用对称加密，保证数据不被偷窥，加密算法一般用AES。以master-key推导出hash-key，用于数据完整性检查（Integrity Check Verification）的加密密钥，HASH算法一般有：MD5、SHA，通俗滴说，保证数据不被篡改。
- 第六步：然后就可以正常发数据了，用HASH key 生成一个MAC（ Message Authentication Code），附在HTTP报文的后面，然后用session key 加密所有数据（HTTP + MAC），然后发送出去
- 第七步：服务器先用session key解密数据，得到HTTP + MAC，然后自己用相同的算法计算自己的MAC，如果两个MAC相等，则数据没有被篡改。

### 补充：服务器返回给客户端的证书跟它自己保留的证书一样吗
### 补充：https 单项认证 双向认证
- 单项认证：客户端APP包里保存一份证书 用于校验服务端证书是否合法
- 双向认证：单项认证以外，   客户端（不是app,这里指系统）要拥有一份证书 用于传给服务端用于校验客户端证书是否合法
#### 客户端配置。
- 单向认证流程：
    * 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
    * 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
    * 客户端使用服务端返回的信息验证服务器的合法性，包括：
        * 证书是否过期
        * 发形服务器证书的CA是否可靠
        * 返回的公钥是否能正确解开返回证书中的数字签名
        * 服务器证书上的域名是否和服务器的实际域名相匹配
    * 验证通过后，将继续进行通信，否则，终止通信
    * 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
    * 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式。
    * 服务器将选择好的加密方案通过明文方式返回给客户端
    * 客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器
    * 服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥。在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。
- 双向认证流程：
    * 客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息。
    * 服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书
    * 客户端使用服务端返回的信息验证服务器的合法性，包括：
        * 证书是否过期
        * 发形服务器证书的CA是否可靠
        * 返回的公钥是否能正确解开返回证书中的数字签名
        * 服务器证书上的域名是否和服务器的实际域名相匹配
    * 验证通过后，将继续进行通信，否则，终止通信
    * 服务端要求客户端发送客户端的证书，客户端会将自己的证书发送至服务端
    * 验证客户端的证书，通过验证后，会获得客户端的公钥
    * 客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择
    * 服务器端在客户端提供的加密方案中选择加密程度最高的加密方式
    * 将加密方案通过使用之前获取到的公钥进行加密，返回给客户端
    * 客户端收到服务端返回的加密方案密文后，使用自己的私钥进行解密，获取具体加密方式，而后，产生该加密方式的随机码，用作加密过程中的密钥，使用之前从服务端证书中获取到的公钥进行加密后，发送给服务端
    * 服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全。

### 12.简要说一下Socket
- Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。
- 套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
- 用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个CP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。
- 建立socket连接
    * 建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。
    * 套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。
        * 服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。
        * 客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。
        * 连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。
- SOCKET连接与TCP连接
    * 创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。
- Socket连接与HTTP连接
    * 由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
- Socket为长连接：通常情况下Socket 连接就是 TCP 连接，因此 Socket连接一旦建立,通讯双方开始互发数据内容，直到双方断开连接。在实际应用中，由于网络节点过多，在传输过程中，会被节点断开连接，因此要通过轮询高速网络，该节点处于活跃状态。很多情况下，都是需要服务器端向客户端主动推送数据，保持客户端与服务端的实时同步。若双方是Socket连接，可以由服务器直接向客户端发送数据。若双方是HTTP连接，则服务器需要等客户端发送请求后，才能将数据回传给客户端。因此，客户端定时向服务器端发送请求，不仅可以保持在线，同时也询问服务器是否有新数据，如果有就将数据传给客户端。

### 13.Http 和 Https 的区别？为什么更加安全？
- HTTP协议
    * HTTP（Hypertext Transfer Protocol）协议是超文本传输协议，是互联网上应用最为广泛的一种网络协议。简单来说，HTTP 是客户端和服务器端之间请求和应答的标准。
- HTTP 协议工作过程，分为4个步骤：
    * 客户端与服务器需要建立连接。例如，单击某个超链接，浏览器和服务器将建立通信连接。
    * 建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容。
    * 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后面是 MIME 信息包括服务器信息、实体信息和可能的内容。
    * 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
- HTTPS协议
    * HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。
- HTTPS和HTTP的区别：
    * https协议需要到ca申请证书，一般免费证书很少，需要交费。
    * http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
    * http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。
    * http的连接很简单,是无状态的。
    * HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全。
- iOS9中新增App Transport Security（简称ATS）特性, 让原来请求时候用到的HTTP，全部都转向TLS1.2协议进行传输，这意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。如果我们在iOS9下直接进行HTTP请求是会报错，系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist中控制ATS的配置。

### 14.Http的请求方式有哪些？Http 有什么特性？
- 根据HTTP标准，HTTP请求可以使用多种请求方法。
- HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
- HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
- GET 请求指定的页面信息，并返回实体主体。
- HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头。
- POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT 从客户端向服务器传送的数据取代指定的文档的内容。
- DELETE 请求服务器删除指定的页面。
- Http 有什么特性
    * 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
    * 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
    * 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
    * 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
    * 支持B/S及C/S模式。B/S即Browser/Server,浏览器/服务器，C/S即Client/Server,客户端/服务器

### 15.解释一下 三次握手 和 四次挥手？解释一下为什么是三次握手 又为什么是 四次挥手？
* tcp的三次握手
    * 所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：
    * TCP三次握手
        * 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
        * 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为 1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
        * 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发 送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入 ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
* 补充：SYN攻击：
    * 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：
  #netstat -nap | grep SYN_RECV
* tcp的四次握手
    * 所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![image](https://upload-images.jianshu.io/upload_images/2744128-70075430fcb3ca99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)

* TCP四次挥手
    * 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个 FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的 一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
        * 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
        * 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
        * 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
        * 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
* 原因
    * 因为连接时服务端收到了客户端的SYN连接请求的报文后, 可以直接发送SYN+ACK报文, 其中的ACK报文是用来响应, SYN报文是用来同步的。
    * 而当关闭连接时, 服务端收到FIN报文后, 很可能并不会马上就关闭Socket连接, 所以只能先回复一个ACK报文, 告诉客户端, 你发的FIN报文我收到了, 只有等到服务器的所有报文发送完了, 服务端才会发送FIN报文, 所以才需要四次挥手。

### 16.GET 和 POST 请求的区别？
- GET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。
- GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头<requestline>中。以分割URL和传输数据，多个参数用&连接。如果数据是英文字母或数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。
- POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体<request-body>中.
- GET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。
- GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。
- POST的安全性要比GET的安全性高；
- 通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。

### 17.GET请求参数一定是放在URL中的么？
- 不是，还可以放在body中，可以防止数据篡改
- 其实质就是用socket封装

### 18.Post请求体有哪些格式？
- JSON提交
    * SON是常用的一种前后端数据接收格式。前端传递的是键值对数据，即对象(Object)。采用JSON传递参数，请求头Content-Type为application/json;charset=utf-8，其中charset为采用的字符集。
- 请求头提交
    * 在实际开发中，遇到过不少后端开发，喜欢吧请求参数放在请求头，类似于get请求，即请求的参数是拼接在请求地址后面。个人觉得这种传参方式并不好，一般浏览器对URL长度是有限制的，以Chrome为例，URL最大长度正在7700个字符左右，对于post请求来说，最好参数还是放在body中。
- 普通表单提交
    * 表单提交的方式有两种，一种是普通的表单提交，另外一种是通过FormData进行提交（主要应用在文件上传）。单纯的表单提交，与上述两种参数格式上还是存在一定的差别的，主要体现在以下几个方面。
- FormData提交 (文件上传)
    * 通常我们在进行文件上传时，都会采用表单提交。参数放在body中,只不过格式与普通的有差别，具体如下：
        * 参数需要放在FormData的实例中，通过append进行参数的添加
        * 请求头Content-Type为multipart/formdata

### 19.POST请求参数能放在URL中么为啥
- 可以
- 注意点
    * 客户端请求参数拼接在url后，在?后，键值对写法a=1，多个键值对之间通过连接符&连接
    * 服务端能够在request对象中，通过request.query直接进行接收
    * 由于参数是拼接在url后面，所以请求头Content-Type无需设置

### 20.HTTP 请求报文 和 响应报文的结构？
- HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。
- HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。
- HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。

### 21.在HTTPS建立连接的时候都用了哪些加密算法，为什么要这么设计
- https涉及了多种加密方式
    * 对称加密：加密和解密共用一把密钥，多用AES,DES算法；
    * 非对称加密：一个公钥和一个私钥，密钥要对，本质上公钥和私钥指定的是一对反函数的，常用就是RSA公钥加密算法；y = f(x) , x = g(y) x = g(f(x)) 相当于你用私钥（f(x)函数）加密了x之后，用公钥（g(y)函数）再解密，就可以把x还原。
    * RSA加密利用了单向函数正向求解很简单，反向求解很复杂的特性。
    * 散列/hash算法加密：这种是不可逆算法，为什么？简单来说，hash本质上是利用因式分解。
- https = http + ssl/tls
- “Secure Sockets Layer”的缩写，中文叫做“安全套接层”
- TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”

### 22.https的缓存问题。
### 23.什么是 Mimetype ?
- MIME是描述消息内容类型的因特网标准。
- 使用场景：无论是我们使用NSURLConnection还是使用第三方框架AFN，在我们上传文件的时候，我们都需要指定上传文件的类型，例如：image/png、text/html等。接下来，我就详细说明一下文件的MIMEType获取方法。
- 怎样获取
- 方法一：写一个分类

```
/*
 * 第一种方式获得MIMEType
 * 说明：
 * 1、你可以将此方法写成分类，以便今后方便使用。
 * 2、这里请求的方式我采用的是NSURLConnection的方式发送的请求，大家可以采取其他的方式，在iOS7.0之后本方式已经弃用了。
 * 参数解释：
 * path : 文件的路径。
 */

- (void)getMimeType:(NSString *)path{
    // 创建URL 
    NSURL *url = [NSURL fileURLWithPath:path];
    // 创建请求对象
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    // 发送异步请求 在请求的
    [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
        NSLog(@"%@",response.MIMEType);
    }];
}
```
- 方法二：采用C语言库的方式进行获取

```
/* 
 * 第二种方式获得MIMEType
 * 说明：
 * 1、这种方式使用了C语言的API进行实现的，要使用它，首先要引入入 <MobileCoreServices/MobileCoreServices.h>这个库。
 * 2、相关的使用在AFURLRequestSerialization.m文件中，在此框架中采用的是内联函数的方式进行描述的。关于内联函数，读者请先自行百度。
 * 参数解释：
 * extension : 这个是文件的拓展名。
 */
// 方法实现
static inline NSString * AFContentTypeForPathExtension(NSString *extension) {
    NSString *UTI = (__bridge_transfer NSString *)UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)extension, NULL);
    NSString *contentType = (__bridge_transfer NSString *)UTTypeCopyPreferredTagWithClass((__bridge CFStringRef)UTI, kUTTagClassMIMEType);
    if (!contentType) {
        return @"application/octet-stream";
    } else {
        return contentType;
    }
}
// 方法调用 打印为 image/png
AFContentTypeForPathExtension(@"png");

-----------------------------------------------------------------华丽丽的分割线------------------------------------------------------------------

/*
 * 说明：
 * 1、知道了这个函数是如何使用的之后我们可以进行相关改造，使其更方便的使用。
 * 2、这里传入文件的路径会自动截取,并且添加了相关的过滤条件，这里的参数和方式一中的相同。
 */
// 方法实现
- (NSString *)mimeTypeForFileAtPath:(NSString *)path
{
    // 这里使用文件管理者的相关方法判断文件路径是否有后缀名
    if (![[[NSFileManager alloc] init] fileExistsAtPath:path]) {
        return nil;
    }
    // [path pathExtension] 获得文件的后缀名 MIME类型字符串转化为UTI字符串 
    CFStringRef UTI = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, (__bridge CFStringRef)[path pathExtension], NULL);
    // UTI字符串转化为后缀扩展名
    CFStringRef MIMEType = UTTypeCopyPreferredTagWithClass (UTI, kUTTagClassMIMEType);
    CFRelease(UTI);
    // application/octet-stream，此参数表示通用的二进制类型。
    if (!MIMEType) {
        return @"application/octet-stream";
    }
    return (__bridge NSString *)(MIMEType);
}
// 方法调用 打印为image/png
[self mimeTypeForFileAtPath:@"/Users/Desktop/icon.png"]
```

### 24.数据传输的加密过程？
- iOS中数据加密有下面几种方式
    * 使用数字证书锁定来保证不被中间人拦截，将服务器返回的数据和我的当地证书进行对比，确保是从服务器返回回来的。证书有ca证书，也可以自己给自己签发证书。像12306购票。
        * 证书锁定尽管带了较高的安全性，但是这种安全性的提高却牺牲了灵活性。一旦当证书发生变化时，我们的客户端也必须随之升级，除此之外，我们的服务端不得不为了兼容以前的客户端而做出一些妥协或者说直接停用以前的客户端，
    * 使用https协议请求网页，post来请求网页数据，保证用户的账号密码不被被人获取到。
    * 使用苹果自己的SSKeyChain钥匙串，将用户的账号密码保存在钥匙串中。钥匙串拱了错误处理，如果保存出错，会在判断后打印出出错的信息。
        * 使用SSKeyChain我们进行下面两步骤操作：
            * 在工程中加入Security.framework框架。
            * 把SSKeychain.h和SSKeychain.m加到项目文件夹。

```
//获取所有账号
+ (NSArray *)allAccounts;
//通过账号名字获取服务名
+ (NSArray *)accountsForService:(NSString *)serviceName;
//通过服务名和账号获取密码
+ (NSString *)passwordForService:(NSString*)serviceNameaccount:(NSString *)account;
//通过服务名和账号删除密码
+ (BOOL)deletePasswordForService:(NSString*)serviceNameaccount:(NSString *)account;
//通过服务名和账号设置密码
+ (BOOL)setPassword:(NSString *)passwordforService:(NSString*)serviceName account:(NSString *)account;
```
- 
    * 最保险的加密算法是非对称加密。非对称加密公钥加密私钥解密。缺点是要耗费时间。
        * 首先AES为对称加密，加密解密用同一个密钥，RSA为非对称加密，加密解密过程需要使用到一个公钥和一个私钥。
        * 第一步首先对数据进行签名。取出字典中数据的所有value，转换成字符串格式然后进行拼接，然后使用客户端的私钥进行签名，得到签名字符串，然后以加入到原始数据的字典里。之后将这个新的添加了签名的字典转换成json格式的字符串，便得到需要加密的数据。这里要注意的是，验签成功的条件是，最终传输的json字符串中的数据需要和和你签名的value字符串顺序一致，当然忽略签名数据。
        * 这里有一个坑。我在实现这部分功能的时候，为了保持顺序一致，先按照key给数据进行了排序，取这个顺序的value进行拼接并签名，然后使用如下方式整个数据进行转json字符串。
        * 这时候，iOS 11和以后的版本和之前的版本得到的结果的顺序是不一样的。iOS 11以后的顺序和按照key排序得到的顺序是一致的，而iOS 11之前的版本是另一个固定的顺序，这就导致直接使用这个数据的话iOS 11之前的版本会验签失败。处理这种情况，我的思路有两种，一是换一种转json的方式，自己写一个转json的逻辑自己控制顺序，二是转换出字符串之后把取出各个key的位置，排个序，按这个顺序重新拼一下value，签名，之后替换掉原来的签名。
        * 得到了数据之后，客户端本地生成一个随机字符串作为AES密钥，然后使用该密钥对数据进行加密得到加密之后的数据1，再使用服务器公钥对AES密钥进行加密，得到加密之后的数据2，给服务器传输这两个数据。
        * 接收返回的数据时，先用客户端私钥对返回数据的数据2进行解密，取得AES密钥，再使用该密钥对数据1进行解密得到返回数据。

### 25.说一下 TCP/IP 五层模型的协议?
* OSI七层模型：
    * OSI七层网络模型称为开发式系统互联网参考模型，是一个逻辑上的定义和规范；
    * 把网络从逻辑上分为七层，每一层都有相应的物理设备 
    * OSI七层网络模型是一种框架式的设计方法，最主要的功能就是帮助不同类型的主机实现数据传输； 
    * 最大的优点就是将服务、接口和协议三个概念明确的区分起来 
    * 复杂且不实用；经常使用的是TCP/IP四层模型。
* 各部分及功能
    * 应用层：针对特定应用的协议 
    * 表示层：设备固定的数据格式和网络标准数据格式之间的转化 
    * 会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层 
    * 传输层：管理两个节点之间的数据传递。负责可靠传输 
    * 网络层：地址管理和路由选择 
    * 数据链路层：互联设备之间传送和识别数据帧 
    * 物理层：界定连接器和网线之间的规格
* TCP/IP四（五）层模型。
    * 每一层都需要它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层） 
    * 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。 
    * 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。 
    * 网络层：负责地址管理和路由选择。路由器工作在网络层。 
    * 传输层：负责两台主机之间的数据传输。 
    * 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。
    * 传输层和网络层的封装在操作系统完成。应用层的封装在应用程序中完成。 
数据链路层和物理层的封装在设备驱动程序与网络接口中完成。

### 26.说一下 OSI 七层模型的协议?
- OSI模型，即开放式通信系统互联参考模型，是国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。
- 0SI／RM协议是由IS0(国际标准化组织)制定的，它有三个基本的功能：
    * 提供给开发者一个必须的
    * 通用的概念以便开发完善
    * 可以用来解释连接不同系统的框架
- OSI的层次划分：OSI将计算机网络体系结构(architecture)划分为以下七层：
    * 物理层  Physical Layer：物理接口规范，传输比特流,网卡是工作在物理层的。
    * 数据链路层  Data Link Layer：成帧，保证帧的无误传输，MAC地址，形成EHTHERNET帧
    * 网络层  Network Layer：路由选择，流量控制，IP地址，形成IP包
    * 传输层  Transport Layer：端口地址，如HTTP对应80端口。TCP和UDP工作于该层,还有就是差错校验和流量控制。
    * 会话层  Session Layer：组织两个会话进程之间的通信,并管理数据的交换使用NETBIOS和WINSOCK协议。QQ等软件进行        通讯因该是工作在会话层的。
    * 表示层  Presentation Layer：使得不同操作系统之间通信成为可能。
    * 应用层 Application Layer：对应于各个应用软件

### 27.大文件下载 的功能有什么注意点？
- 大文件下载分四步：
    * NSURLSessionConfiguration初始化
    * NSURLSession初始化
    * 创建NSURLSessionDownloadTask
    * 实现四个代理方法
#### NSURLSessionConfiguration初始化
- 在初始化NSURLSession之前需要配置NSURLSessionConfiguration，有三种模式可以选择。

```
//默认模式，使用的是持久化的硬盘缓存
defaultSessionConfiguration;
//仅使用内存缓存，不会做持久存储到磁盘等，在session被释放后，数据会被清除，一般用于浏览器的无痕浏览
ephemeralSessionConfiguration;
//后台传输模式，咱们主要用的是这个模式，
backgroundSessionConfigurationWithIdentifier

```
#### NSURLSession初始化
- NSURLSessionConfiguration配置好以后就可以设置NSURLSession了，注意,文件下载只需要有一个Session就够了，要下载多个文件可以创建多个NSURLSessionDownloadTask。

```
//默认单线程执行大文件下载
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;//这里可以设置它的最大并发数
        
//创建会话
self.session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:queue];
```
#### 创建NSURLSessionDownloadTask
- session设置完以后就可以进行下载操作了，一行代码的事儿

```
NSURLSessionDownloadTask *downloadTask = [self.session downloadTaskWithURL:[NSURL URLWithString:urlStr]];
```

#### 实现四个代理方法

```
#pragma mark - NSURLSessionDownloadDelegate
/**
 每次传一个包调用一次该方法,可以从中获得下载进度,速度和文件大小

 @param session 当前的session会话
 @param downloadTask 当前的下载任务NSURLSessionDownloadTask
 @param bytesWritten 这次传递过来的数据量
 @param totalBytesWritten 目前为止下载了多少的数据
 @param totalBytesExpectedToWrite 一共有多少的数据要下载
 */
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    //进度
    float progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    self.downloadProgressBlock(progress);
}

/**
 下载完成后，会调用该方法

 @param session 当前的session会话
 @param downloadTask 当前的下载任务NSURLSessionDownloadTask
 @param location 文件下载下来后系统自动保存的地址，location下的文件会被系统自动删除
 */
- (void)URLSession:(NSURLSession *)session
      downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(nonnull NSURL *)location {
    //移动文件到自己想要保存的路径下,location下的文件会被系统自动删除
    NSError *saveError = nil;
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *savePath = [self savePathWithUrl:downloadTask.taskDescription];
    if ([fileManager fileExistsAtPath:savePath]) {
        [fileManager removeItemAtPath:savePath error:nil];
    }
    BOOL success = [fileManager moveItemAtPath:location.path toPath:savePath error:&saveError];
    if (success) {
        NSLog(@"文件下载完成,路径为 == %@", savePath);
        self.downloadSuccessBlock([NSURL URLWithString:savePath]);
        //删除之前保存的用来断点续传的resumeData
        [self removeDownloadTmpFileWithUrl:downloadTask.taskDescription];
    } else {
        NSLog(@"在转移文件时发生错误 %@", saveError);
    }
}

#pragma mark - NSURLSessionTaskDelegate
/**
 每次任务结束后调用，结束并不代表它下载完了，有以下几种情况
 1、没错误
 2、用户取消下载
 3、进程在后台被杀死了
 4、其他错误
 偷偷说一句，这个error里面有断点续传需要的resumeData
 @param session 当前的session会话
 @param task 当前的下载任务NSURLSessionTask，
            NSURLSessionDownloadTask继承它
 @param error 错误信息
 */
-(void)URLSession:(nonnull NSURLSession *)session
             task:(nonnull NSURLSessionTask *)task
didCompleteWithError:(nullable NSError *)error {
    if (error) {
        
        //用户取消下载会回调一个error,
        if ([error.localizedDescription isEqualToString:@"cancelled"]) {
            return;
        }
        
        //如果是在后台进程被杀死了,则保存一下resumeData
        if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
            [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
        }
        
        //暂时就是出任何错都让resumeData保存一下吧
        [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
        NSLog(@"error = %@", error);
    }
}

#pragma mark - NSURLSessionDelegate
//应用处于后台,所有下载任务已经完成，且其他代理方法都调用完以后调用
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
    NSLog(@"应用在后台该做的事儿都做完了");
}
```

### 28.后台下载
- 在AppDelegate中调用一行代码

```
- (void)applicationDidEnterBackground:(UIApplication *)application {
    //调用这句,防止应用在进入后台后所有任务被终止
    [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
    }];
}
```
调用完这个代码以后，App即使被压入后台，应用会继续把没执行完的任务执行完，一般是3分钟，在后台中应用任务完成后会调用上面介绍的四个回调，应用被强制杀死会走下面这个回调

```
-(void)URLSession:(nonnull NSURLSession *)session
             task:(nonnull NSURLSessionTask *)task
didCompleteWithError:(nullable NSError *)error {
//如果是在后台进程被杀死了,则保存一下resumeData，用于以后断点续传
        if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
              NSData *resumeData = [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData];
        }
}

```

### 29.断点续传 功能该怎么实现？
- 断点续传需要在创建NSURLSessionDownloadTask的时候传入resumeData，这样任务它就知道了上次的文件已经下载到这了，那就接着下载
#### 保存resumeData
- 一般在什么时刻保存resumeData呢
- 暂停下载

```
[downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
        if (!isRemove) {
            //将目前传递的文件数据resumeData存储到Document中
            [self saveDownloadTmpFileWithResumeData:resumeData url:urlStr];
        } else {
            [self removeDownloadTmpFileWithUrl:urlStr];
        }
}];
```
- 应用被强行杀死

```
//如果是在后台进程被杀死了,则保存一下resumeData
if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
        //将目前传递的文件数据resumeData存储到Document中
        [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
}
```
- 下载过程中出现任何错误时
#### 在下次再下载这个文件时用resumeData创建NSURLSessionDownloadTask

```
        NSURLSessionDownloadTask *downloadTask = nil;
        //之前是否有过这个文件的下载任务
        if ([self.resumeDataDic.allKeys containsObject:base64Url]) {
            //到document中找找有没有之前下载过一些的resumeData文件
            //有resumeData就恢复下载
            downloadTask = [self.session downloadTaskWithResumeData:self.resumeDataDic[base64Url]];
        } else {
            //之前没下载过这个文件,就从头下载吧
            downloadTask = [self.session downloadTaskWithURL:[NSURL URLWithString:urlStr]];
        }
        
        //设置任务描述标签为文件url
        downloadTask.taskDescription = urlStr;
        //存储downloadTask对象
        self.downloadTaskDic[base64Url] = downloadTask;
        
        //启动任务
        [downloadTask resume];
```

### 30.封装一个网络框架有哪些注意点？
- 网络请求的数据要能够缓存，但是也可以不进行缓存，缓存的数据还要可以设置缓存时间。
- 对于每次网络请求要优先从缓存中读取内容，如果缓存读取成功，就用回调成功block，然后检查缓存是否过期，过期就从网络请求数据，然后把新的数据存入到缓存中。
- 自定义一个网络配置类 NetSetting，包含发起一次网络请求所有的控制策略，将类的对象作为网络调用的参数，网络如何发起完全根据传递的NetSetting对象的设置
    * NetSetting类包含了所有的设置，包括请求方式，缓存策略，是否加密，是否自己单独控制SVProgressHud的显示。

### 31.NSUrlProtocol用过吗？用在什么地方了？
- 官方文档对 NSURLProtocol 的描述是这样的：
    * 在每一个 HTTP 请求开始时，URL 加载系统创建一个合适的 NSURLProtocol 对象处理对应的 URL 请求，而我们需要做的就是写一个继承自 NSURLProtocol 的类，并通过 - registerClass: 方法注册我们的协议类，然后 URL 加载系统就会在请求发出时使用我们创建的协议对象对该请求进行处理。
- 用处：
    * 在 Cocoa 层拦截所有 HTTP 请求的方法
    * 通过让网页来请求自定义的特定的url，来实现H5与原生应用的交互
    * 对发出请求的header进行格式化
    * 创建本地代理服务，用于数据变化时对URL请求进行更改
- 如何使用
    * 注册你的NSURLProtocol 子类
        * 当请求被加载时，系统会向每一个注册过的protocol询问：“Hey你能控制这个请求吗？”第一个通过 +canInitWithRequest: 回答为 YES 的protocol就会控制该请求。URL protocol会被以注册顺序的反序访问，所以当在-application:didFinishLoadingWithOptions:方法中调用 [NSURLProtocol registerClass:[MyURLProtocol class]];时，你自己写的protocol比其他内建的protocol拥有更高的优先级。
    * 实现+canInitWithRequest: 方法
        * 这个方法主要是说明你是否打算处理这个request，如果是返回yes，否则返回NO。
tips: 因为我们处理时的思路一般先拦截请求，然后对请求进行一定的修改或处理，然后利用NSURLSesson或者NSURLConnection来真正的发送请求。这时就没必要再对其进行处理，不然会造成死循环。所以，要有一个标示来标示这个request是否已经被我们处理过了。一般使用的方法是在- (void)startLoading方法里用
[NSURLProtocol setProperty:@YES forKey:URLProtocolHandledKey inRequest:mutableReqeust];方法来为这个request加一个property，在+canInitWithRequest:`方法里判断有没有这个property。
    * 实现 +canonicalRequestForRequest
        * 这个方法返回一个请求，即是我们修改过的请求。
    * 实现开始、停止请求方法
    * 将请求的结果通过client返回给URL Loading System因为这里我作的是NSURLConnect来做的请求，所以在NSURLConnectDataDelegate方法里面来做这件事，如果你是你的NSURLSession，方法类似。

### 32.如何在测试过程中 MOCK 各种网络环境？
- apple 同时也为我们提供了配置入口，来模拟网络环境：设置 —> 开发者 —> NETWORK LINK CONDITIONER (Status) ->Enable 打开 同时选中一个配置
- 我常用的是 100%Loss、Very Bad Network、High Latency DNS三个选项。（100%丢包，高延迟，非常差的网络）

### 33.DNS 的解析过程？网络的 DNS 优化。
- DNS：因特网上的主机，可以使用多种方式标识，比如主机名或IP地址。
    * 一种标识方法就是用它的主机名（hostname），比如·www.baidu.com、www.google.com、gaia.cs.umass.edu等。这方式方便人们记忆和接受，但是这种长度不一、没有规律的字符串路由器并不方便处理。
    * 还有一种方式，就是直接使用定长的、有着清晰层次结构的IP地址，路由器比较热衷于这种方式。
    * 为了折衷这两种方式，我们需要一种能进行主机名到IP地址转换的目录服务。这就是*域名系统（Domain Name System，DNS）的主要任务。
- DNS是：
    * 一个由分层的DNS服务器实现的分布式数据库
    * 一个使得主机能够查询分布式数据库的应用层协议
- DNS通常是由其他应用层协议所使用的，包括HTTP、SMTP等。其作用则是：将用户提供的主机名解析为IP地址
- DNS的一种简单设计就是在因特网上只使用一个DNS服务器，该服务器包含所有的映射。很明显这种设计是有很大的问题的：
    * 单点故障：如果该DNS服务器崩溃，全世界的网络随之瘫痪
    * 通信容量：单个DNS服务器必须处理所有DNS查询
    * 远距离的集中式数据库：单个DNS服务器必须面对所有用户，距离过远会有严重的时延。
    * 维护：该数据库过于庞大，还需要对新添加的主机频繁更新。
    * 所以，DNS被设计成了一个分布式、层次数据库
- DNS服务器
    * 为了处理扩展性问题，DNS使用了大量的DNS服务器，它们以层次方式组织，并且分布在全世界范围内。
    * 域名服务器是提供域名解析的服务器，在有基本的知识下，任何人都可以搭建域名服务器，甚至是根域名服务器，有名的软件有：BIND
    * 目前的DNS服务器大致分为3种类型的DNS服务器：根DNS服务器、顶级域DNS服务器、权威DNS服务器
- DNS解析过程
    * 迭代查询和递归查询
    * 图一，很清晰地显示出了一条DNS查询链：本地DNS服务器-->根DNS服务器-->顶级域DNS服务器-->权威DNS服务器 ，所有查询都是递归的。
    * 图二，这种利用了迭代查询和递归查询，从Client与本地DNS之间是递归查询，其余则是迭代查询。
所谓 递归查询过程 就是 “查询的递交者” 更替, 而 迭代查询过程 则是 “查询的递交者”不变。
从理论上讲，任何DNS查询既可以是迭代的也能是递归的。而在实际过程中，更常用的是图上 从请求主机到本地DNS服务器的查询是递归，其余查询是迭代的这种方式。

![image](https://upload-images.jianshu.io/upload_images/11034989-3f51cb7780481aad.png?imageMogr2/auto-orient/strip|imageView2/2/w/740)
    
![image](https://upload-images.jianshu.io/upload_images/11034989-b6a37d7698fd071d.png?imageMogr2/auto-orient/strip|imageView2/2/w/987)

- DNS缓存
    * DNS缓存（DNS Caching）：为了改善时延性能并减少在因特网上到处传输的DNS报文数量，DNS广泛使用了缓存技术。
    * 在一个请求链中，当某DNS服务器接收一个DNS回答时，它能将该回答中的信息缓存在本地存储器中。那么另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就可以提供所要求的IP地址，即使它不是该主机名的权威服务器。
    * 由于IP和主机名的映射并不是永久的，DNS服务器在一段时间后就会丢弃缓存的信息。
    * 本地DNS服务器也能够缓存TLD服务器的IP地址，从而允许本地DNS绕过查询链中的根DNS服务器。
    * 而事实上，有DNS的地方，就有缓存。浏览器、操作系统、本地 DNS服务器、根DNS服务器，它们都会对DNS结果做一定程度的缓存。
- DNS解析过程
- 大致分为8步：
    * 发起基于域名的请求后，首先检查本地缓存（浏览器缓存-->操作系统的hosts文件）
    * 如果本地缓存中有，直接返回目标IP地址，否则将域名解析请求发送给本地DNS服务器
    * 如果本地DNS服务器中有，直接返回目标IP地址，到这一步基本能解析80%的域名。如果没有，本地DNS服务器将解析请求发送给根DNS服务器
    * 根DNS服务器会返回给本地DNS服务器一个所查询的TLD服务器地址列表
    * 本地DNS服务器再向上一步返回的TLD服务器发送请求，TLD服务器查询并返回域名对应的权威域名服务器的地址
    * 本地DNS服务器再向上一步返回的权威域名服务器发送请求，权威域名服务器会查询存储的域名和IP的映射关系表，将IP连同一个TTL（过期时间）值返回给本地DNS服务器
    * 本地DNS服务器会将IP和主机名的映射保存起来，保存时间由TTL来控制
    * 本地DNS服务器把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束
- DNS解析安全问题
    * DNS劫持
        * 一种可能的域名劫持方式即黑客侵入了宽带路由器并对终端用户的本地DNS服务器进行篡改，指向黑客自己伪造的本地DNS服务器，进而通过控制本地DNS服务器的逻辑返回错误的IP信息进行域名劫持。
        * 另一方面，由于DNS解析主要是基于UDP协议，除了上述攻击行为外，攻击者还可以监听终端用户的域名解析请求，并在本地DNS服务器返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。
    * 缓存污染（DNS污染）。
        * 我们知道在接收到域名解析请求时，本地DNS服务器首先会查找缓存，如果缓存命中就会直接返回缓存结果，不再进行递归DNS查询。这时候如果本地DNS服务器针对部分域名的缓存进行更改，比如将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。
- 如何解决DNS劫持？
    * DNS解析发生在HTTP协议之前，DNS解析和DNS劫持和HTTP没有关系，DNS协议使用的是UDP协议向服务器的53端口进行请求。
    * 可以使用HttpDNS的方案：使用 HTTP协议向DNS服务器的80端口进行请求,来规避DNS劫持
    * 在终端上，可以更换DNS服务器，不管手机还是电脑，都能手动配置DNS

### 34.DNS劫持和预防
- DNS解析安全问题
    * DNS劫持
        * 一种可能的域名劫持方式即黑客侵入了宽带路由器并对终端用户的本地DNS服务器进行篡改，指向黑客自己伪造的本地DNS服务器，进而通过控制本地DNS服务器的逻辑返回错误的IP信息进行域名劫持。
        * 另一方面，由于DNS解析主要是基于UDP协议，除了上述攻击行为外，攻击者还可以监听终端用户的域名解析请求，并在本地DNS服务器返回正确结果之前将伪造的DNS解析响应传递给终端用户，进而控制终端用户的域名访问行为。
    * 缓存污染（DNS污染）。
        * 我们知道在接收到域名解析请求时，本地DNS服务器首先会查找缓存，如果缓存命中就会直接返回缓存结果，不再进行递归DNS查询。这时候如果本地DNS服务器针对部分域名的缓存进行更改，比如将缓存结果指向第三方的广告页，就会导致用户的访问请求被引导到这些广告页地址上。
- 如何解决DNS劫持？
    * DNS解析发生在HTTP协议之前，DNS解析和DNS劫持和HTTP没有关系，DNS协议使用的是UDP协议向服务器的53端口进行请求。
    * 可以使用HttpDNS的方案：使用 HTTP协议向DNS服务器的80端口进行请求,来规避DNS劫持
    * 在终端上，可以更换DNS服务器，不管手机还是电脑，都能手动配置DNS

### 35.网络请求的状态码都大致代表什么意思？
- 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:
    * 1xx：指示信息--表示请求已接收，继续处理
    * 2xx：成功--表示请求已被成功接收、理解、接受
    * 3xx：重定向--要完成请求必须进行更进一步的操作
    * 4xx：客户端错误--请求有语法错误或请求无法实现
    * 5xx：服务器端错误--服务器未能实现合法的请求
    * 200 OK //客户端请求成功
    * 400 BadRequest//客户端请求有语法错误，不能被服务器所理解
    * 403 Forbidden//服务器收到请求，但是拒绝提供服务
    * 404 NotFound//请求资源不存在，eg：输入了错误的URL
    * 500 Internal Server Error //服务器发生不可预期的错误
    * 503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常

### 36.说说为什么要设计304这个状态码
- 304状态码或许不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。
- 客户端在请求一个文件的时候，发现自己有缓存的文件，那么在请求中会包含 If Modified Since，如果请求中包含 If Modified Since，就说明已经有缓存在客户端。服务端只要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200 。

### 37.Wireshark、Charles、Paw 等工具会使用吗？
- 抓包工具
- Wireshark
    * 打开捕获选项
    * 设置过滤器
    * 点击开始，然后访问该域名的url地址，可以看到tcp三次握手了ssl/tls握手
    * 在捕获结果中过滤
- Charles
    * 安装证书
    * 添加到信任
    * 添加要抓包的域名的ssl代理设置
    * 增加url，然后访问该域名的url地址

### 38.抓包软件 Charles 的原理是什么？说一下中间人攻击的过程。
- 抓取https包的时候,青花瓷会要求使用者 对抓包的设备，安装一个证书,安装这个证书的时候,其实是安装了一个根证书，当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任
- 当客户端设置了代理,并且开始发出网络请求的时候,这个网络请求的校验过程就会变成这样

![image](https://upload-images.jianshu.io/upload_images/5505686-1c2bb870ed73506f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1060)

- 当客户端Client对服务器Server发送请求(带着随机数和加密算法),由于青花瓷做了代理,请求被青花瓷拦截,处理(青花瓷的角色现在对于Client来说是服务器),青花瓷将客户端带的随机数和加密算法处理,然后返回自己的证书通过客户端校验,获取到客户端提交的请求参数等数据,
- 青花瓷得到服务器数据的返回结果之后,开始继续和过程1中的Client以服务器的身份,去做处理,首先收到客户端的随机数和加密算法,自己生成一个随机数和选择一个客户端的加密算法,然后青花瓷会返回一个伪造的CA证书(公钥和真实的server不一样,但是域名是一样的,或者说,除了域名是一致的,其他的都不是一致的,而且这个签发机构是青花瓷之前让你安装的根证书 签发的,所以,当返回这个证书的时候,你的客户端的信任链是可以完成的,会被系统信任),然后Client在这个伪造的证书(对于青花瓷和Client是真实证书(验证信任链和证书信息都通过了),但是和真实的域名对应的证书来看,是伪造证书)的基础上,和青花瓷通信,然后青花瓷再和Server通信,成了一个中间人的角色,这样,整个过程的数据传输,都被青花瓷给监听到了在此,中间人攻击的过程 就完成了

### 39.你知道常见的网络攻击么
- 信息安全三要素
    * 保密性（Confidentiality）：指网络信息不被泄露给非授权的用户、实体或过程。
    * 完整性（Integrity）：在传输、存储信息或数据的过程中，确保信息或数据不被采授权的用户篡改或在篡改后能够被迅速发现。
    * 用性（Availability）：保证合法用户对信息和资源的使用不会被不正当地拒绝。
- 暴力破解
    * 暴力破解主要是针对"保密性"的，它的攻击原理非常简单，就是攻击者通过大量组合尝试所有的可能性破解用户的账户名、密码等敏感信息。是不是有种开数字密码锁的感觉，其实本质是相似的。
    * 暴力破解攻击是通过巨大的尝试次数获得一定成功率的的。大量的暴力破解请求会导致服务器日志中出现大量异常记录，所以暴力破解不算是很复杂的攻击类型，只需要服务器进行有效的监控和分析就可以避免这类攻击。
- 恶意软件
    * 恶意软件主要是针对系统"完整性"的攻击，主要也分为两大类：病毒和蠕虫 ，两者的区别在与需要交互的感染，病毒是需要用户交互来感染的恶意软件，而蠕虫是利用网络进行复制和传播，无需任何明显用户交互就能进入设备的恶意软件，像最近常听到的 "挖矿蠕虫"。
    * 病毒是需要具体的交互来感染的恶意软件，所以我们正确使用电子邮件和即时通讯软件，遇到聊天过程中的陌生链接和邮件附件时，尽量不要打开这类链接和程序。蠕虫可以通过防火墙过滤潜在的破坏性代码，及时更新系统补丁和反病毒软件来实现防护。
- DDoS 攻击
    * DDoS 攻击全称：分布式拒绝服务。说起 DDoS ，不得不提及 DoS 攻击。DoS 攻击即拒绝服务攻击凡是能导致合法用户正常请求无法正常访问网络服务的行为都算是拒绝服务攻击，DDoS 也就是分布式的多个 DoS 攻击同时攻击受害服务器。
    * DDoS 攻击是利用流量来攻击服务器以及网站，假如服务器的带宽只有 100M，这时突然进来了 200M 带宽的流量，服务器是没有办法承载 200M 流量的，导致网络瞬间崩溃，服务器无法连接，服务也无法访问。因为突然进来的 200M 带宽占满了服务器 100M 带宽，
    * DDoS 攻击手段是分布式的，改变了传统的点对点的攻击模式，使攻击方式出现了没有规律的情况，而且在进行攻击时，通常使用的也是常见的协议和服务，这样只是从协议和服务的类型上是很难对攻击进行区分。进行攻击时，数据包都经过伪装，源 IP 地址也是伪造的，致使很难对攻击进行地址确定，查找起来极其困难。

### 40.如何判断一个请求是否结束？
- 同下

### 补充：用户需要上传和下载一个重要的资料文件，应该如何判断用户本次是否上传成功和下载成功了?
- 用MD5验证文件的完整性！(仅仅通过代码来判断当前次的请求发送结束或者收到数据结束不可以的)
- 当客户端上传一个文件的时候，在请求body里面添加该文件的MD5值来告诉服务器，服务器接受文件完毕以后通过校验收到的文件的MD5值与请求body里面的MD5值来最终确定本次上传是否成功
- 当客户端下载一个文件的时候，在响应头里面收到了服务器附带的该文件的MD5值，文件下载结束以后，通过获取下载后文件的MD5值与本次请求服务器返回的响应头中的MD5值做一个比较，来最终判断本次下载是否成功
- MD5，是一个将任意长度的数据字符串转化成短的固定长度的值的单向操作。任意两个字符串不应有相同的散列值
- MD5校验可以应用在多个领域，比如说机密资料的检验，下载文件的检验，明文密码的加密等。MD5校验原理举例：如客户往我们数据中心同步一个文件，该文件使用MD5校验，那么客户在发送文件的同时会再发一个存有校验码的文件，我们拿到该文件后做MD5运算，得到的计算结果与客户发送的校验码相比较，如果一致则认为客户发送的文件没有出错，否则认为文件出错需要重新发送。

### 41.Web登录时怎么保持会话状态的
- 利用Cookie机制实现
    * 我们知道cookie是为了解决http无状态的一种技术，被电商、oa等web应用广泛使用。如果我们的App和后端通讯采用的http通讯方式，可以利用cookie技术进行登录状态保持。比如我们可以把sessionID和有效期保存在cookie中，发给前端App，前端App收到后保存在本地。当访问后端服务把sessionID和有效期作为参数传给后台进行认证。直到sessionID失效，用户都不需要重新登录。
- 本地保存用户名和密码
    * 当用户第一次输入账号和密码的时候，APP端本地保存用户的账号和密码，下次启动的时候获取本地保存的账户和密码进行登录，由我们开发者在后台进行登录处理，不过这个有个不是太合适的就是相当于在APP本地保存了用户的这些信息，意义上来说不安全，
- 前后端配合采用token方式
    * token方式在app认证上用的比较普遍，App初始登录时，提交账号和密码数据给服务端，服务端根据定义的的策略生成一个token字符串，token字符串中可以包含用户信息、设备ID等信息以保证用户的唯一性，服务端并对token设置一定的期限。服务端把生成的token字符串传给客户端，客户端保存token字符串，并在接下来的请求中带上这个字符串。相对于在App本地token的安全性更高了。
    * 设备唯一ID的问题，在实际开发使用设备ID唯一性的处理，就是UUID + 手机号码 + iOS（平台），安卓就是UUID + 手机号码 + Android。这样子就不仅避免了同一台设备登录多个账号的问题，还区分了不同平台登录的账号。

### 42.SSL 传输协议？说一下 SSL 验证过程？
- SSL(Secure Sockets Layer, 安全套接字层)，因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点，比如传输内容会被偷窥（嗅探）和篡改。 SSL 协议的作用就是在传输层对网络连接进行加密。
- 简单来说，HTTPS = HTTP + SSL/TLS, 也就是 HTTP over SSL 或 HTTP over TLS，这是后面加 S 的由来 。
- 客户端和服务端建立 SSL 握手：客户端通过 CA 证书来确认服务端的身份；互相传递三个随机数，之后通过这随机数来生成一个密钥；互相确认密钥，然后握手结束；数据通讯开始，都使用同一个对话密钥来加解密；
    * 首先，客户端 A 访问服务器 B ，比如我们用浏览器打开一个网页 https://www.baidu.com ，这时，浏览器就是客户端 A ，百度的服务器就是服务器 B 了。这时候客户端 A 会生成一个随机数1，把随机数1 、自己支持的 SSL 版本号以及加密算法等这些信息告诉服务器 B 。
    * 服务器 B 知道这些信息后，确认一下双方的加密算法，然后服务端也生成一个随机数 B ，并将随机数 B 和 CA 颁发给自己的证书一同返回给客户端 A 。
    * 客户端 A 得到 CA 证书后，会去校验该 CA 证书的有效性，校验方法在上面已经说过了。校验通过后，客户端生成一个随机数3 ，然后用证书中的公钥加密随机数3 并传输给服务端 B 。服务端 B 得到加密后的随机数3，然后利用私钥进行解密，得到真正的随机数3。
    * 最后，客户端 A 和服务端 B 都有随机数1、随机数2、随机数3，然后双方利用这三个随机数生成一个对话密钥。之后传输内容就是利用对话密钥来进行加解密了。这时就是利用了对称加密，一般用的都是 AES 算法。
    * 客户端 A 通知服务端 B ，指明后面的通讯用对话密钥来完成，同时通知服务器 B 客户端 A 的握手过程结束。
    * 服务端 B 通知客户端 A，指明后面的通讯用对话密钥来完成，同时通知客户端 A 服务器 B 的握手过程结束。
    * SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户端 A 和服务器 B 开始使用相同的对话密钥进行数据通讯。

### 43.解释一下 Http 的持久连接？
- 在HTTP1.0中，默认的是短连接，没有正式规定 Connection:Keep-alive 操作；
- 在HTTP1.1中所有连接都是Keep-alive的，也就是默认都是持续连接的（Persistent Connection）。
- 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。
- 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度也就相应提高了。

### 44.你知道cookie和session的区别么
- 由于HTTP是一种无状态协议,服务器没有办法单单从网络连接上面知道访问者的身份,为了解决这个问题,就诞生了Cookie，Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。实际就是颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理
- Cookie可以让服务端程序跟踪每个客户端的访问，但是每次客户端的访问都必须传回这些 Cookie，如果 Cookie很多，这无形地增加了客户端与服务端的数据传输量，而 Session的出现正是为了解决这个问题。同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie值，而是只要传回一个ID，这个ID是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的ID，客户端只要传回这个 ID就行了，这个ID通常是NANE为JSESIONID的一个 Cookie。
- cookie机制
    * cookie的内容主要包括name(名字)、value(值)、maxAge(失效时间)、path(路径),domain(域)和secure
    * name：cookie的名字，一旦创建，名称不可更改。
    * value：cookie的值，如果值为Unicode字符，需要为字符编码。如果为二进制数据，则需要使用BASE64编码.
    * maxAge：cookie失效时间，单位秒。如果为正数，则该cookie在maxAge后失效。如果为负数，该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，表示删除该cookie。默认为-1
    * path：该cookie的使用路径。如果设置为"/sessionWeb/"，则只有ContextPath为“/sessionWeb/”的程序可以访问该cookie。如果设置为“/”，则本域名下ContextPath都可以访问该cookie。
    * domain:域.可以访问该Cookie的域名。第一个字符必须为".",如果设置为".google.com",则所有以"google.com结尾的域名都可以访问该cookie",如果不设置,则为所有域名
    * secure：该cookie是否仅被使用安全协议传输。
- Session机制
    * Session机制是一种服务端的机制，服务器使用一种类似散列表的结构来保存信息。
    * 当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端里的请求里是否已包含了一个session标识--sessionID，如果已经包含一个sessionID，则说明以前已经为此客户端创建过session，服务器就按照sessionID把这个session检索出来使用
    * 如果客户端请求不包含sessionID，则为此客户端创建一个session并且声称一个与此session相关联的sessionID，sessionID的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串(服务器会自动创建),这个sessionID将被在本次响应中返回给客户端保存。
- 使用cookie的缺点
    * 如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，cookie可以被用户禁止
    * cookie不安全(对于敏感数据，需要加密)
    * cookie只能保存少量的数据(大约是4k)，cookie的数量也有限制(大约是几百个)，不同浏览器设置不一样，反正都不多
    * cookie只能保存字符串，对服务器压力小
- 使用session的缺点
    * 一般是寄生在Cookie下的，当Cookie被禁止，Session也被禁止
    * 当然可以通过url重写来摆脱cookie
    * 当用户访问量很大时，对服务器压力大
    * 我们现在知道session是将用户信息储存在服务器上面,如果访问服务器的用户越来越多,那么服务器上面的session也越来越多, session会对服务器造成压力，影响服务器的负载.如果Session内容过于复杂，当大量客户访问服务器时还可能会导致内存溢出。
    * 用户信息丢失,或者说用户访问的不是这台服务器的情况下,就会出现数据库丢失.
- cookie和session的区别
    * 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的
    * cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗，考虑到安全应当使用session
    * session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie
    * 单个cookie保存的数据不能超过4k,很多浏览器都限制一个站点最多保存20个cookie。
    * 可以将登陆信息等重要信息存放为session。

### 45.发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?
### 46.使用异步请求的方式抓取一个网站的内容，请考虑超时，状态码的异常情况（请用原生API或者Socket/Cocoa Socket）
### 47.在网络请求中，如何处理网络网速慢，网络中断、网络抖动等等网络问题？
### 48.说说点击一个按钮后打开一个web页面从发送网络请求到页面展示都做了啥
- DNS解析
- TCP连接
- 发送HTTP请求
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- 连接结束
- 具体过程：
    * HTTP请求阶段：向服务器发送请求
        * 浏览器首先向 DNS域名解析服务器发送请求
        * DNS 反解析：根据浏览器请求地址中的域名，到 DNS 服务器中找到对应的服务器外网 IP 地址
        * 通过外网 IP 向对应服务器发送请求（首先访问的服务器 Web 站点管理工具，准确来说先基于工具在服务器上面创建很多服务，当有客户访问的时候，服务器会匹配出具体是请求哪个服务 ）
        * 通过 URL 中携带的端口号找到服务器上对应的服务，以及服务所管理的项目源文件
    * HTTP相应阶段：服务端把客户端需要的内容准备好，并且响应给客户
        * 服务器端根据请求地址中路径名称，问号传参或者哈希值，把客户端需要的内容进行准备和处理
        * 把准备的内容响应给客户端（如果请求的是 html 或 css 等这样的资源文件，服务器返回的是资源文件中的源代码[不是文件本身]）
    * 浏览器渲染阶段
        * 客户端浏览器接收到服务器返回代码，基于自己渲染引擎开始进行绘制和渲染
            * 首先计算 DOM 结构，生成 DOM TREE
            * 自上而下运行代码，加载 CSS 等资源内容
            * 根据获取的 CSS 生成带样式的 RENDER TREE
            * 开始渲染

### 49.为什么能通过一个URL就能请求到对应的资源（域名解析等）
### 50.如果客户端上有个按钮，点击会触发一次网络请求，在短时间内快速点击，怎么处理（从客户端以及服务端角度思考）
### 51.判断一个字符串是不是ipv6地址（要求尽全力的考虑所有异常的情况）
### 52.你平时怎么解决网络请求的依赖关系：当一个接口的请求需要依赖于另一个网络请求的结果
#### 思路一：操作依赖：NSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求）

```
[operationB addDependency:operationA]; // 操作B依赖于操作
```
#### 思路二：逻辑判断：在上一个网络请求的响应回调中进行下一网络请求的激活（不适用，可能拿不到回调）
#### 思路三：线程同步 -- 组队列（dispatch_group）
- 当group里所有事件都完成GCD API有两种方式发送通知，第一种是DispatchGroup.wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用DispatchGroup.notify，异步执行闭包，不会阻塞当前线程。

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片… …
});
```

```
//阻塞当前的线程,直到dispatch group中的所有任务完成才会返回,可能会卡住主线程,造成页面卡顿,谨慎使用
dispatch_group_wait(serviceGroup,DISPATCH_TIME_FOREVER);
```

#### 思路四：线程同步 --阻塞任务（dispatch_barrier）也叫栅栏函数：

```
/* 创建并发队列 */
dispatch_queue_t concurrentQueue = dispatch_queue_create("test.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);
/* 添加两个并发操作A和B，即A和B会并发执行 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationA");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationB");
});
/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */
dispatch_barrier_async(concurrentQueue, ^(){
    NSLog(@"OperationBarrier!");
});
/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationC");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationD");
});
```
#### 思路五：线程同步 -- 信号量机制（dispatch_semaphore）：

```
/* 创建一个信号量 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

/* 任务1 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 耗时任务1 */
    NSLog(@"任务1开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务1结束");
    /* 任务1结束，发送信号告诉任务2可以开始了 */
    dispatch_semaphore_signal(semaphore);
});

/* 任务2 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 等待任务1结束获得信号量, 无限等待 */
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    /* 如果获得信号量则开始任务2 */
    NSLog(@"任务2开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务2结束");
});
[NSThread sleepForTimeInterval:10];
```
- 或者

```
/* 创建一个信号量 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
/* 任务1 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 耗时任务1 */
    NSLog(@"任务1开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务1结束");
    /* 任务1结束，发送信号告诉任务2可以开始了 */
    dispatch_semaphore_signal(semaphore);
});
/* 任务2 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 等待任务1结束获得信号量, 无限等待 */
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    /* 如果获得信号量则开始任务2 */
    NSLog(@"任务2开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务2结束");
});

//我们每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后，而我们dispatch_semaphore_signal(sem)是在网络请求的回调里调用的

    dispatch_semaphore_t sem = dispatch_semaphore_create(0);
    for (int i=0; i<10; i++) {
        
        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            
            NSLog(@"%d---%d",i,i);
            dispatch_semaphore_signal(sem);
        }];
        
        [task resume];
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"end");
    });
```

## 消息传递的方式
### 1.说一下 NSNotification 的实现机制？
- 使用观察者模式来实现的用于跨层传递信息的机制。传递方式是一对多的。
- 如果实现通知机制？
    * 应用服务提供商从服务器端把要发送的消息和设备令牌（device token）发送给苹果的消息推送服务器APNs。
    * APNs根据设备令牌在已注册的设备（iPhone、iPad、iTouch、mac等）查找对应的设备，将消息发送给相应的设备。
    * 客户端设备接将接收到的消息传递给相应的应用程序，应用程序根据用户设置弹出通知消息。

### 2.说一下 NSNotification 的特点。
### 3.简述 KVO 的实现机制。或者是KVO的使用？实现原理？（为什么要创建子类来实现）
- 概述
    * KVO，即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则其观察者就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。
    * KVO其实也是“观察者”设计模式的一种应用。这种模式有利于两个类间的解耦合，尤其是对于 业务逻辑与视图控制 这两个功能的解耦合。
    
- 实现原理
    * KVO 是基于运行时实现的 isa   Class   NSKVONotifying_Person
    * 基本的原理：当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter 方法。setter 方法随后负责通知观察对象属性的改变状况。
    * 基本的步骤：
        - 注册观察者，实施监听；
        - 在回调方法中处理属性发生的变化；
        - 移除观察者
    * Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；）
        - NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。
        - 子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。

- KVC与KVO的不同？
    * KVC(键值编码)，即Key-Value Coding，一个非正式的Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用Setter、Getter方法等显式的存取方式去问。
    * KVO(键值监听)，即Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后,对象就会接受到通知，前提是执行了setter方法、或者使用了KVC赋值。

- 和notification(通知)的区别？
    * notification比KVO多了发送通知的一步。两者都是一对多，但是对象之间直接的交互，notification明显得多，需要notificationCenter来做为中间交互。而KVO如我们介绍的，设置观察者->处理属性变化，至于中间通知这一环，则隐秘多了，只留一句“交由系统通知”，具体的可参照以上实现过程的剖析。
notification的优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，例如键盘、前后台等系统通知的使用也更显灵活方便。

- 与delegate的不同？
    * 和delegate一样，KVO和NSNotification的作用都是类与类之间的通信。但是与delegate不同的是：
这两个都是负责发送接收通知，剩下的事情由系统处理，所以不用返回值；而delegate 则需要通信的对象通过变量(代理)联系；
delegate一般是一对一，而这两个可以一对多。

- 总结
    * 对比其他的回调方式，KVO机制的运用的实现，更多的由系统支持，相比notification、delegate等更简洁些，并且能够提供观察属性的最新值以及原始值；但是相应的在创建子类、重写方法等等方面的内存消耗是很巨大的。所以对于两个类之间的通信，我们可以根据实际开发的环境采用不同的方法，使得开发的项目更加简洁实用。
    * 另外需要注意的是，由于这种继承方式的注入是在运行时而不是编译时实现的，如果给定的实例没有观察者，那么KVO不会有任何开销，因为此时根本就没有KVO代码存在。但是即使没有观察者，委托和NSNotification还是得工作，这也是KVO此处零开销观察的优势。
    * 异步:监听通知 主线程:发出通知 接收通知代码在主线程
    * 主线程:监听通知 异步:发出通知 接收通知代码在异步
    * 注意:在接收通知代码中 可以加上主队列任务
    * 总结:接收通知代码 由 发出通知线程决定, KVO也一样

- 代码
```
#import "ViewController.h"
#import "Person.h"

@interface ViewController ()
/** p1 */
@property (strong, nonatomic) Person *p1;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.什么是通知
    
    // 3个对象
    self.p1 = [[Person alloc] init];
    self.p1.name = @"p1";
    //打印监听前类信息
    [p1 printInfo];
    // KVO是监听对象的属性值的改变的
    [self.p1 addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];
    self.p1.name = @"123";
    //打印监听后类信息
     [p1 printInfo];
     [p1 removeObserver:self forKeyPath:@"name"];
     //打印移除监听后类信息
     [p1 printInfo];
}

// 这个方法时属于 NSObject 类的，任何对象都可以作为观察者
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context
{
    NSLog(@"监听到了%@的%@属性发生了改变", object, keyPath);
    NSLog(@"%@", change);
}

@end

person类方法：

-(void)printInfo
{
    NSLog(@"isa:%@, supper class:%@", NSStringFromClass(object_getClass(self)),
          class_getSuperclass(object_getClass(self)));
    
    NSLog(@"self:%@, [self superclass]:%@", self, [self superclass]);
    
    NSLog(@"age setter function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(setAge:)));
    
    NSLog(@"name setter function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(setName:)));
    NSLog(@"printInfo function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(printInfo)));
}
```
- KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：
    * 上述例子中，当 p1.name 的值改变时，p1对象的 isa 指针会指向 NSKVONotifying_Person，意味着，在程序运行时，会动态生成一个 NSKVONotifying_Person 类，该类继承于 Person，而且该类中也有个 -setName: 方法，方法中在设置 name 的同时实现了：
```
- (void)setName:(NSString *)name
{
    [super setName:name];
    
    // 这两个方法底层会调用observer的- (void)observeValueForKeyPath: ofObject: change: context:这个方法
    [self willChangeValueForKey:@"age"];
    [self didChangeValueForKey:@"age"];
}

```
- 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行KVO的回调方法，例如是否执行了setter方法、或者是否使用了KVC赋值。
如果赋值没有通过setter方法或者KVC，而是直接修改属性对应的成员变量，例如：仅调用_name = @"newName"，这时是不会触发kvo机制，更加不会调用回调方法的。
所以使用KVO机制的前提是遵循 KVO 的属性设置方式来变更属性值。

### 4.KVO 在使用过程中有哪些注意点？有没有使用过其他优秀的 KVO 三方替代框架？
### 5.消息通知有几种？如何判断是否发送通知。
- 不传递参数, 最常用的一种
- 使用object 传递消息 
- 使用userInfo 传递消息

### 6.简述 KVO 的注册依赖键是什么？
- 有时候，我们监听的某个属性值可能会依赖于其他多个属性，只要其他属性发生了改变都会导致我们监听的属性发生变化，这种就叫做依赖键。
- 例如，在Person类中有一个personInfo的属性，它返回的是对象的name和age的组合：

```
- (NSString *)personInfo
{
    return [NSString stringWithFormat:@"person's name:%@ age:%d", self.name, self.age];
}
```
- 如果我们对personInfo进行监听，则name和age的变化也会导致personInfo发生变化，这时候我们就需要设置依赖键。

```
+ (NSSet *)keyPathsForValuesAffectingPersonInfo
{
    return [NSSet setWithObjects:@"name", @"age", nil];
}
```
然后再对personInfo进行注册监听，之后如果我们对name或者age的值进行修改的时候，观察者就会收到这样的通知：

```
CollectionViewTest[742:17933] {
    kind = 1;
    new = "person's name:hexintao age:0";
}
```
- 也就是当关联属性中的任何一个发生了变化，我们监听的这个属性就会收到通知，说明其值发生了变化。

### 7.如何做到 KVO手动通知？，如何手动触发一个value的KVO
- 所谓的“手动触发”是区别于“自动触发”：
- 自动触发是指类似这种场景：在注册 KVO 之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了。
- 想知道如何手动触发，必须知道自动触发 KVO 的原理：
    * 键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了。
    * 那么“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。
具体做法如下：

如果这个 value 是 表示时间的 self.now ，那么代码如下：最后两行代码缺一不可。

```
//  .m文件
//  手动触发 value 的KVO，最后两行代码缺一不可。

//@property (nonatomic, strong) NSDate *now;
- (void)viewDidLoad {
   [super viewDidLoad];
   _now = [NSDate date];
   [self addObserver:self forKeyPath:@"now" options:NSKeyValueObservingOptionNew context:nil];
   NSLog(@"1");
   [self willChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
   NSLog(@"2");
   [self didChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
   NSLog(@"4");
}
```
但是平时我们一般不会这么干，我们都是等系统去“自动触发”。“自动触发”的实现原理：
> 比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。

大家可能以为这是因为 setNow: 是合成方法，有时候我们也能看到有人这么写代码:

```
- (void)setNow:(NSDate *)aDate {
   [self willChangeValueForKey:@"now"]; // 没有必要
   _now = aDate;
   [self didChangeValueForKey:@"now"];// 没有必要
}
```
这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 。

### 8.在什么情况下会触发 KVO?
### 9.给实例变量赋值时，是否会触发 KVO?
- KVO的运行是通过重写setter方法来触发通知机制的，也就是说，如果你直接赋值给实例变量而不是使用属性赋值的话，是不会触发KVO的。
- 使用KVC来给实例变量赋值，会触发KVO

### 10.Delegate通常用什么关键字修饰？为什么？
- 通常来说，delegate都使用weak修饰，为了避免循环引用，但是并不是所有的情况都如此，通过NSURLSession的头文件我们发现，NSURLSession对于它的 delegate属性是强引用。这就意味着当session存在时，其delegate就不会被释放。另外，由session发起请求的缓存相关对象也会被其强引用并一直保留在内存中。

### 11.通知 和 代理 有什么区别？各自适应的场景？
- 和delegate一样，KVO和NSNotification的作用都是类与类之间的通信。但是与delegate不同的是： 这两个都是负责发送接收通知，剩下的事情由系统处理，所以不用返回值；而delegate 则需要通信的对象通过变量(代理)联系； delegate一般是一对一，而这两个可以一对多。

#### 分类
- 分类的作用？
    * 声明私有方法，分解体积大的类文件，把framework的私有方法公开
- 分类的特点
    * 运行时决议，可以为系统类添加分类 。
    * 说得详细些，在运行时时期，将 Category 中的实例方法列表、协议列表、属性列表添加到主类中后（所以Category中的方法在方法列表中的位置是在主类的同名方法之前的），然后会递归调用所有类的 load 方法，这一切都是在main函数之前执行的。
- 分类可以添加哪些内容？
    * 实例方法，类方法，协议，属性（添加getter和setter方法，并没有实例变量，添加实例变量需要用关联对象）
- 如果工程里有两个分类A和B，两个分类中有一个同名的方法，哪个方法最终生效？
    * 取决于分类的编译顺序，最后编译的那个分类的同名方法最终生效，而之前的都会被覆盖掉(这里并不是真正的覆盖，因为其余方法仍然存在，只是访问不到，因为在动态添加类的方法的时候是倒序遍历方法列表的，而最后编译的分类的方法会放在方法列表前面，访问的时候就会先被访问到，同理如果声明了一个和原类方法同名的方法，也会覆盖掉原类的方法)。
- 如果声明了两个同名的分类会怎样？
    * 会报错，所以第三方的分类，一般都带有命名前缀
- 分类能添加成员变量吗？
    * 不能。只能通过关联对象(objc_setAssociatedObject)来模拟实现成员变量，但其实质是关联内容，所有对象的关联内容都放在同一个全局容器哈希表中:AssociationsHashMap,由AssociationsManager统一管理。
#### 扩展
- 一般用扩展做什么？
    * 声明私有属性，声明方法（没什么意义），声明私有成员变量
- 扩展的特点
    * 编译时决议，只能以声明的形式存在，多数情况下寄生在宿主类的.m中，不能为系统类添加扩展。
#### 代理（Delegate）
- 代理是一种设计模式，以@protocol形式体现，一般是一对一传递。
- 一般以weak关键词以规避循环引用。

### 12.说一下什么是Block?
- Block是将函数及其执行上下文封装起来的对象。
- block内部有isa指针，所以说其本质也是OC对象

### 13.Block 有几种类型？分别是什么？
- 三种类型：
    * 全局Block(_NSConcreteGlobalBlock)
    * 栈Block(_NSConcreteStackBlock)
    * 堆Block(_NSConcreteMallocBlock)
- 其中栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区
- 不使用外部变量的block是全局block
- 使用外部变量并且未进行copy操作的block是栈block
- 对栈block进行copy操作，就是堆block，而对全局block进行copy，仍是全局block，即如果对栈Block进行copy，将会copy到堆区，对堆Block进行copy，将会增加引用计数，对全局Block进行copy，因为是已经初始化的，所以什么也不做。

### 14.Block 用什么修饰？copy，assign，strong有什么区别？
- 用copy修饰；
- block本身是像对象一样可以使用strong。但是block在创建的时候，它的内存是分配在栈上的，而不是在堆上。它本身的作用域是属于创建的时候的作用域，一旦在创建的时候的作用域外面调用block将导致程序崩溃。因为栈区的特点就是创建的对象随时可能被销毁，一旦被销毁后续再次调用空对象会造成程序崩溃，在对block进行copy后，block存放在堆区。
- 用strong也可以，但是block的strong行为默认是用copy的行为实现的，因为block变量默认是声明为栈变量的，为了能够在block的声明域外使用，所以要把block拷贝（copy）到堆，所以说为了block属性声明和实际的操作一致，最好声明为copy。

### 15.Block 后面携带参数的时候，有数量限制吗？为什么？
### 16.__block 的解释以及在 ARC 和 MRC 下有什么不同？
- MRC 环境下，block 截获外部用 __block 修饰的变量，不会增加对象的引用计数
- ARC 环境下，block 截获外部用 __block 修饰的变量，会增加对象的引用计数

### 补充：在block内如何修改block外部变量?
- 默认情况下,在block中访问的外部变量是复制过去的,即:写操作不对原变量生效
- 这里是把栈中的a,复制了一份到堆中(只是一个简单的值传递,堆中的暂且称之为b,下面也这样称呼),两个内存空间,所以修改栈中的a,不影响堆中的b.
- 如果我们想要修改外部变量的值,我们可以加上__block来进行操作
- 为什么加上__block就生效了？
    * Block不允许修改外部变量的值,这里所说的外部变量的值,指的是.__block 所起到的作用就是只要观察到该变量被 block 所持有,就会将a包装成一个结构体__Block_byref_a_0,初始化a=0,然后将该结构体的指针传递到了堆中.因而在block内部也可以修改外部变量的值.a在结构体里变成了一个属性(该结构体持有局部的原始变量),也有__forwarding这个指针. 这时候栈里面结构体的__forwarding 指向了堆中的结构体,堆中结构体的__forwarding 指向了自己,这就保证了无论是栈中的还是堆中的,都是访问的同一个值a
- Block不允许修改外部变量的值这样的设计,应该是考虑到了block的特殊性,block也属于“函数”的范畴,变量进入block,实际就是已经改变了作用域.在几个作用域之间进行切换时,如果不加上这样的限制,变量的可维护性将大大降低.又比如我想在block内声明了一个与外部同名的变量,此时是允许呢还是不允许呢?
- 可以看到,定义后和block内部内存地址是一样的,我们都知道 block 内部的变量会被放到堆区,“block内部”打印的是堆地址,因而也就可以知道,“定义后”打印的也是堆的地址.
- 结论:a在定义前是在栈区(),进入block区域后,变成了堆区.这才是__block关键字的作用

### 17.Block 的内存管理。
### 18.Block 自动截取变量。
#### 局部变量截获 是值截获。 比如:

```
    NSInteger num = 3;
    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){
        
        return n*num;
    };
    
    num = 1;
    
    NSLog(@"%zd",block(2));
```
- 这里的输出是6而不是2，原因就是对局部变量num的截获是值截获。
- 同样，在block里如果修改变量num，也是无效的，甚至编译器会报错。

```
NSMutableArray * arr = [NSMutableArray arrayWithObjects:@"1",@"2", nil];
    
    void(^block)(void) = ^{
        
        NSLog(@"%@",arr);//局部变量
        
        [arr addObject:@"4"];
    };
    
    [arr addObject:@"3"];
    
    arr = nil;
    
    block();
```
- 打印为1，2，3
- 局部对象变量也是一样，截获的是值，而不是指针，在外部将其置为nil，对block没有影响，而该对象调用方法会影响
#### 局部静态变量截获 是指针截获。

```
static  NSInteger num = 3;
    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){
        
        return n*num;
    };
    
    num = 1;
    
    NSLog(@"%zd",block(2));
```
- 输出为2，意味着num=1这里的修改num值是有效的，即是指针截获。
- 同样，在block里去修改变量m，也是有效的。
#### 全局变量，静态全局变量截获：不截获,直接取值。
- 我们同样用clang编译看下结果。

```
static NSInteger num3 = 300;

NSInteger num4 = 3000;

- (void)blockTest
{
    NSInteger num = 30;
    
    static NSInteger num2 = 3;
    
    __block NSInteger num5 = 30000;
    
    void(^block)(void) = ^{
        
        NSLog(@"%zd",num);//局部变量
        
        NSLog(@"%zd",num2);//静态变量
        
        NSLog(@"%zd",num3);//全局变量
        
        NSLog(@"%zd",num4);//全局静态变量
        
        NSLog(@"%zd",num5);//__block修饰变量
    };
    
    block();
}
```
- 编译后

```
struct __WYTest__blockTest_block_impl_0 {
  struct __block_impl impl;
  struct __WYTest__blockTest_block_desc_0* Desc;
  NSInteger num;//局部变量
  NSInteger *num2;//静态变量
  __Block_byref_num5_0 *num5; // by ref//__block修饰变量
  __WYTest__blockTest_block_impl_0(void *fp, struct __WYTest__blockTest_block_desc_0 *desc, NSInteger _num, NSInteger *_num2, __Block_byref_num5_0 *_num5, int flags=0) : num(_num), num2(_num2), num5(_num5->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
-  impl.isa = &_NSConcreteStackBlock;这里注意到这一句，即说明该block是栈block）
可以看到局部变量被编译成值形式，而静态变量被编成指针形式，全局变量并未截获。而__block修饰的变量也是以指针形式截获的，并且生成了一个新的结构体对象：

```
struct __Block_byref_num5_0 {
  void *__isa;
__Block_byref_num5_0 *__forwarding;
 int __flags;
 int __size;
 NSInteger num5;
};
```
- 该对象有个属性：num5，即我们用__block修饰的变量。这里__forwarding是指向自身的(栈block)。一般情况下，如果我们要对block截获的局部变量进行赋值操作需添加__block修饰符，而对全局变量，静态变量是不需要添加__block修饰符的。另外，block里访问self或成员变量都会去截获self。

### 19.Block 处理循环引用。
- 分为全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)三种形式其中栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区
- 不使用外部变量的block是全局block
- 比如：

```
NSLog(@"%@",[^{
        NSLog(@"globalBlock");
    } class]);
```
- 输出：

```
__NSGlobalBlock__
```
- 使用外部变量并且未进行copy操作的block是栈block
- 比如

```
NSInteger num = 10;
    NSLog(@"%@",[^{
        NSLog(@"stackBlock:%zd",num);
    } class]);
```
- 输出：

```
__NSStackBlock__
```
- 日常开发常用于这种情况:

```
[self testWithBlock:^{
    NSLog(@"%@",self);
}];

- (void)testWithBlock:(dispatch_block_t)block {
    block();

    NSLog(@"%@",[block class]);
}
```
- 对栈block进行copy操作，就是堆block，而对全局block进行copy，仍是全局block
    * 比如堆1中的全局进行copy操作，即赋值：

```
void (^globalBlock)(void) = ^{
        NSLog(@"globalBlock");
    };

 NSLog(@"%@",[globalBlock class]);
```
- 输出：

```
__NSGlobalBlock__
```
- 仍是全局block
- 而对2中的栈block进行赋值操作：

```
NSInteger num = 10;

void (^mallocBlock)(void) = ^{

        NSLog(@"stackBlock:%zd",num);
    };

NSLog(@"%@",[mallocBlock class]);
```
- 输出：

```
__NSMallocBlock__
```
- 对栈blockcopy之后，并不代表着栈block就消失了，左边的mallock是堆block，右边被copy的仍是栈block
- 比如:

```
[self testWithBlock:^{
    
    NSLog(@"%@",self);
}];

- (void)testWithBlock:(dispatch_block_t)block
{
    block();
    
    dispatch_block_t tempBlock = block;
    
    NSLog(@"%@,%@",[block class],[tempBlock class]);
}
```
- 输出：

```
__NSStackBlock__,__NSMallocBlock__
```
- 即如果对栈Block进行copy，将会copy到堆区，对堆Block进行copy，将会增加引用计数，对全局Block进行copy，因为是已经初始化的，所以什么也不做。
- 另外，__block变量在copy时，由于__forwarding的存在，栈上的__forwarding指针会指向堆上的__forwarding变量，而堆上的__forwarding指针指向其自身，所以，如果对__block的修改，实际上是在修改堆上的__block变量。
- 即__forwarding指针存在的意义就是，无论在任何内存位置，都可以顺利地访问同一个__block变量。
- 另外由于block捕获的__block修饰的变量会去持有变量，那么如果用__block修饰self，且self持有block，并且block内部使用到__block修饰的self时，就会造成多循环引用，即self持有block，block 持有__block变量，而__block变量持有self，造成内存泄漏。
- 比如:

```
__block typeof(self) weakSelf = self;
    
    _testBlock = ^{
        
        NSLog(@"%@",weakSelf);
    };
    
    _testBlock();
```
- 如果要解决这种循环引用，可以主动断开__block变量对self的持有，即在block内部使用完weakself后，将其置为nil，但这种方式有个问题，如果block一直不被调用，那么循环引用将一直存在。所以，我们最好还是用__weak来修饰self

### 20.使用block时什么情况会发生引用循环，如何解决？
- 循环引用就是当self 拥有一个block的时候，在block 又调用self的方法。形成你中有我，我中有你，谁都无法将谁释放的困局。其实就是一个对象中强引用了block，在block中又强引用了该对象，就会发生循环引用。

```
self.myBlock = ^{
    [self doSomething];
  };
       +-----------+           +-----------+
       |    self   |           |   Block   |
  ---> |           | --------> |           |
       | retain 2  | <-------- | retain 1  |
       |           |           |           |
       +-----------+           +-----------+

```
又或者
```
ClassA* objA = [[[ClassA alloc] init] autorelease];
  objA.myBlock = ^{
    [self doSomething];
  };
  self.objA = objA;

  +-----------+           +-----------+           +-----------+
  |   self    |           |   objA    |           |   Block   |
  |           | --------> |           | --------> |           |
  | retain 1  |           | retain 1  |           | retain 1  |
  |           |           |           |           |           |
  +-----------+           +-----------+           +-----------+
       ^                                                |
       |                                                |
       +------------------------------------------------+

```

- 解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用。
    * id weak weakSelf = self; 或者 weak __typeof(&*self)weakSelf = self该方法可以设置宏
    * id __block weakSelf = self;
    * 或者将其中一方强制制空 xxx = nil。

```
__weak typeof (self) weakSelf = self;
［self.button  ^｛
      weakSelf.label.text = @"I am Label";
 }］;

//这个时候就变成这样了。
  +-----------+           +-----------+           +-----------+
  |   self    |           |  button   |           |   Block   |
  |           | --------> |           | --------> |           |
  | retain 1  |           | retain 1  |           | retain 1  |
  |           |           |           |           |           |
  +-----------+           +-----------+           +-----------+
       ^                                                |
       |                                                |
       + - - - - - - - - - - - - - - - - - - - - - - - -+
                               weak

```
- 检测代码中是否存在循环引用问题，可使用 Facebook 开源的一个检测工具[FBRetainCycleDetector](https://github.com/facebook/FBRetainCycleDetector) 。

### 21.在block内如何修改block外部变量？
- 用__block声明外部变量，或者static变量，或者全局变量。
- 默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 __block 来让其写操作生效，示例代码如下:

```
__block int a = 0;
   void (^foo)(void) = ^{ 
       a = 1; 
   };
   foo(); 
   //这里，a的值被修改为1
```
- 为什么写操作就生效了？”真正的原因是这样的：
    * 我们都知道：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。进而在block内部也可以修改外部变量的值。
- Block不允许修改外部变量的值。Apple这样设计，应该是考虑到了block的特殊性，block也属于“函数”的范畴，变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。
- 我们可以打印下内存地址来进行验证：

```
__block int a = 0;
   NSLog(@"定义前：%p", &a);         //栈区
   void (^foo)(void) = ^{
       a = 1;
       NSLog(@"block内部：%p", &a);    //堆区
   };
   NSLog(@"定义后：%p", &a);         //堆区
   foo();
```

```
2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义前：0x16fda86f8
2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] 定义后：0x155b22fc8
2016-05-17 02:03:33.559 LeanCloudChatKit-iOS[1505:713679] block内部： 0x155b22fc8
```
“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。
- 那么如何证明“block内部”打印的是堆地址？
    * 把三个16进制的内存地址转成10进制就是：
        * 定义后前：6171559672
        * block内部：5732708296
        * 定义后后：5732708296
    * 中间相差438851376个字节，也就是 418.5M 的空间，因为堆地址要小于栈地址，又因为iOS中一个进程的栈区内存只有1M，Mac也只有8M，显然a已经是在堆区了。这也证实了：a 在定义前是栈区，但只要进入了 block 区域，就变成了堆区。这才是 __block 关键字的真正作用。
- __block 关键字修饰后，int类型也从4字节变成了32字节，这是 Foundation 框架 malloc 出来的。这也同样能证实上面的结论。（PS：居然比 NSObject alloc 出来的 16 字节要多一倍）。
- 理解到这是因为堆栈地址的变更，而非所谓的“写操作生效”，这一点至关重要，要不然你如何解释下面这个现象：
- 以下代码编译可以通过，并且在block中成功将a的从Tom修改为Jerry。

```
NSMutableString *a = [NSMutableString stringWithString:@"Tom"];
   NSLog(@"\n 定以前：------------------------------------\n\
         a指向的堆中地址：%p；a在栈中的指针地址：%p", a, &a);               //a在栈区
   void (^foo)(void) = ^{
       a.string = @"Jerry";
       NSLog(@"\n block内部：------------------------------------\n\
        a指向的堆中地址：%p；a在栈中的指针地址：%p", a, &a);               //a在栈区
       a = [NSMutableString stringWithString:@"William"];
   };
   foo();
   NSLog(@"\n 定以后：------------------------------------\n\
         a指向的堆中地址：%p；a在栈中的指针地址：%p", a, &a);               //a在栈区
```

![image](https://camo.githubusercontent.com/548c6cfd7a1d7084da25be9d4ee76e51a907fd84/687474703a2f2f6936362e74696e797069632e636f6d2f333465756863792e6a7067)

- 这里的a已经由基本数据类型，变成了对象类型。block会对对象类型的指针进行copy，copy到堆中，但并不会改变该指针所指向的堆中的地址，所以在上面的示例代码中，block体内修改的实际是a指向的堆中的内容。
- 但如果我们尝试像上面图片中的65行那样做，结果会编译不通过，那是因为此时你在修改的就不是堆中的内容，而是栈中的内容。
- 上文已经说过：Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。栈区是红灯区，堆区才是绿灯区。

### 22.使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？
- 系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：
- 所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：

```
[UIView animateWithDuration:duration animations:^{ [self.superview layoutIfNeeded]; }]; 
```

```
[[NSOperationQueue mainQueue] addOperationWithBlock:^{ self.someProperty = xyz; }]; 
```

```
[[NSNotificationCenter defaultCenter] addObserverForName:@"someNotification" 
                                                 object:nil 
                          queue:[NSOperationQueue mainQueue]
                                             usingBlock:^(NSNotification * notification) {
                                                   self.someProperty = xyz; }]; 
```
这些情况不需要考虑“引用循环”。

但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：

```
__weak __typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^
{
__typeof__(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doSomethingElse];
} );
```
类似的

```
__weak __typeof__(self) weakSelf = self;
 _observer = [[NSNotificationCenter defaultCenter] addObserverForName:@"testKey"
                                                               object:nil
                                                                queue:nil
                                                           usingBlock:^(NSNotification *note) {
     __typeof__(self) strongSelf = weakSelf;
     [strongSelf dismissModalViewControllerAnimated:YES];
 }];

```
- self --> _observer --> block --> self 显然这也是一个循环引用。
- 总结：所谓循环引用，是因为当前控制器在引用着block，而block又引用着self即当前控制器，这样就造成了循环引用。系统的block或者AFN等block的调用并不在当前控制器中调用，那么这个self就不代表当前控制器，那自然也就没有循环引用的问题。

### 23.Dispatch_block_t这个有没有用过？解释一下？
### 24.addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？
```
// 添加键值观察
/*
1 观察者，负责处理监听事件的对象
2 观察的属性
3 观察的选项
4 上下文
5 self.person 被观察者
6 self        观察者
7 forKeyPath  观察的属性
8 options     观察的选项
*/
[self.person addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@"Person Name"];
```
observer中需要实现一下方法：

```
// 所有的 kvo 监听到事件，都会调用此方法
/*
 1. 观察的属性
 2. 观察的对象
 3. change 属性变化字典（新／旧）
 4. 上下文，与监听的时候传递的一致
 */
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context;
```

### 25.KVC和KVO的keyPath一定是属性么？
- kvo支持实例变量
- 分析：
    * [手动设定实例变量的KVO实现监听](https://yq.aliyun.com/articles/30483)

### 26.如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？
### 27.apple用什么方式实现对一个对象的KVO？
- 在iOS开发中，苹果提供了许多机制给我们进行回调。KVO(key-value-observing)是一种十分有趣的回调机制，在某个对象注册监听者后，在被监听的对象发生改变时，对象会发送一个通知给监听者，以便监听者执行回调操作。最常见的KVO运用是监听scrollView的contentOffset属性，来完成用户滚动时动态改变某些控件的属性实现效果，包括渐变导航栏、下拉刷新控件等效果。
- Apple 的文档对 KVO 实现的描述：
> Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...
- 从Apple 的文档可以看出：Apple 并不希望过多暴露 KVO 的实现细节。不过，要是借助 runtime 提供的方法去深入挖掘，所有被掩盖的细节都会原形毕露：
> 当你观察一个对象时，一个新的类会被动态创建。这个类继承自该对象的原本的类，并重写了被观察属性的 setter 方法。重写的 setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象：值的更改。最后通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 )（关于更多isa指针，点击[这里](https://note.youdao.com/)） 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。
如下图

![image](https://camo.githubusercontent.com/9517b0d78961b5f32cf3392b99964f2e1f79fb35/687474703a2f2f6936322e74696e797069632e636f6d2f7379353775722e6a7067)

KVO 确实有点黑魔法：
> Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。

- 下面做下详细解释：

键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangevlueForKey: 。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就会记录旧的值。而当改变发生后， observeValueForKey:ofObject:change:context: 会被调用，继而 didChangeValueForKey: 也会被调用。可以手动实现这些调用，但很少有人这么做。一般我们只在希望能控制回调的调用时机时才会这么做。大部分情况下，改变通知会自动调用。

比如调用 setNow: 时，系统还会以某种方式在中间插入 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 的调用。大家可能以为这是因为 setNow: 是合成方法，有时候我们也能看到有人这么写代码:
 
```
- (void)setNow:(NSDate *)aDate {
   [self willChangeValueForKey:@"now"]; // 没有必要
   _now = aDate;
   [self didChangeValueForKey:@"now"];// 没有必要
}
```
这完全没有必要，不要这么做，这样的话，KVO代码会被调用两次。KVO在调用存取方法之前总是调用 willChangeValueForKey: ，之后总是调用 didChangeValueForkey: 。怎么做到的呢?答案是通过 isa 混写（isa-swizzling）。第一次对一个对象调用 addObserver:forKeyPath:options:context: 时，框架会创建这个类的新的 KVO 子类，并将被观察对象转换为新子类的对象。在这个 KVO 特殊子类中， Cocoa 创建观察属性的 setter ，大致工作原理如下:

```
- (void)setNow:(NSDate *)aDate {
   [self willChangeValueForKey:@"now"];
   [super setValue:aDate forKey:@"now"];
   [self didChangeValueForKey:@"now"];
}
```
这种继承和方法注入是在运行时而不是编译时实现的。这就是正确命名如此重要的原因。只有在使用KVC命名约定时，KVO才能做到这一点。

KVO 在实现中通过 isa 混写（isa-swizzling） 把这个对象的 isa 指针 ( isa 指针告诉 Runtime 系统这个对象的类是什么 ) 指向这个新创建的子类，对象就神奇的变成了新创建的子类的实例。这在Apple 的文档可以得到印证：
> Automatic key-value observing is implemented using a technique called isa-swizzling... When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class ...

然而 KVO 在实现中使用了 isa 混写（ isa-swizzling） ，这个的确不是很容易发现：Apple 还重写、覆盖了 -class 方法并返回原来的类。 企图欺骗我们：这个类没有变，就是原本那个类。。。

但是，假设“被监听的对象”的类对象是 MYClass ，有时候我们能看到对 NSKVONotifying_MYClass 的引用而不是对 MYClass 的引用。借此我们得以知道 Apple 使用了 isa 混写（isa-swizzling）。具体探究过程可参考 这篇博文 。

那么 wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context: 这三个方法的执行顺序是怎样的呢？

wilChangeValueForKey: 、 didChangeValueForKey: 很好理解，observeValueForKeyPath:ofObject:change:context: 的执行时机是什么时候呢？

先看一个例子：

```
- (void)viewDidLoad {
   [super viewDidLoad];
   [self addObserver:self forKeyPath:@"now" options:NSKeyValueObservingOptionNew context:nil];
   NSLog(@"1");
   [self willChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
   NSLog(@"2");
   [self didChangeValueForKey:@"now"]; // “手动触发self.now的KVO”，必写。
   NSLog(@"4");
}

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context {
   NSLog(@"3");
}
```

![image](https://camo.githubusercontent.com/154f30ca6e4fbb77af74b8186057b7f7c96221ff/687474703a2f2f6936362e74696e797069632e636f6d2f6e636d3774682e6a7067)
   
如果单单从下面这个例子的打印上，顺序似乎是 wilChangeValueForKey: 、 observeValueForKeyPath:ofObject:change:context: 、 didChangeValueForKey: 。
其实不然，这里有一个 observeValueForKeyPath:ofObject:change:context: , 和 didChangeValueForKey: 到底谁先调用的问题：如果 observeValueForKeyPath:ofObject:change:context: 是在 didChangeValueForKey: 内部触发的操作呢？ 那么顺序就是： wilChangeValueForKey: 、 didChangeValueForKey: 和 observeValueForKeyPath:ofObject:change:context:

不信你把 didChangeValueForKey: 注视掉，看下 observeValueForKeyPath:ofObject:change:context: 会不会执行。

了解到这一点很重要，正如“手动触发”的使用场景是什么？一般我们只在希望能控制“回调的调用时机”时才会这么做。而“回调的调用时机”就是在你调用 didChangeValueForKey: 方法时。

### 28.KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）
- KVC（Key-value coding）键值编码，单看这个名字可能不太好理解。其实翻译一下就很简单了，就是指iOS的开发中，可以允许开发者通过Key名直接访问对象的属性，或者给对象的属性赋值。而不需要调用明确的存取方法。这样就可以在运行时动态地访问和修改对象的属性。而不是在编译时确定，这也是iOS开发中的黑魔法之一。很多高级的iOS开发技巧都是基于KVC实现的。
- 实现原理
    * KVC运用了一个isa-swizzling技术。isa-swizzling就是类型混合指针机制。KVC主要通过isa-swizzling，来实现其内部查找定位的。isa指针，如其名称所指，（就是is a kind of的意思），指向维护分发表的对象的类。该分发表实际上包含了指向实现类中的方法的指针，和其它数据。
- KVC拿到key以后，是如何赋值的

### 29.KVC的keyPath中的集合运算符如何使用？
- 必须用在集合对象上或普通对象的集合属性上
- 简单集合运算符有@avg， @count ， @max ， @min ，@sum，
- 格式 @"@sum.age"或 @"集合属性.@max.age"
- 例子：
首先造一些测试数据、后面使用

```
- (NSArray *) loadData
{
    //假数据
    Student *stu0 = [[Student alloc]init];
    stu0.stuId = 0;
    stu0.name = @"tom";
    stu0.score = 88;
    
    Student *stu1 = [[Student alloc]init];
    stu1.stuId = 1;
    stu1.name = @"sam";
    stu1.score = 90;
    
    Student *stu2 = [[Student alloc]init];
    stu2.stuId = 2;
    stu2.name = @"xiaoming";
    stu2.score = 65;
    
    Student *stu3 = [[Student alloc]init];
    stu3.stuId = 3;
    stu3.name = @"shangsan";
    stu3.score = 89;
    
    //此学生和stu3同名
    Student *stu4 = [[Student alloc]init];
    stu4.stuId = 4;
    stu4.name = @"shangsan";
    stu4.score = 91;
    
    return @[stu0,stu1,stu2,stu3,stu4];
}```

#####简单集合操作符
>   `@count`: 返回一个值为集合中对象总数的NSNumber对象。
      `@sum`:   首先把集合中的每个对象都转换为double类型，然后计算其总，最后返回一个值为这个总和的NSNumber对象。
      `@avg`:   首先把集合中的每个对象都转换为double类型，然后计算其均分，最后返回一个值为这个总和的NSNumber对象。
      `@max`:   使用compare:方法来确定最大值。所以为了让其正常工作，集合中所有的对象都必须支持和另一个对象的比较。
      `@min`:   和@max一样，但是返回的是集合中的最小值。

```
//获取学生数据
NSArray *arr = [self loadData];

```
/**
 简单集合操作符
  @count: 返回一个值为集合中对象总数的NSNumber对象。
  @sum:   首先把集合中的每个对象都转换为double类型，然后计算其总，最后返回一个值为这个总和的NSNumber对象。
  @avg:   首先把集合中的每个对象都转换为double类型，然后计算其均分，最后返回一个值为这个总和的NSNumber对象。
  @max:   使用compare:方法来确定最大值。所以为了让其正常工作，集合中所有的对象都必须支持和另一个对象的比较。
  @min:   和@max一样，但是返回的是集合中的最小值。
 */

//注：--->   @
//KVC集合运算符允许在valueForKeyPath:方法中使用key path符号在一个集合中执行方法。无论什么时候你在key path中看见了@，它都代表了一个特定的集合方法，其结果可以被返回或者链接，就像其他的key path一样。

NSLog(@"学生集合平均分 = %@",[arr valueForKeyPath:@"@avg.score"]);
NSLog(@"学生集合总数  = %@",[arr valueForKeyPath:@"@count"]);
NSLog(@"学生集合最该分 = %@",[arr valueForKeyPath:@"@max.score"]);
NSLog(@"学生集合最低分 = %@",[arr valueForKeyPath:@"@min.score"]);
NSLog(@"学生集合成绩总和 = %@",[arr valueForKeyPath:@"@sum.score"]);

```

```
打印结果：
![简单集合操作符](http://upload-images.jianshu.io/upload_images/1599305-2543477be98d8c10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



#####对象操作符
> `@unionOfObjects`/ `@distinctUnionOfObjects`: 返回一个由操作符右边的key path所指定的对象属性组成的数组。
       其中:
        `@distinctUnionOfObjects` 会对数组去重, 
        `@unionOfObjects` 不会对数组去重

```

```
/**
   对象操作符
 
   @unionOfObjects / @distinctUnionOfObjects: 返回一个由操作符右边的key path所指定的对象属性组成的数组。
   其中:
    @distinctUnionOfObjects 会对数组去重, 
    @unionOfObjects 不会对数组去重
 */
NSLog(@"%@",[arr valueForKeyPath:@"@unionOfObjects.name"]);
NSLog(@"%@",[arr valueForKeyPath:@"@distinctUnionOfObjects.name"]);

```

```
打印结果：
![对象操作符](http://upload-images.jianshu.io/upload_images/1599305-5063d87616d26289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

#####数组和集合操作符
>    `@distinctUnionOfArrays` / `@unionOfArrays`: 返回了一个数组，其中包含这个集合中每个数组对于这个操作符右面指定的key path进行操作之后的值。正如你期望的，distinct版本会移除重复的值。
     `@distinctUnionOfSets`: 和`@distinctUnionOfArrays`差不多, 但是它期望的是一个包含着NSSet对象的NSSet，并且会返回一个NSSet对象。因为集合不能包含重复的值，所以它只有distinct操作。

```

```
/**
  数组和集合操作符
 
 @distinctUnionOfArrays / @unionOfArrays: 返回了一个数组，其中包含这个集合中每个数组对于这个操作符右面指定的key path进行操作之后的值。正如你期望的，distinct版本会移除重复的值。
 
 @distinctUnionOfSets: 和@distinctUnionOfArrays差不多, 但是它期望的是一个包含着NSSet对象的NSSet，并且会返回一个NSSet对象。因为集合不能包含重复的值，所以它只有distinct操作。
 */

NSArray *arr2 = [self loadData];
NSLog(@"%@",[@[arr,arr2] valueForKeyPath:@"@unionOfArrays.name"]);

```


打印结果：

![数组和集合操作符]

![image](http://upload-images.jianshu.io/upload_images/1599305-6a75ebddd2c1b221.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 项目架构
### 1.什么是 MVC?
![image](https://upload-images.jianshu.io/upload_images/1653926-9abf7d3219aa5b1c.png?imageMogr2/auto-orient/strip|imageView2/2/w/974)

- 视图（View）：用户界面。
- 控制器（Controller）：业务逻辑
- 模型（Model）：数据保存
- 各部分之间的通信方式如下
    * View 传送指令到 Controller
    * Controller 完成业务逻辑后，要求 Model 改变状态
    * Model 将新的数据发送到 View，用户得到反馈
- MVC的弊端
    * 厚重的View Controller
        * M：模型model的对象通常非常的简单。根据Apple的文档，model应包括数据和操作数据的业务逻辑。而在实践中，model层往往非常薄，不管怎样，model层的业务逻辑不应被拖入到controller。
        * V：视图view通常是UIKit控件（component，这里根据习惯译为控件）或者编码定义的UIKit控件的集合。View的如何构建（PS：IB或者手写界面）何必让Controller知晓，同时View不应该直接引用model（PS：现实中，你懂的！），并且仅仅通过IBAction事件引用controller。业务逻辑很明显不归入view，视图本身没有任何业务。
        * C：控制器controller。Controller是app的“胶水代码”：协调模型和视图之间的所有交互。控制器负责管理他们所拥有的视图的视图层次结构，还要响应视图的loading、appearing、disappearing等等，同时往往也会充满我们不愿暴露的model的模型逻辑以及不愿暴露给视图的业务逻辑。网络数据的请求及后续处理，本地数据库操作，以及一些带有工具性质辅助方法都加大了Massive View Controller的产生。
    * 遗失（无处安放）的网络逻辑
        * 苹果使用的MVC的定义是这么说的：所有的对象都可以被归类为一个model，一个view，或是一个controller。
        * 你可能试着把它放在Model对象里，但是也会很棘手，因为网络调用应该使用异步，这样如果一个网络请求比持有它的model生命周期更长，事情将变的复杂。显然View里面做网络请求那就更格格不入了，因此只剩下Controller了。若这样，这又加剧了Massive View Controller的问题。若不这样，何处才是网络逻辑的家呢？
    * 较差的可测试性
        * 由于View Controller混合了视图处理逻辑和业务逻辑，分离这些成分的单元测试成了一个艰巨的任务。

### 2.什么是 MVVM?
- 一种可以很好地解决Massive View Controller问题的办法就是将 Controller 中的展示逻辑抽取出来，放置到一个专门的地方，而这个地方就是 viewModel 。MVVM衍生于MVC，是对 MVC 的一种演进，它促进了 UI 代码与业务逻辑的分离。它正式规范了视图和控制器紧耦合的性质，并引入新的组件。他们之间的结构关系如下：

![image](https://upload-images.jianshu.io/upload_images/1653926-7ed45d1af126df79.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- MVVM 的基本概念
    * 在MVVM 中，view 和 view controller正式联系在一起，我们把它们视为一个组件
    * view 和 view controller 都不能直接引用model，而是引用视图模型（viewModel）
    * viewModel 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码的地方
    * 使用MVVM会轻微的增加代码量，但总体上减少了代码的复杂性
- MVVM 的注意事项
    * view 引用viewModel ，但反过来不行（即不要在viewModel中引入#import UIKit.h，任何视图本身的引用都不应该放在viewModel中）
    * viewModel 引用model，但反过来不行
- MVVM 的使用建议
    * MVVM 可以兼容你当下使用的MVC架构。
    * MVVM 增加你的应用的可测试性。
    * MVVM 配合一个绑定机制效果最好
    * viewController 尽量不涉及业务逻辑，让 viewModel 去做这些事情。
    * viewController 只是一个中间人，接收 view 的事件、调用 viewModel 的方法、响应 viewModel 的变化。
    * viewModel 绝对不能包含视图 view（UIKit.h），不然就跟 view 产生了耦合，不方便复用和测试。
    * viewModel之间可以有依赖。
    * viewModel避免过于臃肿，否则重蹈Controller的覆辙，变得难以维护。
- MVVM 的优势
    * 低耦合：View 可以独立于Model变化和修改，一个 viewModel 可以绑定到不同的 View 上
    * 可重用性：可以把一些视图逻辑放在一个 viewModel里面，让很多 view 重用这段视图逻辑
    * 独立开发：开发人员可以专注于业务逻辑和数据的开发 viewModel，设计人员可以专注于页面设计
    * 可测试：通常界面是比较难于测试的，而 MVVM 模式可以针对 viewModel来进行测试
- MVVM 的弊端
    * 数据绑定使得Bug 很难被调试。你看到界面异常了，有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了。
    * 对于过大的项目，数据绑定和数据转化需要花费更多的内存（成本）。主要成本在于：
        * 数组内容的转化成本较高：数组里面每项都要转化成Item对象，如果Item对象中还有类似数组，就很头疼。
        * 转化之后的数据在大部分情况是不能直接被展示的，为了能够被展示，还需要第二次转化。
        * 只有在API返回的数据高度标准化时，这些对象原型（Item）的可复用程度才高，否则容易出现类型爆炸，提高维护成本。
    * 调试时通过对象原型查看数据内容不如直接通过NSDictionary/NSArray直观。
    * 同一API的数据被不同View展示时，难以控制数据转化的代码，它们有可能会散落在任何需要的地方。
- MVVM 模式将 Presenter改名为ViewModel，基本上与 MVP 模式完全一致。
- 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。
- MVVM的优势就是，任务均摊每部分都承担各自的责任，结构清晰更加符合软件设计原则
- 其次就是可测试性强，我们只需要测试ViewModel就能够轻易的测试UI上的问题

### 3.什么是 MVP?
- MVP 模式将 Controller改名为Presenter，同时改变了通信方向。
- 各部分之间的通信，都是双向的。
- View 与 Model 不发生联系，都通过 Presenter 传递。
- View 非常薄，不部署任何业务逻辑，称为"被动视图"（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。

### 4.什么是 CDD?
### 5.项目的组件化？
#### 1.说一下你了解的项目组件化方案？
#### 2.什么样的团队及项目适合采用组件化的形式进行开发？
#### 3.组件之间的通信方式。
#### 4.各组件之间的解耦。
### 6.还了解哪些项目架构？你之前所在公司的架构师什么样的，简单说一下？
### 7.从宏观上来讲 App 可以分为哪些层？
### 8.多工程连编之静态库


## iOS设计模式
### 1.编程中的六大设计原则？
- 单一职责原则
    * 通俗地讲就是一个类只做一件事
        * CALayer：动画和视图的显示。
        * UIView：只负责事件传递、事件响应。
- 开闭原则
    * 对修改关闭，对扩展开放。
    * 要考虑到后续的扩展性，而不是在原有的基础上来回修改
- 接口隔离原则
    * 使用多个专门的协议、而不是一个庞大臃肿的协议
        * UITableviewDelegate
        * UITableViewDataSource
- 依赖倒置原则
    * 抽象不应该依赖于具体实现、具体实现可以依赖于抽象。
    * 调用接口感觉不到内部是如何操作的
- 里氏替换原则
    * 父类可以被子类无缝替换，且原有的功能不受任何影响，例如 KVO
- 迪米特法则
    * 一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合

### 2.如何设计一个图片缓存框架？
- 可以模仿 SDWebImage 来实现。
- 构成
    * Manager
    * 内存缓存
    * 磁盘缓存
    * 网络下载
    * Code Manager
        * 图片解码
        * 图片解压缩
        * 图片的存储是以图片的单向 hash 值为 Key
- 内存设计需要考虑的问题
    * 存储的 Size
        * 因为内存的空间有限，我们针对不同尺寸的图片，给出不同的方案
        * 10K 以下的50个
        * 100Kb 以下的20个
        * 100kb 以上的10个
    * 淘汰的策略
        * 内存的淘汰策略采取LRU（最近最少使用算法）
        * 触发淘汰策略的时机有三种
            * 定期检查（不建议，耗性能）
            * 提高检查触发频率（一定要注意开销）
                * 前后台切换的时候
                * 每次读写的时候
- 磁盘设计需要考虑的问题
    * 存储方式
    * 大小限制（有固定的大小）
    * 移除策略（可以设置为7天或者15天）
- 网络设计需要考虑的问题
    * 图片请求的最大并发量
    * 请求超时策略
    * 请求优先级
- 图片解码
    * 应用 策略模式，针对 jpg、png、gif 等不同的图片格式进行解码
    * 图片解码的时机
        * 在 子线程 图片刚下载完时
        * 在 子线程 刚从磁盘读取完时
        * 避免在主线程解压缩、解码，避免卡顿

### 3.如何设计一个时长统计框架？
- 记录器
    * 页面式记录器
    * 流式记录器
    * 自定义式
- 记录管理者
    * 内存记录缓存
    * 磁盘存储
    * 上传器
- 如何降低数据的丢失率？
    * 定期写入磁盘
    * 每当达到某个值的时候，就写入磁盘
- 记录上传的时机
    * 前后台切换的时候可以上传
    * 从无网到有网切换的时候可以上传
- 上传时机的选择
    * 立即上传
    * 定时上传
    * 延时上传

### 4.如何实现 App 换肤（夜间模式）？
### 5.外观模式
### 6.中介者模式
### 7.访问者模式
### 8.装饰模式
### 9.观察者模式
### 10.责任链模式
### 11.命令模式
### 12.适配器模式
### 13.桥接模式
### 14.代理委托模式
### 15.单例模式
### 补充：单例弊端？
- 优点：
    * 一个类只被实例化一次，提供了对唯一实例的受控访问。
    * 节省系统资源
    * 允许可变数目的实例。
- 缺点：
    * 一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。
    * 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
    * 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

### 16.类工厂模式

## 数据存储
### 1.如何判断一个文件在沙盒中是否存在？
- 通常我们在模拟器中运行项目时，如果需要查看沙盒中的文件，只需要按住command+shift+g，然后将文件路径复制进去点击前往，就能查看到沙盒中的文件
- 在真机测试时查看沙盒
    * 点击xcode菜单中的window选项，然后选择Devices and Simulators选项
    * 然后窗口中的TeachersSide就是在真机测试运行的项目。
    * 然后Download文件
    * 然后显示包内容

### 2.数据持久化的几个方案（fmdb用没用过）
- NSUserDefaults
- plist（属性列表）
- NSKeyedArchiver（对象归档）
- iOS的嵌入式关系数据库SQLite3
- 苹果公司提供的持久化工具 Core Data

首先介绍沙盘
- 沙盒目录结构:
    * Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时 会 备份该目录。例如，游戏应用可将游戏存档保存在该目录
    * tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时 不会 备份该目录
    * Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时 不会 备份该目录。一般存储体积大、不需要备份的非重要数据
    * Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用 会 在该目录中查找应用的设置信息。iTunes同步设备时 会 备份该目录

NSUserDefaults

```
static NSString* const key = @"key";
[[NSUserDefaults standardUserDefaults] setValue:@"YES" forKey:key];
[NSUserDefaults standardUserDefaults] valueForKey:key]
[userDefaults removeObjectForKey:key];
[userDefaults synchronize];
```
上面的示例代码基本就是NSUserDefaults所有用法了，虽然很简单，但还是有几点需要注意：
    * 建议将所有的的key单独存放（好处自己领会）
    * NSUserDefaults可以存储的数据类型包括：NSData、NSString、NSNumber、NSDate、NSArray、NSDictionary。如果要存储其他类型，则需要转换为前面的类型，才能用NSUserDefaults存储。之前碰到个坑就是从服务器拿到数据部分用这种方式存储，服务器返回NSNull,我们这边也没有model层转，就直接存储了，导致app卡掉但并没有闪退之类，就是线程卡死的情况
    * 同步问题，在适当的时候同步。因为synchronize的开销可能会很大，因为要比较内存中和存储中的所有用户偏好默认值，如果有好几百个key value 同步是非常消耗性能的。
    * 偏好设置是专门用来保存应用程序的配置信息的，（ 用过Settings.bundle的应该都很熟悉），所以一般不要在偏好设置中保存其他数据。
    * 偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。

plist
首先需要知道什么是序列化对象（serialized object）：指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象

```
/**
 *  获取存储路径
 */
- (NSString*)dataFilePath {
    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
    NSString *documentDirectory = paths[0];
    return [documentDirectory stringByAppendingPathComponent:@"data.plist"];//nsstring真强大
}
```
我们在app处于非活跃状态时存储一些东东

```
UIApplication* app = [UIApplication sharedApplication];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillResignActive:) name:UIApplicationWillResignActiveNotification object:app];

- (void)appWillResignActive:(NSNotification*)notification {
    NSString* filePath = [self dataFilePath];
    NSArray* arr = @[@1,@2,@3,@4];
    [arr writeToFile:filePath atomically:YES];
}
```
在我们需要这些东东的时候从文件中读取

```
NSString* filePath = [self dataFilePath];
if ([[NSFileManager defaultManager]fileExistsAtPath:filePath]) {
    NSArray* arr = [[NSArray alloc]initWithContentsOfFile:filePath];
}
```

NSKeyedArchiver

在Cocoa中，Archiver是另一种形式的序列化，是任何对象都可实现的更常规的类型

说明：

只有遵守了NSCoding或 NSSecureCoding（更为安全的归档协议）协议,并且实现了协议里归档与解归档的方法的的类创建的对象才能够进行归档
最好也实现以下NSCopying，NSCopying与NSCoding一起实现好处在于允许复制对象，使用数据模型对象时有较大的灵活性


```
#import <Foundation/Foundation.h>
@interface FourLines : NSObject<NSCoding,NSCopying>

@property(copy,nonatomic)NSArray* lines;

@end

#import "FourLines.h"

//编解码的key
static NSString* const klinesKey = @"klinesKey";

@implementation FourLines

#pragma mark -  NSCoding

- (void)encodeWithCoder:(NSCoder *)aCoder {
    [aCoder encodeObject:self.lines forKey:klinesKey];
}

- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
    self = [super init];
    if (self) {
        self.lines = [aDecoder decodeObjectForKey:klinesKey];
    }
    return self;
}

#pragma mark -  NSCopying 

- (id)copyWithZone:(nullable NSZone *)zone {
    FourLines* copy = [[[self class]allocWithZone:zone]init];
    NSMutableArray* linesCopy = [NSMutableArray array];
    for (id line in self.lines) {
        [linesCopy addObject:[line copyWithZone:zone]];
    }
    copy.lines = linesCopy;
    return copy;
}

@end
```
写入数据，编码：文件路径还是用上面代码中定义的文件路径

```
- (void)appWillResignActive:(NSNotification*)notification {
    NSString* filePath = [self dataFilePath];
    FourLines* lines = [[FourLines alloc]init];
    lines.lines = @[@"a",@"b",@"c",@"d"];
    NSMutableData* data = [[NSMutableData alloc]init];
    NSKeyedArchiver* archiver = [[NSKeyedArchiver alloc]initForWritingWithMutableData:data];
    [archiver encodeObject:lines forKey:kRootKey];
    [archiver finishEncoding];
    [data writeToFile:filePath atomically:YES];  
}
```
读取数据，解码：

```
NSString* filePath = [self dataFilePath];
 if ([[NSFileManager defaultManager]fileExistsAtPath:filePath]) {
        NSData* data = [[NSMutableData alloc]initWithContentsOfFile:filePath];
        NSKeyedUnarchiver* unarchiver = [[NSKeyedUnarchiver alloc]initForReadingWithData:data];
        FourLines* four = [unarchiver decodeObjectForKey:kRootKey];
        [unarchiver finishDecoding];
        for (int i = 0; i < 4; i++) {
            //to do
        }
}

UIApplication* app = [UIApplication sharedApplication];
[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appWillResignActive:) name:UIApplicationWillResignActiveNotification object:app];
```
fmdb（iOS平台的SQLite数据库框架）

建表以及关闭表

使用数据库的第一件事，就是建立一个数据库。要注意的是，在iOS环境下，只有document directory 是可以进行读写的。在写程序时用的那个Resource资料夹底下的东西都是read-only。因此，建立的资料库要放在document 资料夹下。方法如下：


```
//建表
    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];
    NSLog(@"doc = %@", doc);
    NSString *fileName = [doc stringByAppendingPathComponent:@"device.sqlite"];
    FMDatabase *db = [FMDatabase databaseWithPath:fileName];
    if ([db open]) {
        BOOL result = [db executeUpdate:@"CREATE TABLE IF NOT EXISTS Device (deviceID text, deviceName text, deviceType integer, deviceStatus integer);"];
        if (result) {
            NSLog(@"创建表成功");
        } else {
            NSLog(@"建表失败");
        }
    }

```

这样简单的操作就已经完成了数据库的创建，每一行代码都很好理解，先是找到程序在沙盒中的路径，之后填写数据库的名字，完成创建。如果创建数据库成功，那么我们就创建一个名字叫Device的表，这个设备表里有 deviceID, deviceName, deviceType, deviceStatus 四个字段，他们的类型分别是text、text、integer、integer。

### 3.简要介绍沙盘
- 沙盒目录结构:
    * Documents：保存应用运行时生成的需要持久化的数据，iTunes同步设备时 会 备份该目录。例如，游戏应用可将游戏存档保存在该目录
    * tmp：保存应用运行时所需的临时数据，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时 不会 备份该目录
    * Library/Caches：保存应用运行时生成的需要持久化的数据，iTunes同步设备时 不会 备份该目录。一般存储体积大、不需要备份的非重要数据
    * Library/Preference：保存应用的所有偏好设置，iOS的Settings(设置)应用 会 在该目录中查找应用的设置信息。iTunes同步设备时 会 备份该目录

### 4.Sqlite3
#### 1.简单说一下 Sqlite3
#### 2.Sqlite3 常用的执行语句
### 3.Sqlite3在不同版本的APP，数据库结构变化了，如何处理?
### 5.FMDB (Sqlite3 的封装)
### 6.Realm
### 7.NSKeyArchieve
### 8.Preperfence
### 9.Plist
### 10.CoreDate
### 11.Keychain
### 12.UIPasteBoard
### 13.FoundationDB
### 14.LRU(最少最近使用)缓存


## WebView
### 1.说一下 JS 和 OC 互相调用的几种方式？
#### UIWebView 拦截 URL
##### JS 调用原生 OC
- 我们可以利用 JS 发起一个假的 URL 请求，然后利用UIWebView的代理方法拦截这次请求，然后再做相应的处理。

```
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
    NSURL * url = [request URL];
    if ([[url scheme] isEqualToString:@"firstclick"]) {  // firstClick://shareClick?title=分享的标题&content=分享的内容&url=链接地址&imagePath=图片地址
        NSArray *params = [url.query componentsSeparatedByString:@"&"];
        
        NSMutableDictionary *tempDict = [NSMutableDictionary dictionary];
        NSMutableString *strM = [NSMutableString string];
        for (NSString *paramStr in params) {
            NSArray *dictArray = [paramStr componentsSeparatedByString:@"="];
            if (dictArray.count > 1) {
                NSString *decodeValue = [dictArray[1] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
                decodeValue = [decodeValue stringByRemovingPercentEncoding];
                [tempDict setObject:decodeValue forKey:dictArray[0]];
                [strM appendString:decodeValue];
            }
        }
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"这是OC原生的弹出窗" message:strM delegate:self cancelButtonTitle:@"收到" otherButtonTitles:nil];
        [alertView show];
        NSLog(@"tempDic:%@",tempDict);
        return NO;
    }
    return YES;
}
```
- 相关问题：
    * 为什么定义一个loadURL方法，不直接使用window.location.href?
        * 因为如果当前网页正在使用window.location.href加载网页的同时，调用window.location.href去调用 OC 原生方法，会导致加载网页的操作被取消掉。同样的，如果连续使用window.location.href执行两次 OC 原生调用，也有可能导致第一次的操作被取消掉。所以我们使用自定义的loadURL，来避免这个问题。
    * 为什么 loadURL 中的链接，使用统一的 scheme？
        * 便于在 OC 中做拦截处理，减少在 JS 中调用一些 OC 没有实现的方法时，webView 做跳转。我再 OC 拦截 URL 时，根据 scheme即(firstclick）来区分是调用原生的方法还是正常的网页跳转。然后根据host（即//后面的部分shareClick）来区分执行什么操作。
    * 为什么自定义一个asyncAlert方法？
        * 因为有的 JS 调用是需要 OC 返回结果到 JS 的。stringByEvaluatingJavaScriptFromString是一个同步方法，会等待js方法执行完成。而弹出的alert也会阻塞界面等待用户响应，所以他们可能会造成死锁。导致 alert 卡死界面。如果回调的JS是一个耗时操作，那么建议将耗时的操作也放入setTimeout的function中。
> 1.JS中的firstClick,在拦截到的url scheme全都被转化为小写。
2.html 中需要设置编码，否则中文参数可能会出现编码问题。
3.JS用打开一个iFrame的方式替代直接用document.location的方式，以避免多次请求，被替换覆盖的问题。

##### OC 调用 JS

```
NSString *jsStr = [NSString stringWithFormat:@"showAlert('%@')",@"这里是JS中alert弹出的message"];
[self.webView stringByEvaluatingJavaScriptFromString:jsStr];
```

- ==注意：该方法会同步返回一个字符串，因此是一个同步方法，可能会阻塞主线程。==
- 在 html 文件中

```
function showAlert(message) {
  alert(message);
}
```

#### WKWebView拦截 URL
##### JS调用 OC
- 使用WKNavigationDelegate中的代理方法，拦截自定义的 URL 来实现 JS 调用 OC 方法。

```
#pragma mark - WKNavigationDelegate

- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    NSURL *URL = navigationAction.request.URL;
    NSString *scheme = [URL scheme];
    if ([scheme isEqualToString:@"haleyaction"]) {
        [self handleCustomAction:URL];
        decisionHandler(WKNavigationActionPolicyCancel);
        return;
    }
    decisionHandler(WKNavigationActionPolicyAllow);
}
```
- ==注意点：如果实现了这个代理方法，就必须得调用decisionHandler这个 block，否则会导致 app 奔溃。block 参数是一个枚举值，WKNavigationActionPolicyCancel代表取消加载，相当于UIWebView的代理方法return NO的情况；WKNavigationActionPolicyAllow代表允许加载，相当于UIWebView的代理方法中 return YES的情况。==
- 关于如何区分执行不同的OC方法，也与UIWebView的处理方式一样,通过URL的host来区分执行不同的方法：

```
#pragma mark - dealwith custom action

- (void)handleCustomAction:(NSURL *)URL {
    NSString *host = [URL host];
    
    if ([host isEqualToString:@"shareClick"]) {
        [self share:URL];
    } else if ([host isEqualToString:@"getLocation"]) {
        [self getLocation:URL];
    } else if ([host isEqualToString:@"setBGColor"]) {
        [self setBGColor:URL];
    } else if ([host isEqualToString:@"payAction"]) {
        [self payAction:URL];
    } else if ([host isEqualToString:@"shake"]) {
        [self shakeAction];
    } else if ([host isEqualToString:@"back"]) {
        [self goBack];
    }
}
```
##### OC 调用 JS 方法
- JS 调用OC 方法后，有的操作可能需要将结果返回给JS。这时候就是OC 调用JS 方法的场景。
- WKWebView 提供了一个新的方法evaluateJavaScript:completionHandler:，实现OC 调用JS 等场景。

```
- (void)getLocation:(NSURL *)URL {
    // 获取位置信息
    NSLog(@"原生获取位置信息操作");
    
    // 将结果返回给 JS
    NSString *jsStr = [NSString stringWithFormat:@"setLocation('%@')",@"广东省广州市白云区豪泉大厦"];
    [self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) {
        NSLog(@"%@----%@",result, error);
    }];
}
```
- ==注意点：evaluateJavaScript:completionHandler:没有返回值，JS执行成功还是失败会在completionHandler 中返回。所以使用这个API就可以避免执行耗时的JS，或者alert 导致界面卡住的问题。==

#### JavaScriptCore （UIWebView）
##### JS 调用原生 OC
- 在iOS 7之后，apple添加了一个新的库JavaScriptCore，用来做JS交互，因此JS与原生OC交互也变得简单了许多。
- 首先导入JavaScriptCore库,然后在OC中获取JS的上下文。

```
JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
```
- 再然后定义好JS需要调用的方法，例如JS要调用share方法：则可以在UIWebView加载url完成后，在其代理方法中添加要调用的share方法：

```
- (void)setupData {
    JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
    //定义好JS要调用的方法, share就是调用的share方法名
    context[@"share"] = ^() {
        NSLog(@"+++++++Begin Log+++++++");
        NSArray *args = [JSContext currentArguments];
        NSMutableString *strM = [NSMutableString string];
        for (JSValue *jsVal in args) {
            NSLog(@"%@", jsVal.toString);
            [strM appendString:jsVal.toString];
        }
        
        dispatch_async(dispatch_get_main_queue(), ^{
            UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"这是OC原生的弹出窗" message:strM delegate:self cancelButtonTitle:@"收到" otherButtonTitles:nil];
            [alertView show];
        });
        
        
        NSLog(@"-------End Log-------");
    };
}
```
##### OC 调用 JS
- OC 调用 JS 方法有多种，首先介绍使用JavaScriptCore框架的方式。
- 方式一：使用JSContext 的方法-evaluateScript，可以实现 OC 调用 JS 方法

```
// 法一
- (void)transferJS {
    JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
    NSString *textJS = @"showAlert('这里是JS中alert弹出的message')";
    [context evaluateScript:textJS];
}

// 法二
- (void)transferJS {
    NSString *textJS = @"showAlert('这里是JS中alert弹出的message')";
    [[JSContext currentContext] evaluateScript:textJS];
}
```
- 方式二：使用 JSValue 的方法-callWithArguments，也可以实现 OC 调用 JS 方法

```
JSContext *context = [self.webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
[context[@"showAlert"] callWithArguments:@[@"这里是JS中alert弹出的message"]];
```

#### MessageHandler(WKWebView)
- 使用WKWebView的时候，如果想要实现JS调用OC方法，除了拦截URL之外，还有一种简单的方式。那就是利用WKWebView的新特性MessageHandler来实现JS调用原生方法。
##### 怎么使用MessageHandler？
- 创建WKWebViewConfiguration对象，配置各个API对应的MessageHandler。
- WKUserContentController对象可以添加多个scriptMessageHandler。
- 然后在界面即将显示的时候添加MessageHandler

```
- (void)viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    
    // addScriptMessageHandler 很容易导致循环引用
    // 控制器 强引用了WKWebView,WKWebView copy(强引用了）configuration， configuration copy （强引用了）userContentController
    // userContentController 强引用了 self （控制器）
    [self.webView.configuration.userContentController addScriptMessageHandler:self name:@"ScanAction"];
    [self.webView.configuration.userContentController addScriptMessageHandler:self name:@"Location"];
    [self.webView.configuration.userContentController addScriptMessageHandler:self name:@"Share"];
}
```
- 需要注意的是addScriptMessageHandler很容易引起循环引用，导致控制器无法被释放，所以需要移除MessageHandler

```
- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    
    // 因此这里要记得移除handlers
    [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"ScanAction"];
    [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"Location"];
    [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@"Share"];
}
```
##### 实现协议方法 - JS调用 OC
- 这里实现了两个协议<WKUIDelegate,WKScriptMessageHandler>，WKUIDelegate是因为我在JS中弹出了alert 。WKScriptMessageHandler是因为我们要处理JS调用OC方法的请求。

```
#pragma mark - WKScriptMessageHandler

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    // message.body  --  Allowed types are NSNumber, NSString, NSDate, NSArray,NSDictionary, and NSNull.
    if ([message.name isEqualToString:@"ScanAction"]) {
        [self scanAction];
    } else if ([message.name isEqualToString:@"Location"]) {
        [self getLocation];
    } else if ([message.name isEqualToString:@"Share"]) {
        [self shareWithParams:message.body];
    }
}
```
- WKScriptMessage有两个关键属性name 和 body。
- 因为我们给每一个OC方法取了一个name，那么我们就可以根据name 来区分执行不同的方法。body 中存着JS 要给OC 传的参数。
- 关于参数body的解析，我就举一个body中放字典的例子，其他的稍后可以看demo。
解析JS 调用OC 实现分享的参数：

```
- (void)shareWithParams:(NSDictionary *)params {
    if (![params isKindOfClass:[NSDictionary class]]) {
        return;
    }
    NSString *title = [params objectForKey:@"title"];
    NSString *content = [params objectForKey:@"content"];
    NSString *url = [params objectForKey:@"url"];
    
    // 在这里执行分享的操作
    NSLog(@"在这里执行分享的操作");
    
    // 将分享结果返回给js
    NSString *jsStr = [NSString stringWithFormat:@"shareResult('%@','%@','%@')",title,content,url];
    [self.webView evaluateJavaScript:jsStr completionHandler:^(id result, NSError *error) {
        NSLog(@"%@----%@",result, error);
    }];
}
```
- message.boby就是JS里传过来的参数。我们不同的方法先做一下容错性判断。然后正常取值就可以了。

##### 处理HTML中JS调用

```
// 传字典              
function shareClick(){
  window.webkit.messageHandlers.Share.postMessage({title:'测试分享的标题',content:'测试分享的内容',url:'http://www.baidu.com'});
}

function shareResult(channel_id,share_channel,share_url) {
    var content = channel_id+","+share_channel+","+share_url;
    asyncAlert(content);
    document.getElementById("returnValue").value = content;
}
            
function asyncAlert(content) {
    setTimeout(function(){
        alert(content);
    },1);
}
```
##### OC调用JS
- 这里使用WKWebView实现OC调用JS方法与之前说的文章一样，通过- evaluateJavaScript:completionHandler:

```
// 将分享结果返回给js
NSString *jsStr = [NSString stringWithFormat:@"shareResult('%@','%@','%@')",title,content,url];
[self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) {
    NSLog(@"%@----%@",result, error);
}];
```
##### 使用MessageHandler的好处
- 1.在JS中写起来简单，不用再用创建URL的方式那么麻烦了。
- 2.JS传递参数更方便。使用拦截URL的方式传递参数，只能把参数拼接在后面，如果遇到要传递的参数中有特殊字符，如&、=、？等，必须得转换，否则参数解析肯定会出错。

#### WebViewJavascriptBridge(UIWebView)
##### 第一步，使用Pods 将WebViewJavascriptBridge库添加到工程中。
##### 第二步，创建UIWebView和WebViewJavascriptBridge示例

```
#import <WebViewJavascriptBridge.h>

@interface WebBridgeViewController ()
/** webView */
@property(nonatomic, strong)UIWebView *webView;
/** bridge */
@property(nonatomic, strong)WebViewJavascriptBridge *webViewBridge;

@end
```
- 创建UIWebVIew

```
- (void)drawUI {
    self.webView = [[UIWebView alloc] initWithFrame:self.view.bounds];
    [self.view addSubview:self.webView];
    
    NSURL *htmlURL = [[NSBundle mainBundle] URLForResource:@"index.html" withExtension:nil];
    NSURLRequest *request = [NSURLRequest requestWithURL:htmlURL];
    
    // UIWebView 滚动的比较慢，这里设置为正常速度
    self.webView.scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;
    [self.webView loadRequest:request];
}
```
> 这里不需要为UIWebViews设置代理，因为在创建WebViewJavascriptBridge的时候，UIWebView的代理已经被赋值给了WebViewJavascriptBridge。

- 创建WebViewJavascriptBridge
    * 因为WebViewJavascriptBridge实例，在控制器中多个地方用到，因此最好定义一个property或者实例变量存起来。

```
// WebViewJavascriptBridge
self.webViewBridge = [WebViewJavascriptBridge bridgeForWebView:self.webView];
[self.webViewBridge setWebViewDelegate:self];
```
- 然后看看bridgeForWebView:方法是如何实现的

```
+ (instancetype)bridgeForWebView:(id)webView {
    return [self bridge:webView];
}
+ (instancetype)bridge:(id)webView {
#if defined supportsWKWebView
    if ([webView isKindOfClass:[WKWebView class]]) {
        return (WebViewJavascriptBridge*) [WKWebViewJavascriptBridge bridgeForWebView:webView];
    }
#endif
    if ([webView isKindOfClass:[WVJB_WEBVIEW_TYPE class]]) {
        WebViewJavascriptBridge* bridge = [[self alloc] init];
        [bridge _platformSpecificSetup:webView];
        return bridge;
    }
    [NSException raise:@"BadWebViewType" format:@"Unknown web view type."];
    return nil;
}
```
- 其实{-bridgeForWebView }内部先去判断当前使用的是 WKWebView 还是 UIWebView，然后再分别初始化了一个WebViewJavascriptBridge对象，并为其实例变量_webView 和 _base赋值。

##### 第三步，注册js 要调用的Native 功能。

```
- (void)registerNativeFunctions {
    [self registShareFunction];
    
    [self registLocationFunction];
    
    [self registPayFunction];
}

- (void)registShareFunction {
    [self.webViewBridge registerHandler:@"shareClick" handler:^(id data, WVJBResponseCallback responseCallback) {
        // data 的类型与 JS中传的参数有关
        NSDictionary *tempDic = data;
        // 在这里执行分享的操作
        NSString *title = [tempDic objectForKey:@"title"];
        NSString *content = [tempDic objectForKey:@"content"];
        NSString *url = [tempDic objectForKey:@"url"];
        NSLog(@"JS 传递给 OC 的参数:%@",[NSString stringWithFormat:@"分享成功:%@,%@,%@",title,content,url]);
        
        // 将分享的结果返回到JS中
        NSString *result = [NSString stringWithFormat:@"分享成功:%@,%@,%@",title,content,url];
        responseCallback(result);
    }];
}
```
- - (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler 该方法由两个参数：第一个参数handlerName，是对这个功能起的一个别名。第二个参数handler，是一个block，也就是 Native 实现的功能。JS 要调用的 Native 实现其实就是 block 内{}内的代码功能。
- 为了便于维护，我们可以将JS要调用的Native方法都集中到一起，然后单个功能再封装一个方法。

##### 第四步，完成 HTML 必要的 JS 代码
- HTML 中有一个必须要添加的JS方法，然后需要自动调用一次该方法。该方法是：

```
function setupWebViewJavascriptBridge(callback) {
    if (window.WebViewJavascriptBridge) { return callback(WebViewJavascriptBridge); }
    if (window.WVJBCallbacks) { return window.WVJBCallbacks.push(callback); }
    window.WVJBCallbacks = [callback];
    var WVJBIframe = document.createElement('iframe');
    WVJBIframe.style.display = 'none';
    WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__';
    document.documentElement.appendChild(WVJBIframe);
    setTimeout(function() { document.documentElement.removeChild(WVJBIframe) }, 0)
}
```
- 上面这个方法的参数是一个function，这个方法的作用主要是在第一次加载HTML的时候起作用，目的是加载一次wvjbscheme://__BRIDGE_LOADED__，来触发往HTML中注入一些已经写好的JS方法。
- 看看上面的方法与下面这个是不是很相似：

```
function loadURL(url) {
    var iFrame;
    iFrame = document.createElement("iframe");
    iFrame.setAttribute("src", url);
    iFrame.setAttribute("style", "display:none;");
    iFrame.setAttribute("height", "0px");
    iFrame.setAttribute("width", "0px");
    iFrame.setAttribute("frameborder", "0");
    document.body.appendChild(iFrame);
    // 发起请求后这个iFrame就没用了，所以把它从dom上移除掉
    iFrame.parentNode.removeChild(iFrame);
    iFrame = null;
}
```
- 添加完setupWebViewJavascriptBridge方法，需要在JS中主动调用一次该方法：

```
setupWebViewJavascriptBridge(function(bridge) {
     bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) {
        alert('JS方法被调用:'+data);
        responseCallback('js执行过了');
     })
})
```
- Native 需要调用的 JS 功能，也是需要先注册，然后再执行的。如果Native 需要调用的JS 功能有多个，那么这些功能都要在这里先注册，注册之后才能够被Native 调用。
接下来需要好好分析一下JS 中这个方法的作用了。
- 以下是分析的重点
    * 首先调用setupWebViewJavascriptBridge，第一次执行的时候，由于window.WebViewJavascriptBridge和window.WVJBCallbacks都不存在，所以会继续往下执行，将参数callback（它是一个function）装进数组赋值给window.WVJBCallbacks。
    * js 支持动态添加属性并赋值，这里window.WVJBCallbacks=[callback];就是动态添加属性，并赋值。 另外js中的全局变量都可以使用window.xxxx来调用;动态添加的属性也可以不加window.，直接使用
    * WebViewJavascriptBridge 帮助JS调用Native的url 有两种，一种是wvjbscheme://__BRIDGE_LOADED__；而另一种是wvjbscheme://__WVJB_QUEUE_MESSAGE__。前者只有在调用setupWebViewJavascriptBridge的时候执行一次，一般来说这个url 如果没有页面应该只会执行一次。第二种url所有js调用Native 功能时，都会使用到。
    * 在拦截到自定义的url 时，WebViewJavascriptBridge分了三种情况。
3.1 如果是wvjbscheme://__BRIDGE_LOADED__,就往HMTL 中注入已经写好的js，这个js 在WebViewJavascriptBridge_JS中；
3.2 如果是wvjbscheme://__WVJB_QUEUE_MESSAGE__,那就利用stringByEvaluatingJavaScriptFromString，取回调用js中callHandler传进去的参数。
然后再从WebViewJavascriptBridge之前保存的Native 方法对应的block，调用对应的block。

##### 第五步，调用 Native 功能
- 利用之前注入的JS方法callHandler就可以调用Native 功能了。
- 示例代码如下：

```
function shareClick() {
    var params = {'title':'测试分享的标题','content':'测试分享的内容','url':'http://www.baidu.com'};
    WebViewJavascriptBridge.callHandler('shareClick',params,function(response) {
         alert(response);
        document.getElementById("returnValue").value = response;
     });
}
```
- 这里callHandler前的WebViewJavascriptBridge,其实就是上一步注入到JS中的代码中，动态创建属性，动态赋值的属性。如下代码片段可以在WebViewJavascriptBridge_JS中找到。

```
window.WebViewJavascriptBridge = {
  registerHandler: registerHandler,
  callHandler: callHandler,
  disableJavscriptAlertBoxSafetyTimeout: disableJavscriptAlertBoxSafetyTimeout,
  _fetchQueue: _fetchQueue,
  _handleMessageFromObjC: _handleMessageFromObjC
 };
```
- 而callHandler 内部调用了另一个js function _doSend,而_doSend内部其实，就是把handlerName和 参数data，再加上callbackId 装成键值对，然后保存到数组sendMessageQueue，同时加载一次wvjbscheme://__WVJB_QUEUE_MESSAGE__。
到此 利用WebViewJavascriptBridge实现JS 调用iOS Native 就完成了。

##### 第六步，Native 调用 JS 功能
- Native 调用js 的功能，也需要先在js 中为要调用的功能注册一个别名。
- js 注册Native 要调用的功能

```
setupWebViewJavascriptBridge(function(bridge) {
     bridge.registerHandler('testJSFunction', function(data, responseCallback) {
        alert('JS方法被调用:'+data);
        responseCallback('js执行过了');
     })
    // 注册其他的功能
    //bridge.regsiterHandler.....
})
```
- Native 调用功能的别名handlerName

```
//    // 如果不需要参数，不需要回调，使用这个
//    [_webViewBridge callHandler:@"testJSFunction"];
//    // 如果需要参数，不需要回调，使用这个
//    [_webViewBridge callHandler:@"testJSFunction" data:@"一个字符串"];
    // 如果既需要参数，又需要回调，使用这个
    [_webViewBridge callHandler:@"testJSFunction" data:@"一个字符串" responseCallback:^(id responseData) {
        NSLog(@"调用完JS后的回调：%@",responseData);
    }];
```
- 而callHandler 方法又是如何实现调用js 方法的呢？
callHandler 内部是将传递给js 的参数、handlerName、callbackId组合成字典，然后把字典转换成字符串，将转换后的字符串以参数的形式，通过stringByEvaluatingJavaScriptFromString传递给js ，js 中将传递过来的字符串转成json ，然后通过handlerName 获取对应的function执行。
- 关键的几个代码段：

```
// 这里是Native 调用js ，把参数转换为字符串，执行js 中的_handleMessageFromObjC方法。
- (void)_dispatchMessage:(WVJBMessage*)message {
    NSString *messageJSON = [self _serializeMessage:message pretty:NO];
    [self _log:@"SEND" json:messageJSON];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\\" withString:@"\\\\"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\"" withString:@"\\\""];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\'" withString:@"\\\'"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\r" withString:@"\\r"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\f" withString:@"\\f"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\u2028" withString:@"\\u2028"];
    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@"\u2029" withString:@"\\u2029"];
    
    NSString* javascriptCommand = [NSString stringWithFormat:@"WebViewJavascriptBridge._handleMessageFromObjC('%@');", messageJSON];
    if ([[NSThread currentThread] isMainThread]) {
        [self _evaluateJavascript:javascriptCommand];

    } else {
        dispatch_sync(dispatch_get_main_queue(), ^{
            [self _evaluateJavascript:javascriptCommand];
        });
    }
}
```
- 下面这里是找到handlerName对应的function，并执行function。

```
var handler = messageHandlers[message.handlerName];
    if (!handler) {
     console.log("WebViewJavascriptBridge: WARNING: no handler for message from ObjC:", message);
    } else {
     handler(message.data, responseCallback);
    }
}
```
- 到这里 利用WebViewJavascriptBridge 实现Native 调用js 的功能就完成了。
> 注意：JS 有动态参数的特性，调用js 的方法，可以传0个参数，1个参数，N个参数都可以。
例如，我们在js中定义一个test()方法，我们可以调用test()，来执行这个方法；如果有参数要传进来，也可以调用test(xxx)；如果有多个参数，那么就用test(xxx,xxx)。当然如果我们定义的参数是test(a,b,c)，也可以少传参数，或者不传参数调用test()。

##### 总结
- 利用WebViewJavascriptBridge来实现JS与OC的交互的优点：
    * 获取参数时，更方便一些，如果参数中有一些特殊符号或者url带参数，能够很好的解析。
- 一些缺点：
    * 做一次交互，需要执行的js与原生的交互步骤较多，至少有两次。
    * 需要花较多的时间，理解WebViewJavascriptBridge的原理和使用步骤。

#### WebViewJavascriptBridge(WKWebView)

### 2.在使用 WKWedView 时遇到过哪些问题？
### 3.是否了解 UIWebView 的插件化？
### 4.是否了解 SFSafariViewController ？


## 音频处理

## 视频处理
### 补充：AVFoundation原理
- AFNetworking 底层原理分析
- AFNetworking是封装的NSURLSession的网络请求，由五个模块组成：分别由NSURLSession,Security,Reachability,Serialization,UIKit五部分组成
- NSURLSession：网络通信模块（核心模块） 对应 AFNetworking中的 AFURLSessionManager和对HTTP协议进行特化处理的AFHTTPSessionManager,AFHTTPSessionManager是继承于AFURLSessionmanager的
- Security：网络通讯安全策略模块 对应 AFSecurityPolicy
- Reachability：网络状态监听模块 对应AFNetworkReachabilityManager
- Seriaalization：网络通信信息序列化、反序列化模块 对应 AFURLResponseSerialization
- UIKit：对于iOS UIKit的扩展库

### AFN3.0与2.0区别，AFN4.0
#### 发展历程
- AFNetworking 1.0建立在NSURLConnection的基础API之上
- AFNetworking 2.0开始使用NSURLConnection的基础API ，以及较新基于NSURLSession的API的选项。
- AFNetworking 3.0现已完全基于NSURLSession的API，这降低了维护的负担，同时支持苹果增强关于NSURLSession提供的任何额外功能。
- AFNetworking 2.X将继续获得关键的隐患和安全补丁，但没有新的功能将被添加。Alamofire(Swift下的网络请求)软件基金会建议，所有的项目迁移到基于NSURLSession的API。

#### 废弃与新增
- 下面的类已从AFNetworking 3.0中废弃：
    * AFURLConnectionOperation
    * AFHTTPRequestOperation
    * AFHTTPRequestOperationManager
- 依次被下面三个类代替了，同时请求方法也跟着改变了
    * AFURLSessionManager
    * AFHTTPSessionManager
    * AFNetworkReachabilityManager
- 下面的类包含基于NSURLConnection的API的内部实现。他们已经被NSURLSession重构:
    * UIImageView+AFNetworking
    * UIWebView+AFNetworking
    * UIButton+AFNetworking

#### 迁移
- AFHTTPRequestOperationManager与AFHTTPSessionManager
    * 如果你以前使用 AFHTTPRequestOperationManager ， 你将需要迁移去使用 AFHTTPSessionManager。 以下的类在两者过渡间并没有变化：
        * securityPolicy
        * requestSerializer
        * responseSerializer
    * 接下来举一个关于AFHTTPSessionManager的简单例子。注意HTTP网络请求返回的不再是AFHTTPRequestOperation, 修改成为了NSURLSessionTask，并且成功和失败的Block块中的参数也变更为了NSURLSessionTask，而不再是AFHTTPRequestOperation。
    * 

### 一个完整直播app功能

![image](https://upload-images.jianshu.io/upload_images/8957764-fc94afcbe56ece0b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

#### 基本概念
- 一个完整直播app原理
    * 直播原理：把主播录制的视频，推送到服务器，在由服务器分发给观众观看。
    * 直播环节：推流端（采集、美颜处理、编码、推流）、服务端处理（转码、录制、截图、鉴黄）、播放器（拉流、解码、渲染）、互动系统（聊天室、礼物系统、赞）
- 一个完整直播app实现流程
    * 1.采集、2.滤镜处理、3.编码、4.推流、5.CDN分发、6.拉流、7.解码、8.播放、9.聊天互动
- 一个完整直播app架构

![image](https://upload-images.jianshu.io/upload_images/304825-54974199408c0cc1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

#### 一个完整直播app技术点

![image](https://upload-images.jianshu.io/upload_images/304825-9b64e9596f3ccdce.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

#### 了解流媒体（直播需要用到流媒体）
- 流媒体开发:网络层(socket或st)负责传输，协议层(rtmp或hls)负责网络打包，封装层(flv、ts)负责编解码数据的封装，编码层(h.264和aac)负责图像，音频压缩。
- 帧:每帧代表一幅静止的图像
- GOP:（Group of Pictures）画面组，一个GOP就是一组连续的画面，每个画面都是一帧，一个GOP就是很多帧的集合
    * 直播的数据，其实是一组图片，包括I帧、P帧、B帧，当用户第一次观看的时候，会寻找I帧，而播放器会到服务器寻找到最近的I帧反馈给用户。因此，GOP Cache增加了端到端延迟，因为它必须要拿到最近的I帧
    * GOP Cache的长度越长，画面质量越好
- 码率：图片进行压缩后每秒显示的数据量。
- 帧率：每秒显示的图片数。影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。
    * 由于人类眼睛的特殊生理结构，如果所看画面之帧率高于16的时候，就会认为是连贯的，此现象称之为视觉暂留。并且当帧速达到一定数值后，再增长的话，人眼也不容易察觉到有明显的流畅度提升了。
- 分辨率：(矩形)图片的长度和宽度，即图片的尺寸
- 压缩前的每秒数据量:帧率X分辨率(单位应该是若干个字节)
- 压缩比:压缩前的每秒数据量/码率 （对于同一个视频源并采用同一种视频编码算法，则：压缩比越高，画面质量越差。）
- 视频文件格式：文件的后缀，比如.wmv,.mov,.mp4,.mp3,.avi,
    * 主要用处，根据文件格式，系统会自动判断用什么软件打开,
注意: 随意修改文件格式，对文件的本身不会造成太大的影响，比如把avi改成mp4,文件还是avi.
- 视频封装格式：一种储存视频信息的容器，流式封装可以有TS、FLV等，索引式的封装有MP4,MOV,AVI等，
    * 主要作用：一个视频文件往往会包含图像和音频，还有一些配置信息(如图像和音频的关联，如何解码它们等)：这些内容需要按照一定的规则组织、封装起来.
    * 注意：会发现封装格式跟文件格式一样，因为一般视频文件格式的后缀名即采用相应的视频封装格式的名称,所以视频文件格式就是视频封装格式。
- 视频封装格式和视频压缩编码标准：就好像项目工程和编程语言，封装格式就是一个项目的工程，视频编码方式就是编程语言，一个项目工程可以用不同语言开发。

#### 直播基础知识介绍
##### 1.采集视频、音频
- 采集视频、音频编码框架
    * AVFoundation:AVFoundation是用来播放和创建实时的视听媒体数据的框架，同时提供Objective-C接口来操作这些视听数据，比如编辑，旋转，重编码
- 视频、音频硬件设备
    * CCD:图像传感器： 用于图像采集和处理的过程，把图像转换成电信号。
    * 拾音器:声音传感器： 用于声音采集和处理的过程，把声音转换成电信号。
    * 音频采样数据:一般都是PCM格式
    * 视频采样数据: 一般都是YUV,或RGB格式，采集到的原始音视频的体积是非常大的，需要经过压缩技术处理来提高传输效率

##### 2.视频处理（美颜，水印）
    * 视频处理原理:因为视频最终也是通过GPU，一帧一帧渲染到屏幕上的，所以我们可以利用OpenGL ES，对视频帧进行各种加工，从而视频各种不同的效果，就好像一个水龙头流出的水，经过若干节管道，然后流向不同的目标
    * 现在的各种美颜和视频添加特效的app都是利用GPUImage这个框架实现的
- 视频处理框架
    * GPUImage : GPUImage是一个基于OpenGL ES的一个强大的图像/视频处理框架,封装好了各种滤镜同时也可以编写自定义的滤镜,其本身内置了多达120多种常见的滤镜效果。
    * OpenGL:OpenGL（全写Open Graphics Library）是个定义了一个跨编程语言、跨平台的编程接口的规格，它用于三维图象（二维的亦可）。OpenGL是个专业的图形程序接口，是一个功能强大，调用方便的底层图形库。
    * OpenGL ES:OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。

##### 3.视频编码解码
- 视频编码框架
    * FFmpeg:是一个跨平台的开源视频框架,能实现如视频编码,解码,转码,串流,播放等丰富的功能。其支持的视频格式以及播放协议非常丰富,几乎包含了所有音视频编解码、封装格式以及播放协议。
        * -Libswresample:可以对音频进行重采样,rematrixing 以及转换采样格式等操 作。
        * -Libavcodec:提供了一个通用的编解码框架,包含了许多视频,音频,字幕流 等编码/解码器。
        * -Libavformat:用于对视频进行封装/解封装。
        * -Libavutil:包含一些共用的函数,如随机数生成,数据结构,数学运算等。
        * -Libpostproc:用于进行视频的一些后期处理。
        * -Libswscale:用于视频图像缩放,颜色空间转换等。
        * -Libavfilter:提供滤镜功能。
    * X264:把视频原数据YUV编码压缩成H.264格式
    * VideoToolbox:苹果自带的视频硬解码和硬编码API，但是在iOS8之后才开放。
    * AudioToolbox:苹果自带的音频硬解码和硬编码API
- 视频编码技术
    * 视频压缩编码标准：对视频进行压缩(视频编码)或者解压缩（视频解码）的编码技术,比如MPEG，H.264,这些视频编码技术是压缩编码视频的
        * 主要作用:是将视频像素数据压缩成为视频码流，从而降低视频的数据量。如果视频不经过压缩编码的话，体积通常是非常大的，一部电影可能就要上百G的空间。
        * 注意:最影响视频质量的是其视频编码数据和音频编码数据，跟封装格式没有多大关系
    * MPEG:一种视频压缩方式，它采用了帧间压缩，仅存储连续帧之间有差别的地方 ，从而达到较大的压缩比
    * H.264/AVC:一种视频压缩方式,采用事先预测和与MPEG中的P-B帧一样的帧预测方法压缩，它可以根据需要产生适合网络情况传输的视频流,还有更高的压缩比，有更好的图象质量
        * 注意1:如果是从单个画面清晰度比较，MPEG4有优势；从动作连贯性上的清晰度，H.264有优势
        * 注意2:由于264的算法更加复杂，程序实现烦琐，运行它需要更多的处理器和内存资源。因此，运行264对系统要求是比较高的。
        * 注意3:由于264的实现更加灵活，它把一些实现留给了厂商自己去实现，虽然这样给实现带来了很多好处，但是不同产品之间互通成了很大的问题，造成了通过A公司的编码器编出的数据，必须通过A公司的解码器去解这样尴尬的事情
    * H.265/HEVC:一种视频压缩方式,基于H.264，保留原来的某些技术，同时对一些相关的技术加以改进，以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。
        * H.265 是一种更为高效的编码标准，能够在同等画质效果下将内容的体积压缩得更小，传输时更快更省带宽
        * I帧:(关键帧)保留一副完整的画面，解码时只需要本帧数据就可以完成（因为包含完整画面）
    * P帧:(差别帧)保留这一帧跟之前帧的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（P帧没有完整画面数据，只有与前一帧的画面差别的数据）
    * B帧:(双向差别帧)保留的是本帧与前后帧的差别，解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累
    * 帧内（Intraframe）压缩:当压缩一帧图像时，仅考虑本帧的数据而不考虑相邻帧之间的冗余信息,帧内一般采用有损压缩算法
    * 帧间（Interframe）压缩:时间压缩（Temporal compression），它通过比较时间轴上不同帧之间的数据进行压缩。帧间压缩一般是无损的
    * muxing（合成）：将视频流、音频流甚至是字幕流封装到一个文件中(容器格式（FLV，TS）)，作为一个信号进行传输。
- 音频编码技术
    * AAC，mp3：这些属于音频编码技术,压缩音频用
- 码率控制 
    * 多码率:观众所处的网络情况是非常复杂的，有可能是WiFi，有可能4G、3G、甚至2G，那么怎么满足多方需求呢？多搞几条线路，根据当前网络环境自定义码率。
    * 列如：常常看见视频播放软件中的1024，720，高清，标清，流畅等，指的就是各种码率。
- 视频封装格式
    * TS : 一种流媒体封装格式，流媒体封装有一个好处，就是不需要加载索引再播放，大大减少了首次载入的延迟，如果片子比较长，mp4文件的索引相当大，影响用户体验
        * 为什么要用TS:这是因为两个TS片段可以无缝拼接，播放器能连续播放
    * FLV: 一种流媒体封装格式,由于它形成的文件极小、加载速度极快，使得网络观看视频文件成为可能,因此FLV格式成为了当今主流视频格式

##### 4.推流
- 数据传输框架
    * librtmp:用来传输RTMP协议格式的数据
- 流媒体数据传输协议
    * RTMP:实时消息传输协议,Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输开发的开放协议，因为是开放协议所以都可以使用了。
        * RTMP协议用于对象、视频、音频的传输。
        * 这个协议建立在TCP协议或者轮询HTTP协议之上。
        * RTMP协议就像一个用来装数据包的容器，这些数据可以是FLV中的视音频数据。一个单一的连接可以通过不同的通道传输多路网络流，这些通道中的包都是按照固定大小的包传输的
    * chunk:消息包

##### 流媒体服务器
- 常用服务器
    * SRS：一款国人开发的优秀开源流媒体服务器系统
    * BMS:也是一款流媒体服务器系统，但不开源，是SRS的商业版，比SRS功能更多
    * nginx:免费开源web服务器，常用来配置流媒体服务器。
- 数据分发
    * CDN：(Content Delivery Network)，即内容分发网络,将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度.
        * CDN：代理服务器，相当于一个中介。
        * CDN工作原理：比如请求流媒体数据
            * 1.上传流媒体数据到服务器（源站）
            * 2.源站存储流媒体数据
            * 3.客户端播放流媒体，向CDN请求编码后的流媒体数据
            * 4.CDN的服务器响应请求，若节点上没有该流媒体数据存在，则向源站继续请求流媒体数据；若节点上已经缓存了该视频文件，则跳到第6步。
            * 5.源站响应CDN的请求，将流媒体分发到相应的CDN节点上
            * 6.CDN将流媒体数据发送到客户端
    * 回源：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取搜索。如果没有人访问，那么CDN节点不会主动去源站拿.
    * 带宽:在固定的时间可传输的数据总量
        * 比如64位、800MHz的前端总线，它的数据传输率就等于64bit×800MHz÷8(Byte)=6.4GB/s
    * 负载均衡: 由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助.
        * 通过某种负载分担技术，将外部发送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。
        * 均衡负载能够平均分配客户请求到服务器列阵，籍此提供快速获取重要数据，解决大量并发访问服务问题。
        * 这种群集技术可以用最少的投资获得接近于大型主机的性能。
    * QoS（带宽管理）:限制每一个组群的带宽，让有限的带宽发挥最大的效用

##### 拉流
- 直播协议选择：
    * 即时性要求较高或有互动需求的可以采用RTMP,RTSP
    * 对于有回放或跨平台需求的，推荐使用HLS
    * `直播协议对比`    :

![image](https://upload-images.jianshu.io/upload_images/304825-f92e85515845e107.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- HLS:由Apple公司定义的用于实时流传输的协议,HLS基于HTTP协议实现，传输内容包括两部分，一是M3U8描述文件，二是TS媒体文件。可实现流媒体的直播和点播，主要应用在iOS系统
    * HLS是以点播的技术方式来实现直播
    * HLS是自适应码率流播，客户端会根据网络状况自动选择不同码率的视频流，条件允许的情况下使用高码率，网络繁忙的时候使用低码率，并且自动在二者间随意切
换。这对移动设备网络状况不稳定的情况下保障流畅播放非常有帮助。
    * 实现方法是服务器端提供多码率视频流，并且在列表文件中注明，播放器根据播放进度和下载速度自动调整。
- HLS与RTMP对比:HLS主要是延时比较大，RTMP主要优势在于延时低
    * HLS协议的小切片方式会生成大量的文件，存储或处理这些文件会造成大量资源浪费
    * 相比使用RTSP协议的好处在于，一旦切分完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了CDN边缘服务器的配置要求，可以使用任何现成的CDN,而一般服务器很少支持RTSP。
- HTTP-FLV:基于HTTP协议流式的传输媒体内容。
    * 相对于RTMP，HTTP更简单和广为人知，内容延迟同样可以做到1~3秒，打开速度更快，因为HTTP本身没有复杂的状态交互。所以从延迟角度来看，HTTP-FLV要优于RTMP。
- RTSP:实时流传输协议,定义了一对多应用程序如何有效地通过IP网络传送多媒体数据.
- RTP:实时传输协议,RTP是建立在UDP协议上的，常与RTCP一起使用，其本身并没有提供按时发送机制或其它服务质量（QoS）保证，它依赖于低层服务去实现这一过程。
- RTCP:RTP的配套协议,主要功能是为RTP所提供的服务质量（QoS）提供反馈，收集相关媒体连接的统计信息，例如传输字节数，传输分组数，丢失分组数，单向和双向网络延迟等等。

##### 解码
- 解封装
    * demuxing（分离）：从视频流、音频流，字幕流合成的文件(容器格式（FLV，TS）)中， 分解出视频、音频或字幕，各自进行解码。
- 音频编码框架
    * fdk_aac:音频编码解码框架，PCM音频数据和AAC音频数据互转
- 解码介绍
    * 硬解码：用GPU来解码，减少CPU运算
        * 优点：播放流畅、低功耗，解码速度快，
        * 缺点：兼容不好
    * 软解码：用CPU来解码
        * 优点：兼容好
        * 缺点：加大CPU负担，耗电增加、没有硬解码流畅，解码速度相对慢

##### 播放
- ijkplayer:一个基于FFmpeg的开源Android/iOS视频播放器
    * API易于集成；
    * 编译配置可裁剪，方便控制安装包大小；
    * 支持硬件加速解码，更加省电
    * 简单易用，指定拉流URL，自动解码播放.

##### 聊天互动
- IM:(InstantMessaging)即时通讯:是一个实时通信系统，允许两人或多人使用网络实时的传递文字消息、文件、语音与视频交流.
    * IM在直播系统中的主要作用是实现观众与主播、观众与观众之间的文字互动.
- 腾讯云：腾讯提供的即时通讯SDK，可作为直播的聊天室
- 融云：一个比较常用的即时通讯SDK，可作为直播的聊天室

####  








## 图像处理
### 1.图像的压缩、解压。
### 2.一张物理体积20KB、分辨率为 200 * 300 的图片，在内存中占用多大的空间？
### 3.GLSurfaceView的相关知识，OpenGL，Shader，绘制流程。


## iOS 动画
### 1.简要说一下常用的动画库。
### 2.请说一下对 CALayer 的认识。
### 3.解释一下 CALayer.contents 属性。
### 4.在 iOS 中，动画有哪几种类型？
### 5.隐式动画
### 6.显式动画

## 蓝牙

## ARKit

## Core ML


## 代码管理、持续集成、项目托管
### 1.Git
#### 1.`git pull` 和 `git fetch` 的区别？
#### 2.`git merge` 和 `git rebase` 的区别？
#### 3.如何在本地新建一个分支，并 push 到远程服务器上？
#### 4.如果 fork 了一个别人的仓库，怎样与源仓库保持同步
#### 5.总结一下 Git 常用的命令？
### 2.Svn
### 3.CocoaPods
#### 1.说一下 `CocoaPods` 的原理？
#### 2.如何让自己写的框架支持 `CocoaPods`？
#### 3.`pod update` 和 `pod install` 有什么区别？
#### 4.`Podfile.lock` 文件起什么作用？
#### 5.CocoaPods 常用指令？
#### 6.在使用 CocoaPods 中遇到过哪些问题？
#### 7.如何使用 CocoaPods 集成远程私有库？
#### 8.如果自己写的库需要依赖其他的三方库，该怎么办？
#### 9.CocoaPods 中的 Subspec 字段有什么用处？
### 4.Carthage
### 5.Fastlane
### 6.Jenkins
### 7.fir.im
### 8.蒲公英
### 9.TestFlight


## 数据安全及加密
### 1.RSA非对称加密  
### 2.AES对称加密
### 3.DES加密
### 4.Base64加密
### 5.MD5加密
### 6.简述 `SSL` 加密的过程用了哪些加密方法，为何这么作？
### 7.是否了解 `iOS` 的签名机制？
### 8.如何对 `APP` 进行重签名？
### 9.在HTTPS建立连接的时候都用了哪些加密算法，为什么要这么设计
### 10.常见的加密算法
### 11.对称加密算法和非对称加密算法的区别


## 源代码阅读
### 1.YYKit
### 2.SDWebImage
#### 面试常见问题
#### 1.看过sdwebimage的源码吗？说一下sdwebimage的原理
- SDWebImage加载图片的流程
    * 入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage显示，然后 SDWebImageManager根据 URL 开始处理图片。
    * 进入SDWebImageManager类中downloadWithURL:delegate:options:userInfo:，交给 SDImageCache从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
    * 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate回调 imageCache:didFindImage:forKey:userInfo:到 SDWebImageManager。
    * SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache,等前端展示图片。
    * 如果内存缓存中没有，生成 ｀NSOperation ｀ 添加到队列，开始从硬盘查找图片是否已经缓存。
    * 根据 URL的MD5值Key在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。
    * 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小， 会先清空内存缓存）。SDImageCacheDelegate'回调 imageCache:didFindImage:forKey:userInfo:`。进而回调展示图片。
    * 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片， 回调 imageCache:didNotFindImageForKey:userInfo:。
    * 共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。
    * 图片下载由 NSURLConnection来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。
    * connection:didReceiveData: 中利用 ImageIO做了按图片下载进度加载效果。
    * connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder做图片解码处理。
    * 图片解码处理在一个 NSOperationQueue完成，不会拖慢主线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
    * 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成 imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader`。
    * imageDownloader:didFinishWithImage:回调给 SDWebImageManager告知图片 下载完成。
    * 通知所有的 downloadDelegates下载完成，回调给需要的地方展示图片。
    * 将图片保存到 SDImageCache中，内存缓存和硬盘缓存同时保存。写文件到硬盘 也在以单独 NSOperation 完成，避免拖慢主线程。
    * SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候清理过期图片。
#### 2.说一下SDWebImage的缓存策略？
- 有一个专门的 Cache 分类用来处理图片的缓存。 这里面也有两个类 SDImageCache 和 SDImageCacheConfig。 大部分的缓存处理都在 SDImageCache 这个类中实现。
- SDImageCache 中有一个叫做 memCache 的属性，它是一个 NSCache 对象，用于实现我们对图片的 Memory Cache，其实就是接受系统的内存警告通知，然后清除掉自身的图片缓存。Disk Cache，也就是文件缓存，SDWebImage 会将图片存放到 NSCachesDirectory目录中，然后为每一个缓存文件生成一个 md5 文件名, 存放到文件中。
- Memory 和 Disk 双缓存
    * Memory(内存)中查找：SDImageCache 类的 queryDiskCacheForKey方法，查询图片缓存，queryDiskCacheForKey 方法内部， 先会查询 Memory Cache ，如果查找到就直接返回，反之进入下面的硬盘查找。
    * Disk(硬盘) 中查找：如果 Memory Cache查找不到， 就会查询 Disk Cache，查询Disk Cache 的时候有一个小插曲，就是如果 Disk Cache 查询成功，还会把得到的图片再次设置到 Memory Cache 中。这样做可以最大化那些高频率展现图片的效率。如果找不到就进入下面的网络下载。
    * 网路下载：请求网络使用的是imageDownloader属性，这个示例专门负责下载图片数据。如果下载失败， 会把失败的图片地址写入failedURLs集合，为什么要有这个 failedURLs 呢，因为SDWebImage默认会有一个对上次加载失败的图片拒绝再次加载的机制。也就是说，一张图片在本次会话加载失败了，如果再次加载就会直接拒绝，SDWebImage这样做可能是为了提高性能。如果下载图片成功了，接下来就会使用 [self.imageCache storeImage]方法将它写入缓存，同时也会写入硬盘，并且调用 completedBlock 告诉前端显示图片。
    * Disk(硬盘)缓存清理策略：SDWebImage 会在每次 APP 结束的时候执行清理任务。清理缓存的规则分两步进行。第一步先清除掉过期的缓存文件。如果清除掉过期的缓存之后，空间还不够。那么就继续按文件时间从早到晚排序，先清除最早的缓存文件，直到剩余空间达到要求。

#### 补充：如何设计一个图片缓存框架？
- 可以模仿 SDWebImage 来实现。
- 构成
    * Manager
    * 内存缓存
    * 磁盘缓存
    * 网络下载
    * Code Manager
        * 图片解码
        * 图片解压缩
        * 图片的存储是以图片的单向 hash 值为 Key
- 内存设计需要考虑的问题
    * 存储的 Size
        * 因为内存的空间有限，我们针对不同尺寸的图片，给出不同的方案
        * 10K 以下的50个
        * 100Kb 以下的20个
        * 100kb 以上的10个
    * 淘汰的策略
        * 内存的淘汰策略采取LRU（最近最少使用算法）
        * 触发淘汰策略的时机有三种
            * 定期检查（不建议，耗性能）
            * 提高检查触发频率（一定要注意开销）
                * 前后台切换的时候
                * 每次读写的时候
- 磁盘设计需要考虑的问题
    * 存储方式
    * 大小限制（有固定的大小）
    * 移除策略（可以设置为7天或者15天）
- 网络设计需要考虑的问题
    * 图片请求的最大并发量
    * 请求超时策略
    * 请求优先级
- 图片解码
    * 应用 策略模式，针对 jpg、png、gif 等不同的图片格式进行解码
    * 图片解码的时机
        * 在 子线程 图片刚下载完时
        * 在 子线程 刚从磁盘读取完时
        * 避免在主线程解压缩、解码，避免卡顿

#### 3.磁盘缓存时间，默认的缓存路径，怎么处理图片的名称?默认的超时时间是多少?最大并发数？
#### 4.该框架内部对内存警告的处理方式?（或者问：当app接收到内存警告时，SDWebImage做了什么？）
#### 5.NSCache和字典的区别？
#### 6.如何计算图片的成本?
#### 7.保证错误的URL不会被尝试重新下载，使用什么来下载图片的 
#### 8.sdwebimage是一个异步下载图片的三方，怎么保证线程安全的？
#### 9.如果一个页面 加载图片很卡 ，什么原因，会跟sdwebimage有关吗，还是跟图片渲染有关？
#### 10.如果收到内存警告怎么办
- 如果使用了SDWebImage框架,使用如下代码,可以有效的减少内存:

```
[[SDImageCache sharedImageCache] setValue:nil forKey:@"memCache"];//清除内存中通过SDWebImage框架下载的图片,建议在收到内存警告时在调用
```
#### 11.SDWebImage是如何做到Url不变的情况下，更新图片内容的？
- SDWebImage它是基于URL作为Key来实现图片缓存机制的。大多数情况下，片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变更的图片内容。
- 客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。
- 客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？
- 通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。
- Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。
- 那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：

```
SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;
imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) {

    NSFileManager *fm = [[NSFileManager alloc] init];
    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];
    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];
    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];

    NSMutableDictionary *mutableHeaders = [headers mutableCopy];

    NSDate *lastModifiedDate = nil;

    if (fileAttr.count > 0) {
        if (fileAttr.count > 0) {
            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];
        }

    }
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"];
    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];
    formatter.dateFormat = @"EEE, dd MMM yyyy HH:mm:ss z";

    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];
    lastModifiedStr = lastModifiedStr.length > 0 ? lastModifiedStr : @"";
    [mutableHeaders setValue:lastModifiedStr forKey:@"If-Modified-Since"];

    return mutableHeaders;
};

```
- 然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached

```
NSURL *imgURL = [NSURL URLWithString:@"http://handy-img-storage.b0.upaiyun.com/3.jpg"];  
[[self imageView] sd_setImageWithURL:imgURL  
                    placeholderImage:nil  
                             options:SDWebImageRefreshCached];
                             
```
- 经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。
从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。
- 这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。
- OK，到此这次的主题已得到完美解决。
- 其实，在抓取服务器返回的数据包时，还发现response header中还有一个ETag，与之相对应的request header中可以追加一个If-None-Match的key，这对header与Last-Modified、If-Modified-Since的作用是相同的，即服务器是否需要返回最新的图片，当然它们在服务器端的判断逻辑应该是等与不等的判断，Etag在客户端的存储同样可以采用在plist文件中存放图片key名称与Etag的对应关系。

### 3.AFNetworking
### 4.SVProgressHub 
### 5.Texture（ASDK）


## iOS逆向及安全
### 1.怎么防止反编译？
- 本地数据加密。
    * iOS应用防反编译加密技术之一：对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息
- URL编码加密。
    * iOS应用防反编译加密技术之二：对程序中出现的URL进行编码加密，防止URL被静态分析
- 网络传输数据加密。
    * iOS应用防反编译加密技术之三：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据
- 方法体，方法名高级混淆。
    * iOS应用防反编译加密技术之四：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码
- 程序结构混排加密。
    * iOS应用防反编译加密技术之五：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低

### 2.项目中网络层如何做安全处理？
- 尽量使用https
    * https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。
- 不要传输明文密码
    * 不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh，token去申请新的token。
- Post并不比Get安全
    * 事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。
- 不要使用301跳转
    * 301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。
- http请求都带上MAC
    * 所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。
- http请求使用临时密钥
    * 高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。
- AES使用CBC模式
    * 不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。


## Coretext
## 项目组件化
### 1.说一下你之前项目的组件化方案？
### 2.项目的组件化模块应该如何划分？
### 3.如何集成本地私有库？
### 4.如何集成远程私有库？


## 性能优化
### 1.如何提升 `tableview` 的流畅度？
- 本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。
    * CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制
    * GPU：纹理的渲染
- 卡顿优化在 CPU 层面
    * 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
    * 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
    * 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
    * Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
    * 图片的 size 最好刚好跟 UIImageView 的 size 保持一致
    * 控制一下线程的最大并发数量
    * 尽量把耗时的操作放到子线程
        * 文本处理（尺寸计算、绘制）
        * 图片处理（解码、绘制）
- 卡顿优化在 GPU层面
    * 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
    * GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
    * 尽量减少视图数量和层次
    * 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES
    * 尽量避免出现离屏渲染
- iOS 保持界面流畅的技巧
    * 预排版，提前计算
        * 在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。
        * 尽量少用 UILabel，可以使用 CALayer 。避免使用AutoLayout的自动布局技术，采取纯代码的方式
    * 预渲染，提前绘制
        * 例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了，避免使用CALayer的Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。
    * 异步绘制
    * 全局并发线程
    * 高效的图片异步加载

### 2.如何使用 `Instruments` 进行性能调优？(Time Profiler、Zombies、Allocations、Leaks)
### 3.如何优化 `APP` 的启动时间
- App启动过程
    * 解析Info.plist
    * 加载相关信息，例如闪屏
    * 沙箱建立、权限检查
    * Mach-O加载
    * 如果是胖二进制文件，寻找合适当前CPU类别的部分
    * 加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）
    * 定位内部、外部指针引用，例如字符串、函数等
    * 执行声明为attribute((constructor))的C函数
    * 加载类扩展（Category）中的方法
    * C++静态对象加载、调用ObjC的 +load 函数
    * 程序执行
    * 调用main()
    * 调用UIApplicationMain()
    * 调用applicationWillFinishLaunching
- 影响启动性能的因素
    * main()函数之前耗时的影响因素
        * 动态库加载越多，启动越慢。
        * ObjC类越多，启动越慢
        * C的constructor函数越多，启动越慢
        * C++静态对象越多，启动越慢
        * ObjC的+load越多，启动越慢
    * main()函数之后耗时的影响因素
        * 执行main()函数的耗时
        * 执行applicationWillFinishLaunching的耗时
        * rootViewController及其childViewController的加载、view及其subviews的加载

### 4.今日头条的启动优化方案
- 针对于今日头条这个App我们可以优化的点如下：
    * 纯代码方式而不是storyboard加载首页UI。
    * 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。
    * 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载。
    * 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。
    * 上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。

### 5.如何对 `APP` 进行内存、电量、网络流量的优化
### 6.如何有效降低 `APP` 包的大小？
- 可执行文件
    * 编译器优化
        * Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES
        * 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions
    * 利用 AppCode 检测未使用的代码：菜单栏 -> Code -> Inspect Code
    * 编写LLVM插件检测出重复代码、未被调用的代码
- 资源
    * 资源包括 图片、音频、视频 等
    * 优化的方式可以对资源进行无损的压缩
    * 去除没有用到的资源

### 7.日常如何检查内存泄露？
- 目前我知道的方式有以下几种
    * Memory Leaks
    * Alloctions
    * Analyse
    * Debug Memory Graph
    * MLeaksFinder
- 泄露的内存主要有以下两种
    * Laek Memory这种是忘记Release操作所泄露的内存。
    * Abandon Memory这种是循环引用，无法释放掉的内存。

### 8.能不能说一下物理屏幕显示的原理？
- CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，视频控制器收到VSync信号后逐行读取帧缓冲区的数据，再经过一定的数模转换传递给显示器显示。
- iOS屏幕刷新机制
    * 为了解决单缓存区的问题，iOS设备在这个过程中采取了如下图所示的双缓存区+VSync机制：
        * GPU 会预先渲染好一帧放入一个缓存区内（前帧缓存）。
        * 在显示器发出VSync后，视频控制器的指针会指向前帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入另一个缓存区（后帧缓存）。
        * 在显示器发出新的VSync后，视频控制器的指针会指向后帧缓存区并开始读取，GPU开始渲染下一帧，并将渲染结果放入前帧缓存区。
- 双缓存和VSync造成的问题
    * 每一帧画面要先经过CPU计算，再经过GPU渲染，最后存入缓存区供视频控制器读取。由于垂直同步的机制，如果在一个VSync时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，而这时显示屏会保留之前的内容不变，也就造成界面卡顿。
- 为了降低双缓存造成界面卡顿的几率，有些设备（如安卓设备）会引入三缓存+VSync机制，但iOS设备一直都是双缓存+垂直同步机制。
- 三缓存区的工作原理同双缓冲类似，只是多了一个 Back Buffer（图中的缓存区C）。三缓存区只是能降低界面卡顿的几率，并不能解决这个问题。

### 9.解释一下什么是屏幕卡顿、掉帧？该如何避免？
- 图像显示相关的原理
    * iOS系统中 CPU、GPU、显示器是以下面图中方式协同工作的。CPU和GPU是通过总线链接起来的，CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过数模转换传递给显示器显示。 
- 关于CPU和GPU的分工又有以下内容：
    * CPU负责：
        * 对象创建和销毁
        * 对象属性调整
        * 布局计算、文本的计算
        * 排版、图片的格式转换和解码
        * 图像的绘制
    * GPU负责：
        * 纹理的渲染
        * 视图的混合
        * 图形的生成
- IOS视图卡顿掉帧的原因
    * 标准情况下，页面滑动流畅是60FPs ，就是每一秒有60帧的画面刷新，每16.7ms(1/60秒)有一帧数据。上图两个VSync 之间的时间就是16.7ms。 如果CPU 和 GPU 加起来的处理时间超过了 16.7ms，就会造成掉帧甚至卡顿。当FPs 帧数低于30时，人的肉眼就能感觉到画面明显的卡顿。
- 如何监控界面的卡顿
    * 思路一：监控一秒钟内的帧数是否经常低于或远低于 60FPs。
    * 思路二：监控每一帧的时长是否超时。
- 思路一实现方法：用 CADisplayLinker 来计数
> CADisplayLink可以以屏幕刷新的频率调用指定selector，iOS系统中正常的屏幕刷新率为60次/秒，只要在这个方法里面统计每秒这个方法执行的次数，通过次数/时间就可以得出当前屏幕的刷新率了。

- 思路二实现方法：通过子线程监测主线程的RunLoop，判断两个状态RunLoop的状态区域之间的耗时是否达到一定阈值。
> 开启子线程,实时计算这两个状态区域之间的耗时是否到达某个阀值,便能揪出这些性能杀手，假定连续6次超时50ms认为卡顿(当然也包含了单次超时300ms)

- 如何优化掉帧卡顿
    * 图像显示的工作是由CPU和GPU协同完成的， 那么优化的方向和思路就是尽量减少他们的处理时长。
    * 对CPU处理的优化:
        * 在子线程中进行对象的创建,调整和销毁，节省一部分CPU的时间
        * 在子线程中预排版(布局计算,文本计算)，让主线程有更多的时间去响应用户的交互
        * 对文本等异步绘制,图片编解码等内容进行 预渲染、预排版
    * 对GPU处理的优化
        * 尽量避免使用 CALayer 的 Border、corner、shadow、mask 等技术，这样能少触发离屏渲染
        * 尽可能将多张图片合成为一张进行显示，减轻视图层级

### 10.什么是`离屏渲染`？什么情况下会触发？该如何应对？
- 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作。
- 离屏渲染出发的场景
    * 圆角 （maskToBounds并用才会触发）
    * 图层蒙版
    * 阴影
    * 光栅化
- 为什么要避免离屏渲染？
    * CPU、GPU在绘制渲染视图时做了大量的工作。离屏渲染发生在GPU层面上，会创建新的渲染缓冲区，会触发 OpenGL的多通道渲染管线，图形上下文的切换会造成额外的开销，增加 GPU 工作量。如果 CPU GPU 累计耗时16.67毫秒还没有完成，就会造成卡顿掉帧。
    * 圆角属性、蒙层遮罩都会触发离屏渲染。指定了以上属性，标记了它在新的图形上下文中，在未愈合之前，不可以用于显示的时候就出发了离屏渲染。
- 在OpenGL中，GPU有2种渲染方式
    * On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
    * Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
- 离屏渲染消耗性能的原因
    * 需要创建新的缓冲区
    * 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕
- 哪些操作会触发离屏渲染？
    * 光栅化，layer.shouldRasterize = YES
    * 遮罩，layer.mask
    * 圆角，同时设置 layer.masksToBounds = YES、layer.cornerRadius大于0
    * 考虑通过 CoreGraphics 绘制裁剪圆角，或者叫美工提供圆角图片
    * 阴影，layer.shadowXXX，如果设置了 layer.shadowPath 就不会产生离屏渲染；

### 11.如何检测离屏渲染？
- 模拟器debug-选中color Offscreen - Renderd离屏渲染的图层高亮成黄 可能存在性能问题
- 真机Instrument-选中Core Animation-勾选Color Offscreen-Rendered Yellow
- 离屏渲染的触发方式
    * 设置了以下属性时，都会触发离屏绘制：
        * layer.shouldRasterize（光栅化）
            * 光栅化概念：将图转化为一个个栅格组成的图象。
            * 光栅化特点：每个元素对应帧缓冲区中的一像素。
        * masks（遮罩）
        * shadows（阴影）
        * edge antialiasing（抗锯齿）
        * group opacity（不透明）
        * 复杂形状设置圆角等
        * 渐变
        * drawRect
- 例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。
- 如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。
- 现在摆在我们面前得有三个选择：当前屏幕渲染、离屏渲染、CPU渲染，该用哪个呢？这需要根据具体的使用场景来决定。
- 尽量使用当前屏幕渲染，鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。
- 由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作

### 12.如何高性能的画一个圆角？

```
label.layer.cornerRadius = 5
label.layer.masksToBounds = true
```
- 首先上面的方式是不可取的，会触发离屏渲染。
- 如果能够只用 cornerRadius解决问题，就不用优化。
- 如果必须设置masksToBounds，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。
- UIImageView的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。

### 13.如何优化 APP 的内存？

### 14.如何优化 APP 的电量？
- 程序的耗电主要在以下四个方面：
    * CPU 处理
    * 定位
    * 网络
    * 图像
- 优化的途径主要体现在以下几个方面：
    * 尽可能降低 CPU、GPU 的功耗。
    * 尽量少用 定时器。
    * 优化 I/O 操作。
        * 不要频繁写入小数据，而是积攒到一定数量再写入
        * 读写大量的数据可以使用 Dispatch_io ，GCD 内部已经做了优化。
        * 数据量比较大时，建议使用数据库
    * 网络方面的优化
        * 减少压缩网络数据 （XML -> JSON -> ProtoBuf），如果可能建议使用 ProtoBuf。
        * 如果请求的返回数据相同，可以使用 NSCache 进行缓存
        * 使用断点续传，避免因网络失败后要重新下载。
        * 网络不可用的时候，不尝试进行网络请求
        * 长时间的网络请求，要提供可以取消的操作
        * 采取批量传输。下载视频流的时候，尽量一大块的进行下载，广告可以一次下载多个
    * 定位层面的优化
        * 如果只是需要快速确定用户位置，最好用 CLLocationManager 的 requestLocation 方法。定位完成后，会自动让定位硬件断电
        * 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务
        * 尽量降低定位精度，比如尽量不要使用精度最高的 kCLLocationAccuracyBest
        * 需要后台定位时，尽量设置 pausesLocationUpdatesAutomatically 为 YES，如果用户不太可能移动的时候系统会自动暂停位置更新
        * 尽量不要使用 startMonitoringSignificantLocationChanges，优先考虑 startMonitoringForRegion:
    * 硬件检测优化
        * 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件

### 15.假如Controller太臃肿，如何优化？
- 将网络请求抽象到单独的类中
    * 方便在基类中处理公共逻辑；
    * 方便在基类中处理缓存逻辑，以及其它一些公共逻辑；
    * 方便做对象的持久化。
- 将界面的封装抽象到专门的类中
    * 构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。
- 构造 ViewModel
    * 借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。
- 专门构造存储类
    * 专门来处理本地数据的存取。
- 整合常量



## 调试技巧 & 软件使用
### 1.`LLDB` 调试。
### 2.断点调试- breakPoint。
### 3.`NSAssert` 的使用。
### 4.`Charles` 的使用。
    - 使用 Charles 下载过去任意版本的 App。
### 5.`Reveal` 的使用。
### 6.iOS 常见的崩溃类型有哪些？
### 7.当页面 AutoLayout 出现了问题，怎样快速调试？

## 扩展问题
### 1.无痕埋点
### 2.APM（应用程序性能监测）
### 3.Hot Patch（热修补）
### 4.崩溃的处理
### 补充：各个app之间是怎么相互切换的


## 其他问题
### 1.面向对象的三个要素
- 封装
    * 封装，就是将客观事物抽象为逻辑实体，实体的属性和功能相结合，形成一个有机的整体。并对实体的属性和功能实现进行访问控制，向信任的实体开放，对不信任的实体隐藏。，通过开放的外部接口即可访问，无需知道功能如何实现。
    * 也就是说，封装主要有以下目的：
        * 可隐藏实体实现的细节
        * 提高安全性，设定访问控制，只允许具有特定权限的使用者调用。
        * 简化编程，调用方无需知道功能是怎么实现的，即可调用。
- 继承
    * 继承，在继承机制下形成有层级的类，使得低层级的类可以延用高层级类的特征和方法。继承的实现方式有两种：实现继承、接口继承。
    * 实现继承：直接使用基类公开的属性和方法，无需额外编码。
    * 接口继承：仅使用接口公开的属性和方法名称，需要子类实现。
    * 也就是说，继承有以下目的：
        * 复用代码，减少类的冗余代码，减少开发工作量。
        * 使得类与类之间产生关系，为多态的实现打下基础。
- 多态
    * 多态，是指一个类的同名方法，在不同情况下的实现细节不同。多态机制实现不同的内部实现结构共用同一个外部接口。
    * 也就是说，多态有以下目的：
        * 一个外部接口可被多个同类使用。
        * 不同对象调用同个方法，可有不同实现。

### 2.多态？
- 多态实现的三个必要条件是：继承、重写（子类继承父类后，对继承的方法重新定义）、父类应用指向子类对象。所以，多态的实现是基于继承的。

### 补充：事务的特征
- 事务的四个特征：
    * 原子性 Atomic：事务中的所有操作要么都执行，要么都不执行
    * 一致性 Consistency：事务执行的结果从一个状态到另一个状态时保持一致。即当事务提交成功时，保存一致性的结果；当事务提交不成功时，数据库将处在不一样的状态，这种状态应该撤销
    * 隔离性 Isolation：并发执行事务时，事务之间不能互相干扰
    * 持久性 Durability：事务一旦提交成功，数据修改是永久的
- 原子性保持了事务的一致性，隔离性保证多个事务间不互相干扰。否则，即便每个事务都能确保数据的原子性和一致性，多个事务并发执行时，也可能出现不一致的状态。

### 补充：事务状态
- 活动状态：事务执行前的状态
- 部分提交状态：事务的最后一条语句执行完毕，结果已经在内存缓冲区中，还没有写入磁盘
- 失败状态：事务没有正常执行，应该回滚
- 终止状态：事务回滚并且数据库恢复到事务执行前的状态
- 提交状态：数据的更改完全写入磁盘

### 3.Java，python，OC运行效率孰高？
- OC最高，OC大于java大于python
- oc方法调用的需要经历查缓存，查方法表，查父类方法表，如果都差不多就会进行动态方法决议，如果还是不行，就执行消息转发机制，如果还是无法处理就crash。但是大部分在方法缓存的时候就能找到，苹果有函数缓存机制，当缓存生效时性能与c差不多。
- Java是静态语言静态编译的，直接执行，速度上要比Python快的很多。而Python动态类型语言，一边执行一边编译，所以要比Java慢。

### 4.Property，其中copy如何？
- 用途：
    * NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
    * lock 也经常使用 copy 关键字
- block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
- 下面做下解释：
    * copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
    * 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
    * 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

### 5.Property(nonatomatic, copy) NSMutableArray有什么问题？
- 两个问题：
    * 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变 NSArray 的对象；
    * 使用了 atomic 属性会严重影响性能 ；
- 第一个问题：
    * 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
- 第二个问题：
    * 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。
    * 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。
    * 在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。
    * 一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。
    * 因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用atomic 属性通常都不会有性能瓶颈。

### 6.Copy和MutableCopy的区别？
#### 对非集合类对象的 copy 与 mutableCopy 操作；
- 在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：
    * [immutableObject copy] // 浅复制
    * [immutableObject mutableCopy] //深复制
    * [mutableObject copy] //深复制
    * [mutableObject mutableCopy] //深复制
- 用 @property声明NSString、NSArray、NSDictionary 经常使用 copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

#### 对集合类对象的 copy 与 mutableCopy 操作。
- 集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。
- 集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。

### 7.解释下类别的原理
### 8.解释下封装，重载
### 9.OC存在多重继承吗？
### 10.了解表视图吗，解释一下复用原理
### 11.说明一下表视图的滑动卡顿的优化方法
### 12.viewDidLoad和viewDidAppear的调用时机（一次和多次的区别）；
### 13.页面间的传值方式有哪些（公有属性，公有方法和协议，block传值，通知，extern全局变量传值，NSUserDefault简单数据存储传值）；
### 14.在OC中对象方法的几种访问权限，分别是什么？
### 15.列出 #import 和 #include 的区别，另外什么时候使用@class？
### 16.`load` 和 `Initialize` 的区别?
### 17.`Designated Initializer`的规则？
### 18.`App` 编译过程有了解吗？
### 19.介绍下App启动的完成过程？
- 先加载Main函数
- 在Main函数里的 UIApplicationMain方法中，创建Application对象 创建Application的Delegate对象
- 创建主循环，代理对象开始监听事件
- 启动完毕会调用 didFinishLaunching方法，并在这个方法中创建UIWindow
- 设置UIWindow的根控制器是谁
- 如果有storyboard，会根据info.plist中找到应用程序的入口storyboard并加载箭头所指的控制器
- 显示窗口
- 其中在didFinishLaunching方法到窗口显示其中有AppDelegate,ViewController,MainView（控制器的View）,ChildView（子控件的View）的18个方法：
    * AppDelegate中的：
        * application:didFinishLaunchingWithOptions:
        * applicationDidBecomeActive:
    * ViewController中的：
        * loadView
        * viewDidLoad
        * load
        * initialize
        * viewWillAppear
        * viewWillLayoutSubviews
        * viewDidLayoutSubviews
        * viewDidAppear
    * MainView（控制器的View）中的
        * initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
        * awakeFromNib
        * layoutSubviews
        * drawRect
    * ChildView（子控件View）中的：
        * initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
        * awakeFromNib
        * layoutSubviews
        * drawRect
- 十八个方法排个顺序

```
+ (void)load; //这是应用程序启动就会调用的方法，在这个方法里写的代码最先调用

+ (void)initialize; //这个是需要用到本类时才调用，这个方法里一般写设置导航控制器的主题啊之类的，
//如果在后面的方法设置导航栏主题就晚了！（当然在上面的方法里也能写）

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;
//这个方法里面会创建UIWindow，设置根控制器并展现，
//比如某些应用程序要加载授权页面也是在这加，也可以设置观察者，监听到通知切换根控制器

ChildView - (instancetype)initWithCoder:(NSCoder *)aDecoder;
//这里反正我是万万没想到，childView的initwithcoder会在MainView的方法之前调用，
//父的都还没出来，就先整子控件？ 有了解比较透彻的博友恳请告诉我谢谢。

MainView - (instancetype)initWithCoder:(NSCoder *)aDecoder;
// 就是关于应用程序的数据存储后的解档操作。

MainView - (void)awakeFromNib;
//在这个方法里设置view的背景等一系列普通操作，不要写关于frame的还不准，
//在使用IB的时候才会涉及到此方法的使用，当.nib文件被加载的时候，
//会发送一个awakeFromNib的消息到.nib文件中的每个对象，
//每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。

ChildView - (void)awakeFromNib
//子控件也有本方法，重写父类的方法。基本用法同上

- (void)loadView; 
//创建视图的层次结构，这里需要注意，
//在没有创建控制器的view的情况下不能直接写 self.view 因为self.view的底层是：
    if（_view == nil）{
　   　_view = [self loadView]
    }
//所以这么写会直接造成死循环。
//如果重写这个loadView方法里面什么都不写，会显示黑屏

- (void)viewDidLoad;
//卧槽，这个方法是用的最多的方法，但是在之后的开发中就会发现越来越不靠谱，
//很多东西都还没加载完毕，各种取值都不准确，很少在这里面写东西了。 
//这里只是把视图元件加载完成

- (void)viewWillAppear:(BOOL)animated;
//视图将要出现，这个方法用的非常多，比如如果要设置导航栏的setNavigationBarHiden:animate: 
//就必须要在这里写，才能完美契合，不卡跳。 还有很多比如监听屏幕旋转啦，
 
//viewWillTransitionToSize:可能要在本方法里再调一次，
//或者就是新到这个界面要reloadData或是自动下拉刷新等 都是写在本方法里

- (void)viewWillLayoutSubviews;
//视图将要布局子视图，苹果建议的设置界面布局属性的方法，
//这个方法和viewWillAppear里，系统的底层都是没有写任何代码的，也就是说这里面不写super 也是可以的

MainView  - (void)layoutSubviews;
//在这个方法里一般设置子控件的frame，因为这里相当于是布局基本完成了，
//设置时取到的frame或者是self.bounds才最准，如果在awakeFromeNib里写会不准确 。
//还有这里要切记千万不能把super layoutSubviews忘了，可能最后都很难找到这个bug

- (void)viewDidLayoutSubviews;
//这个方法我也是玩玩没想到，控制器的view的子控件还没有布局好呢，怎么这个控制器就已经说布局全部完成了？
//那后边的布局就不等了？ 有独到见解的也恳请你告诉我，这其中苹果的意思到底是什么。

ChildView - (void)layoutSubviews;
//控制器的子控件里的子控件的布局就在这里写了。

MainView - (void)drawRect:(CGRect)rect;
//因为默认所有额UI控件都是画上去的，在这一步就是把所有的东西画上去，
//有时候需要用到Quartz2D的知识的时候都是在这个方法里话，但也是要注意别忘了写super，
//不然系统原本的东西就都画不上来了，这里要建议尽可能使用贝塞尔路径画图形，
//因为系统默认的那个上下文画法有时可能会内存泄露。drawRect方法只能在加载时调用一次，
//如果后面还需要调用，比如下载进度的圆弧，需要一直刷帧，
//就要使用setNeedsDisplay来定时多次调用本方法

ChildView - (void)drawRect:(CGRect)rect;
//view的子控件内部的画图方法，有时可以自己自定义label 中间带个删除线的（用来写打折前的原价） 就是在这里画根线 。

- (void)viewDidAppear:(BOOL)animated;
//把上面的画图都画完了，这里就会显示，视图完全加载完成。
//在这里的操作可能就是设置页面的一些动画,或者是设置tableView，collectionView，
//QQ聊天页面啥的滚动到底部scrollToIndexPath之类的代码操作

- (void)applicationDidBecomeActive:(UIApplication *)application;
//最后这是AppDelegate的应用程序获取焦点方法，真正到了这里，才是所有东西全部加载完毕，应用程序整装待发保持最佳状态等待用户操作。
//这个方法中一般会写关于弹出键盘的方法，比如有的用户登录界面为了更好的用户体验，
//就让你在刚打开程序来到登录界面的时候，光标的焦点就自动在账号的文本框里闪烁，
//也就是设置账号文本框为第一响应者。键盘在页面加载完毕后从下方弹出，这种代码一般就在本方法写。

```

### 20.`JS` 和 `Native` 交互。
### 21.`LoadView`方法了解吗？
### 22.说一下对 `APNS` 的认识？
### 23：简述Xcode7和Xcode8的异同
### 24：描述iOS 10的一些新特性（包括系统和开发环境）
### 25.App 上有一数据列表，客户端和服务端均没有任何缓存，当服务端有数据更新时，该列表在 wifi 下能获取到数据，在 4G 下刷新不到，但是在 4g 环境下其他 App 都可以正常打开，分析其产生的原因？
### 26.是否了解链式编程？
### 27.dSYM你是如何分析的
- 我们在iOS开发过程中一定会跟符号表（dSYM文件）打交道，它是我们不可或缺的定位bug的小帮手。我们都知道，每次编译都会生成一个dSYM文件，当我们的应用程序出现奔溃时，dSYM文件能帮我们定位到应用程序的代码奔溃到哪里了。
- 符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示：

```
<起始地址> <结束地址> <函数> [<文件名:行号>]
```
- dSYM是如何分析的
    * 方法1 使用XCode，这种方法可能是最容易的方法了。
        * 要使用Xcode符号化 crash log，你需要下面所列的3个文件：crash报告（.crash文件），符号文件(.dsymb文件)，应用程序文件(appName.app文件，把IPA文件后缀改为zip，然后解压，Payload目录下的appName.app文件),这里的appName是你的应用程序的名称。把这3个文件放到同一个目录下，打开Xcode的Window菜单下的organizer，然后点击Devices tab，然后选中左边的Device Logs。然后把.crash文件拖到Device Logs或者选择下面的import导入.crash文件。这样你就可以看到crash的详细log了。
        * 方法2 使用命令行工具symbolicatecrash，有时候Xcode不能够很好的符号化crash文件。我们这里介绍如何通过symbolicatecrash来手动符号化crash log。在处理之前，请依然将“.app“, “.dSYM”和 ".crash"文件放到同一个目录下。现在打开终端(Terminal)然后输入如下的命令：export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer，然后输入命令：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash appName.crash appName.app > appName.log；现在，符号化的crash log就保存在appName.log中了。
        * 方法3 使用命令行工具atos，如果你有多个“.ipa”文件，多个".dSYMB"文件，你并不太确定到底“dSYMB”文件对应哪个".ipa"文件，那么，这个方法就非常适合你。特别当你的应用发布到多个渠道的时候，你需要对不同渠道的crash文件，写一个自动化的分析脚本的时候，这个方法就极其有用。
