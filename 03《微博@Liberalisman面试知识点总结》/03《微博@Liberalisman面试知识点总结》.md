# iOSInterviewQuestion
## 微博@Liberalisman面试知识点总结（附答案）

- 03《微博@Liberalisman面试知识点总结》，面试题来源是微博[@Liberalisman](https://weibo.com/1743643682/)的面试题知识点总结；
- 如有纰漏，请向微博[@爱吃兔兔的胡萝卜吖](https://weibo.com/6447187962/)反馈。

### 推荐书目
* 1.《Effective Objective-C 2.0》
* 2.《Objective-C 高级编程》
* 3.《程序员的自我修养》
* 4.《图解HTTP》
* 5.《高性能iOS应用开发》
* 6.《算法图解》
* 7.《剑指Offer》）

# 索引
## 数据结构及算法

### 数据结构
- 1.[数组](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1数组)
- 2.[字符串](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2字符串)
- 3.[链表](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3链表)
- 4.[树](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4树)
    * 红黑树
    * 二叉搜索树
- 5.[栈](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5栈)
- 6.[队列](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6队列)
- 7.[哈希表（有哪些功能是通过哈希表实现的）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7哈希表有哪些功能是通过哈希表实现的)

### 算法
#### 基本概念
- [时间复杂度](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#时间复杂度)
- [空间复杂度](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#空间复杂度)

#### 常见的摘要算法
- [HEX编码](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#hex编码)
- [Base64](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#base64)
- [MD5](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#md5)
- [SHA1](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#sha1)
- [SHA256](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#sha256)
- [MAC算法](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#mac算法)

#### 常见对称加密算法
- [AES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#aes)
- [DES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#des)
- [3DES](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3des)
- [Blowfish](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#--blowfish)

#### 常见的排序算法
- [快速排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#快速排序)
- [堆排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#堆排序)
- [冒泡排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#冒泡排序)
- [选择排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#选择排序)
- [希尔排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#希尔排序)
- [归并排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#归并排序/)

#### 常见的字符编码方法
- [ASCII](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#ascii)
- [ISO-8859-1](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#iso-8859-1)
- [GB2312](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#gb2312)
- [GBK](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#gbk)
- [UTF-8](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#utf-8)
- [UTF-16](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#utf-16)
- [Unicode](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#unicode)

[推荐一个很好的算法总结](https://github.com/CyC2018/Interview-Notebook)

#### 常考算法题
- 1.[字符串反转](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1字符串反转) 
- 2.[链表反转](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2链表反转)
- 3.[有序数组合并](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3有序数组合并)
- 4.[查找第一个只出现一次的字符](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4查找第一个只出现一次的字符)
- 5.[查找两个子视图的共同父视图](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5查找两个子视图的共同父视图)
- 6.[无序数组中的中位数](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6无序数组中的中位数)
- 7.[两数之和为特定值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7两数之和为特定值)
- 8.[求出数组中连续数字的和值](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8求出数组中连续数字的和值)
- 9.[白鼠与毒酒的算法问题](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9白鼠与毒酒的算法问题)
- 10.[在一个数组中找出前四个最大的数字。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10在一个数组中找出前四个最大的数字)
- 11.[假如有 10亿 条数据，每条数据的大小在 10k-100k 之间，我们有一台内存为 4G 的电脑，如何算出播放次数最多的一条微博？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11假如有-10亿-条数据每条数据的大小在-10k-100k-之间我们有一台内存为-4g-的电脑如何算出播放次数最多的一条微博)
- 12.[如何打印一个矩阵？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12如何打印一个矩阵)
- 13.[如何验证一个 IP 地址的有效性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12如何打印一个矩阵)
- 14.[栈中储存着一组无序的数字，不用遍历的方式，如何找出最小值？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14栈中储存着一组无序的数字不用遍历的方式如何找出最小值)
- 15.[二维数组查找一个值。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15二维数组查找一个值)
- [补充：插入排序](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充插入排序)
- [补充：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充给定一个非空整数数组除了某个元素只出现一次以外其余每个元素均出现两次找出那个只出现了一次的元素)
- [补充：100层楼，扔两个鸡蛋，寻找使鸡蛋摔碎的楼层最快要扔多少次？（Google经典的面试题，有一个100层的楼，你手里现在有两个一模一样的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置？）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充100层楼扔两个鸡蛋寻找使鸡蛋摔碎的楼层最快要扔多少次google经典的面试题有一个100层的楼你手里现在有两个一模一样的鸡蛋它们有可能都在一楼就摔碎也可能从一百层楼摔下来没事要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置)
- [补充：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。或者是问：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充数组中有一个数字出现的次数超过数组长度的一半请找出这个数字例如输入一个长度为9的数组123222542由于数字2在数组中出现了5次超过数组长度的一半因此输出2如果不存在则输出0或者是问给定一个大小为-n-的数组找到其中的众数众数是指在数组中出现次数大于--n2--的元素)

## iOS 内存管理
- 1.[讲一下 `iOS` 内存管理的理解？(三种方案的结合)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1讲一下-ios-内存管理的理解三种方案的结合)
- 2.[使用自动引用计（ARC）数应该遵循的原则?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2使用自动引用计arc数应该遵循的原则)
- 3.[ARC 自动内存管理的原则?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3arc-自动内存管理的原则)
- 4.[访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4访问-__weak-修饰的变量是否已经被注册在了-autoreleasepool-中为什么)
- 5.[ARC 的 retainCount 怎么存储的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5arc-的-retaincount-怎么存储的)
- 6.[简要说一下 @autoreleasePool 的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6简要说一下-autoreleasepool-的数据结构)
- 7.[__weak 和 _Unsafe_Unretain 的区别](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7__weak-和-_unsafe_unretain-的区别)？
- 8.[为什么已经有了 ARC ,但还是需要 @AutoreleasePool 的存在？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8为什么已经有了-arc-但还是需要-autoreleasepool-的存在)
- 9.[__weak 属性修饰的变量，如何实现在变量没有强引用后自动置为 nil](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9__weak-属性修饰的变量如何实现在变量没有强引用后自动置为-nil)
- 10.[说一下对 retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10说一下对-retaincopyassignweak_unsafe_unretain-关键字的理解)
- [补充：简述下列属性的作用：readwrite、readonly、assign、retain、copy、nonatomic、weak、strong](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充简述下列属性的作用readwritereadonlyassignretaincopynonatomicweakstrong)
- [补充：automic的实现机制；](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充automic的实现机制)
- 11.[ARC 在编译时做了哪些工作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11arc-在编译时做了哪些工作)
- 12.[ARC 在运行时做了哪些工作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12arc-在运行时做了哪些工作)
- 13.[函数返回一个对象时，会对对象 autorelease 么？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13函数返回一个对象时会对对象-autorelease-么为什么)
- 14.[说一下什么是 悬垂指针？什么是 野指针?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14说一下什么是-悬垂指针什么是-野指针)
- 15.[内存管理默认的关键字是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15内存管理默认的关键字是什么)
- 16.[内存中的5大区分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16内存中的5大区分别是什么)
- [补充：iOS程序内存的每个分区怎么存储（举例说明）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16内存中的5大区分别是什么)
- [补充：block一般存在哪里（分ARC和MRC）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充block一般存在哪里分arc和mrc)
- [补充：代码区存储的是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充代码区存储的是什么)
- 17.[是否了解 深拷贝 和 浅拷贝 的概念，集合类深拷贝如何实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17是否了解-深拷贝-和-浅拷贝-的概念集合类深拷贝如何实现)
- 18.[BAD_ACCESS 在什么情况下出现?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18bad_access-在什么情况下出现)
- 19.[讲一下 @dynamic 关键字？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19讲一下-dynamic-关键字)
- 20.[@autoreleasrPool 的释放时机？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20autoreleasrpool-的释放时机)
- 21.[retain、release 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21retainrelease-的实现机制)
- [补充：在OC里 alloc 和 retain 语义相反的方法是？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充在oc里-alloc-和-retain-语义相反的方法是)
- [补充：realease作用是什么和 autorelease 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充realease作用是什么和-autorelease-有什么区别)
- 22.[能不能简述一下 Dealloc 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22能不能简述一下-dealloc-的实现机制)
- 23.[在 MRC 下如何重写属性的 Setter 和 Getter?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23在-mrc-下如何重写属性的-setter-和-getter)
- 24.[在 Obj-C 中，如何检测内存泄漏？你知道哪些方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24在-obj-c-中如何检测内存泄漏你知道哪些方式)

## Runtime
- 1.[实例对象的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1实例对象的数据结构)
- 2.[类对象的数据结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2类对象的数据结构)
- 3.[元类对象的数据结构?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3元类对象的数据结构)
- 4.[Obj-C 对象、类的本质是通过什么数据结构实现的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4obj-c-对象类的本质是通过什么数据结构实现的)
- 5.[Obj-C 中的类信息存放在哪里？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5obj-c-中的类信息存放在哪里)
- 6.[一个 NSObject 对象占用多少内存空间？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6一个-nsobject-对象占用多少内存空间)
- 7.[说一下对 class_rw_t 的理解？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7说一下对-class_rw_t-的理解)
- 8.[说一下对 class_ro_t 的理解？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8说一下对-class_ro_t-的理解)
- 9.[Category 的实现原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9category-的实现原理)
- 10.[如何给 Category 添加属性？关联对象以什么形式进行存储？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10如何给-category-添加属性关联对象以什么形式进行存储)
- 11.[Category 有哪些用途？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11category-有哪些用途)
- [补充：Category的优缺点](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充category的优缺点)
- 12.[Category 和 Extension 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12category-和-extension-有什么区别)
- 13.[Category 可不可以添加实例对象？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13category-可不可以添加实例对象为什么)
- 14.[Category 在编译过后，是在什么时机与原有的类合并到一起的？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14category-在编译过后是在什么时机与原有的类合并到一起的)
- 15.[说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15说一下-method-swizzling-说一下在实际开发中你在什么场景下使用过)
- 16.[如何实现动态添加方法和属性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16如何实现动态添加方法和属性)
- 17.[说一下对 isa 指针的理解， 对象的isa 指针指向哪里？isa 指针有哪两种类型？（注意区分不同对象）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17说一下对-isa-指针的理解-对象的isa-指针指向哪里isa-指针有哪两种类型注意区分不同对象)
- 18.[说一下 Runtime 消息解析。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18说一下-runtime-消息解析)
- 19.[说一下 Runtime 消息转发。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#19说一下-runtime-消息转发)
- 20.[如何运用 Runtime 字典转模型？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#20如何运用-runtime-字典转模型)
- 21.[如何运用 Runtime 进行模型的归解档？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#21如何运用-runtime-进行模型的归解档)
- 22.[在 Obj-C 中为什么叫发消息而不叫函数调用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#22在-obj-c-中为什么叫发消息而不叫函数调用)
- 23.[说一下对 runtime 的理解。（主要讲一下消息机制，是对上述的总结）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#23说一下对-runtime-的理解主要讲一下消息机制是对上述的总结)
- 24.[说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#24说一下-runtime-的方法缓存存储的形式数据结构以及查找的过程)
- 25.[是否了解 Type Encoding?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#25是否了解-type-encoding)
- 26.[Objective-C 如何实现多重继承？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#26objective-c-如何实现多重继承)
- [补充：runtime如何通过selector找到对应的IMP地址？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充runtime如何通过selector找到对应的imp地址)
- [补充：使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充使用runtime-associate方法关联的对象需要在主对象dealloc的时候释放么)
- [补充：runtime如何实现weak变量的自动置nil？知道SideTable吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充runtime如何实现weak变量的自动置nil知道sidetable吗)

## Runloop
- [补充：RunLoop概念](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充runloop概念)
- [补充：RunLoop的数据结构](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充runloop的数据结构)
- 1.[Runloop 和线程的关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1runloop-和线程的关系)
- 2.[讲一下 Runloop 的 Mode?(越详细越好)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2讲一下-runloop-的-mode越详细越好)
- 3.[讲一下 Observer ？（Mode中的重点）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3讲一下-observer-mode中的重点)
- 4.[讲一下 Runloop 的内部实现逻辑？（运行过程）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4讲一下-runloop-的内部实现逻辑运行过程)
- 5.[你所知的哪些三方框架使用了 Runloop?（AFNetworking、Texture 等）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5你所知的哪些三方框架使用了-runloopafnetworkingtexture-等)
- 6.[autoreleasePool 在何时被释放？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6autoreleasepool-在何时被释放)
- 7.[解释一下 事件响应 的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7解释一下-事件响应-的过程)
- 8.[解释一下 手势识别 的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8解释一下-手势识别-的过程)
- 9.[解释一下 GCD 在 Runloop 中的使用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9解释一下-gcd-在-runloop-中的使用)
- 10.[解释一下 NSTimer，以及 NSTimer 的循环引用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10解释一下-nstimer以及-nstimer-的循环引用)
- [补充：NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充nstimer准吗谈谈你的看法如果不准该怎样实现一个精确的nstimer)
- 11.[AFNetworking 中如何运用 Runloop?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11afnetworking-中如何运用-runloop)
- 12.[PerformSelector 的实现原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12performselector-的实现原理)
- 13.[利用 runloop 解释一下页面的渲染的过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#13利用-runloop-解释一下页面的渲染的过程)
- 14.[如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#14如何使用-runloop-实现一个常驻线程这种线程一般有什么作用)
- 15.[为什么 NSTimer 有时候不好使？（不同类型的Mode）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#15为什么-nstimer-有时候不好使不同类型的mode)
- [补充：滑动tableView时，定时器还会生效吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充滑动tableview时定时器还会生效吗)
- 16.[PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#16performselectorafterdelay这个方法在子线程中是否起作用为什么怎么解决)
- 17.[什么是异步绘制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#17什么是异步绘制)
- 18.[如何检测 App 运行过程中是否卡顿？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#18如何检测-app-运行过程中是否卡顿)

## UIKit
- 1.[UIView 和 CALayer 是什么关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1uiview-和-calayer-是什么关系)
- 2.[Bounds 和 Frame 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#2bounds-和-frame-的区别)
- 3.[TableViewCell 如何根据 UILabel 内容长度自动调整高度?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#3tableviewcell-如何根据-uilabel-内容长度自动调整高度)
- 4.[LoadView方法了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#4loadview方法了解吗)
- 5.[UIButton 的父类是什么？UILabel 的父类又是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#5uibutton-的父类是什么uilabel-的父类又是什么)
- 6.[实现一个控件，可以浮在任意界面的上层并支持拖动？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#6实现一个控件可以浮在任意界面的上层并支持拖动)
- 7.[说一下控制器 View 的生命周期，一旦收到内存警告会如何处理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#7说一下控制器-view-的生命周期一旦收到内存警告会如何处理)
- 8.[如何暂停一个 UIView 中正在播放的动画？暂停后如何恢复？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#8如何暂停一个-uiview-中正在播放的动画暂停后如何恢复)
- 9.[说一下 UIView 的生命周期？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#9说一下-uiview-的生命周期)
- 10.[UIViewController 的生命周期？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#10uiviewcontroller-的生命周期)
- 11.[如何以通用的方法找到当前显示的ViewController?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#11如何以通用的方法找到当前显示的viewcontroller)
- 12.[setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#12setneedsdisplay-和-layoutifneeded-两者是什么关系)
- [补充：多个类型的cell如何优雅加载？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#补充多个类型的cell如何优雅加载)

## Foundation
- 1.[`Bounds` 和 `Frame` 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博@Liberalisman面试知识点总结》/03《微博@Liberalisman面试知识点总结》.md#1bounds-和-frame-的区别)
- 2.[`nil`、`NIL`、`NSNULL` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2nilnilnsnull-有什么区别)
- 3.[如何实现一个线程安全的 `NSMutableArray`?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3如何实现一个线程安全的-nsmutablearray)
- 4.[如何定义一台 iOS 设备的唯一性?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4如何定义一台-ios-设备的唯一性)
- 5.[`atomic` 修饰的属性是绝对安全的吗？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5atomic-修饰的属性是绝对安全的吗为什么)
- 6.[实现 `isEqual` 和 `hash` 方法时要注意什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6实现-isequal-和-hash-方法时要注意什么)
- 7.[`id` 和 `instanceType` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7id-和-instancetype-有什么区别)
- 8.[简述事件传递、事件响应机制。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8简述事件传递事件响应机制)
- 9.[说一下对 `Super` 关键字的理解。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9说一下对-super-关键字的理解)
- 10.[了解 逆变 和 协变 吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10了解-逆变-和-协变-吗)
- 11.[`@synthesize` 和 `@dynamic` 分别有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11synthesize-和-dynamic-分别有什么作用)
- 12.[Obj-C 中的反射机制了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12obj-c-中的反射机制了解吗)
- 13.[`typeof` 和 `__typeof`，`typeof` 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13typeof-和-__typeoftypeof-的区别)
- 14.[如何判断一个文件在沙盒中是否存在？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14如何判断一个文件在沙盒中是否存在)
- 15.[头文件导入的方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15头文件导入的方式)
- 16.[如何将 Obj-C 代码改变为 C++/C 的代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16如何将-obj-c-代码改变为-cc-的代码)
- 17.[知不知道在哪里下载苹果的源代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#17知不知道在哪里下载苹果的源代码)
- 18.[objc_getClass()、object_getClass()、Class 这三个方法用来获取类对象有什么不同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#18objc_getclassobject_getclassclass-这三个方法用来获取类对象有什么不同)


## 网络
- 1.[NSUrlConnect相关知识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1nsurlconnect相关知识)
- 2.[NSUrlSession相关知识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2nsurlsession相关知识)
- 补充：简要说一下Https；
- 补充：简要说一下http；
- 3.[Http 和 Https 的区别？为什么更加安全？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3http-和-https-的区别为什么更加安全)
- 4.[Http的请求方式有哪些？Http 有什么特性？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4http的请求方式有哪些http-有什么特性)
- 5.[解释一下 三次握手 和 四次挥手？解释一下为什么是三次握手 又为什么是 四次挥手？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5解释一下-三次握手-和-四次挥手解释一下为什么是三次握手-又为什么是-四次挥手)
- 6.[GET 和 POST 请求的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6get-和-post-请求的区别)
- 7.[HTTP 请求报文 和 响应报文的结构？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7http-请求报文-和-响应报文的结构)
- 8.[什么是 Mimetype ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8什么是-mimetype-)
- 9.[数据传输的加密过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9数据传输的加密过程)
- 10.[说一下 TCP/IP 五层模型的协议?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10说一下-tcpip-五层模型的协议)
- 11.[说一下 OSI 七层模型的协议?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11说一下-osi-七层模型的协议)
- 12.[大文件下载 的功能有什么注意点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12大文件下载-的功能有什么注意点)
- 13.[断点续传 功能该怎么实现？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13断点续传-功能该怎么实现)
- 14.[封装一个网络框架有哪些注意点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14封装一个网络框架有哪些注意点)
- 15.[Wireshark、Charles、Paw 等工具会使用吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15wiresharkcharlespaw-等工具会使用吗)
- 16.[NSUrlProtocol用过吗？用在什么地方了？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16nsurlprotocol用过吗用在什么地方了)
- 17.[如何在测试过程中 MOCK 各种网络环境？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#17如何在测试过程中-mock-各种网络环境)
- 18.[DNS 的解析过程？网络的 DNS 优化。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#18dns-的解析过程网络的-dns-优化)
- 补充：DNS劫持和预防；
- 19.[Post请求体有哪些格式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#19post请求体有哪些格式)
- 20.[网络请求的状态码都大致代表什么意思？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#20网络请求的状态码都大致代表什么意思)
- 21.[抓包软件 Charles 的原理是什么？说一下中间人攻击的过程。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#21抓包软件-charles-的原理是什么说一下中间人攻击的过程)
- 22.[如何判断一个请求是否结束？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#22如何判断一个请求是否结束)
- 23.[SSL 传输协议？说一下 SSL 验证过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#23ssl-传输协议说一下-ssl-验证过程)
- 24.[解释一下 Http 的持久连接？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#24解释一下-http-的持久连接)
- 25.[说一下传输控制协议 - TCP ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#25说一下传输控制协议---tcp-)
- 26.[说一下用户数据报协议 - UDP ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#26说一下用户数据报协议---udp-)
- 27.[谈一谈网络中的 session 和 cookie?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#27谈一谈网络中的-session-和-cookie)
- 28.[发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#28发送网络请求的时候如果带宽-1m如何针对某些请求限制其流量)
[补充：使用异步请求的方式抓取一个网站的内容，请考虑超时，状态码的异常情况（请用原生API或者Socket/Cocoa Socket）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充使用异步请求的方式抓取一个网站的内容请考虑超时状态码的异常情况请用原生api或者socketcocoa-socket)
- [补充：在网络请求中，如何处理网络网速慢，网络中断、网络抖动等等网络问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充在网络请求中如何处理网络网速慢网络中断网络抖动等等网络问题)
- [补充：https的缓存问题。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充https的缓存问题)
- [补充：你平时怎么解决网络请求的依赖关系：当一个接口的请求需要依赖于另一个网络请求的结果](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充你平时怎么解决网络请求的依赖关系当一个接口的请求需要依赖于另一个网络请求的结果)
- 补充：http的header和body
- 

## 多线程
- 补充：进程和线程、多进程和多线程
- [补充：谈谈你对多线程开发的理解(多线程的好处，多线程的作用)？ios中有几种实现多线程的方法？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充谈谈你对多线程开发的理解多线程的好处多线程的作用ios中有几种实现多线程的方法)
- 1.[NSThread相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1nsthread相关知识)
- 2.[GCD 相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2gcd-相关知识)
- 3.[NSOperation 和 NSOperationQueue相关知识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3nsoperation-和-nsoperationqueue相关知识)
- [补充：NSOperation与GCD的关系？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充nsoperation与gcd的关系)
- 4.[如何实现线性编程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4如何实现线性编程)
- 5.[说一下 GCD 并发队列实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5说一下-gcd-并发队列实现机制)
- [补充：GCD的并行队列一定会开辟新的线程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充gcd的并行队列一定会开辟新的线程)
- 6.[NSLock？是否会出现死锁？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6nslock是否会出现死锁)
- 7.[NSContion](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7nscontion)
- 8.[条件锁 - NSContionLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8条件锁---nscontionlock)
- 9.[递归锁 - NSRecursiveLock](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9递归锁---nsrecursivelock)
- 10.[同步锁 - Synchronized(self) {// code}](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10同步锁---synchronizedself--code)
- 11.[信号量 - dispatch_semaphore。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11信号量---dispatch_semaphore)
- 12.[自旋锁 - OSSpinLock 。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12自旋锁---osspinlock-)
- 13.[多功能锁 - pthread_mutex](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13多功能锁---pthread_mutex)
- 14.[分步锁 - NSDistributedLock。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14分步锁---nsdistributedlock)
- 15.[如何确保线程安全？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15如何确保线程安全)
- 16.[NSMutableArray、和 NSMutableDictionary是线程安全的吗？NSCache呢？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16nsmutablearray和-nsmutabledictionary是线程安全的吗nscache呢)
- 17.[多线程的 并行 和 并发 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#17多线程的-并行-和-并发-有什么区别)
- 18.[多线程有哪些优缺点？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#18多线程有哪些优缺点)
- 19.[如何自定义 NSOperation ?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#19如何自定义-nsoperation-)
- 20.[GCD 与 NSOperationQueue 有哪些异同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#20gcd-与-nsoperationqueue-有哪些异同)
- [补充：你们项目中为什么多线程用GCD而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充你们项目中为什么多线程用gcd而不用nsoperation呢-你有没有发现国外的大牛他们多线程都是用nsoperation-你能告诉我他们这样做的理由吗)
- 21.[解释一下多线程中的死锁？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#21解释一下多线程中的死锁)
- [补充：列举几种进程的同步机制、进程的通信途径、死锁及死锁的处理方法。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充列举几种进程的同步机制进程的通信途径死锁及死锁的处理方法)
- 22.[子线程是否会出现死锁？说一下场景？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#22子线程是否会出现死锁说一下场景)
- 23.[多线程技术在使用过程中有哪些注意事项？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#23多线程技术在使用过程中有哪些注意事项)
- [补充：并行和并发的区别？串行/并行、同步异步的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充并行和并发的区别串行并行同步异步的区别)
- [补充：请说明同步请求与异步请求的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充请说明同步请求与异步请求的区别)
- [补充：默认最大并发？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充默认最大并发)
- [补充：dispatch_once如何实现一次性代码？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充dispatch_once如何实现一次性代码)
- [补充：如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充如何用gcd同步若干个异步调用如根据若干个url异步加载多张图片然后在都下载完成后合成一张整图)
- [补充：线程与进程的区别和联系?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充线程与进程的区别和联系)
- 补充：互斥锁和自旋锁区别及应用场景；
- [补充：iOS线程间怎么通信？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充ios线程间怎么通信)
- [补充：Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充object-c中创建线程的方法是什么如果在主线程中执行代码方法是什么如果想延时执行代码方法又是什么)
- [补充：请说明同步请求与异步请求的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充请说明同步请求与异步请求的区别)


## 项目架构
- 1.[什么是 MVC?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1什么是-mvc)
- 2.[什么是 MVVM?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2什么是-mvvm)
- 3.[什么是 MVP?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3什么是-mvp)
- 4.[什么是 CDD?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4什么是-cdd)
- 5.[项目的组件化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5项目的组件化)
    - 1.[说一下你了解的项目组件化方案？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1说一下你了解的项目组件化方案)
    - 2.[什么样的团队及项目适合采用组件化的形式进行开发？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2什么样的团队及项目适合采用组件化的形式进行开发)
    - 3.[组件之间的通信方式。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3组件之间的通信方式)
    - 4.[各组件之间的解耦。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4各组件之间的解耦)
- 6.[还了解哪些项目架构？你之前所在公司的架构师什么样的，简单说一下？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6还了解哪些项目架构你之前所在公司的架构师什么样的简单说一下)
- 7.[从宏观上来讲 App 可以分为哪些层？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7从宏观上来讲-app-可以分为哪些层)
- 8.[多工程连编之静态库](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8多工程连编之静态库)


## 消息传递的方式
- 1.[说一下 NSNotification 的实现机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1说一下-nsnotification-的实现机制)
- 2.[说一下 NSNotification 的特点。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2说一下-nsnotification-的特点)
- 3.[简述 KVO 的实现机制。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3简述-kvo-的实现机制)
- 4.[KVO 在使用过程中有哪些注意点？有没有使用过其他优秀的 KVO 三方替代框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4kvo-在使用过程中有哪些注意点有没有使用过其他优秀的-kvo-三方替代框架)
- 5.[简述 KVO 的注册依赖键是什么？](hhttps://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5简述-kvo-的注册依赖键是什么)
- 6.[如何做到 KVO 手动通知？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6如何做到-kvo-手动通知)
- 7.[在什么情况下会触发 KVO?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7在什么情况下会触发-kvo)
- 8.[给实例变量赋值时，是否会触发 KVO?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8给实例变量赋值时是否会触发-kvo)
- 9.[Delegate通常用什么关键字修饰？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9delegate通常用什么关键字修饰为什么)
- 10[通知 和 代理 有什么区别？各自适应的场景？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10通知-和-代理-有什么区别各自适应的场景)
- 11.[__block 的解释以及在 ARC 和 MRC 下有什么不同？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11__block-的解释以及在-arc-和-mrc-下有什么不同)
- 12.[Block 的内存管理。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12block-的内存管理)
- 13.[Block 自动截取变量。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13block-自动截取变量)
- 14.[Block 处理循环引用。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14block-处理循环引用)
- 15.[Block 有几种类型？分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15block-有几种类型分别是什么)
- 16.[说一下什么是Block?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16说一下什么是block)
- 17.[Dispatch_block_t这个有没有用过？解释一下？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#17dispatch_block_t这个有没有用过解释一下)
- [补充：Block 用什么修饰？copy，assign，strong有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充block-用什么修饰copyassignstrong有什么区别)
- [补充：Block 后面携带参数的时候，有数量限制吗？为什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充block-后面携带参数的时候有数量限制吗为什么)
- [补充：消息通知有几种？如何判断是否发送通知。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充消息通知有几种如何判断是否发送通知)



## 数据存储
- 1.Sqlite3
    - 1.[简单说一下 Sqlite3](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1简单说一下-sqlite3)
    - 2.[Sqlite3 常用的执行语句](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2sqlite3-常用的执行语句)
    - 3.[Sqlite3 在不同版本的APP，数据库结构变化了，如何处理?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3sqlite3-在不同版本的app数据库结构变化了如何处理)
- 2.[FMDB (Sqlite3 的封装)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2fmdb-sqlite3-的封装)
- 3.[Realm](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3realm)
- 4.[NSKeyArchieve](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4nskeyarchieve)
- 5.[Preperfence](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5preperfence)
- 6.[Plist](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6plist)
- 7.[CoreDate](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7coredate)
- 8.[Keychain](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8keychain)
- 9.[UIPasteBoard(感谢 lilingyu0620 同学提醒)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9uipasteboard感谢-lilingyu0620-同学提醒)
- 10.[FoundationDB](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10foundationdb)
- 11.[LRU(最少最近使用)缓存](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11lru最少最近使用缓存)


## iOS设计模式
- 1.[编程中的六大设计原则？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1编程中的六大设计原则)
- 2.[如何设计一个图片缓存框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2如何设计一个图片缓存框架)
- 3.[如何设计一个时长统计框架？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3如何设计一个时长统计框架)
- 4.[如何实现 App 换肤（夜间模式）？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4如何实现-app-换肤夜间模式)
- 5.[外观模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5外观模式)
- 6.[中介者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6中介者模式)
- 7.[访问者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7访问者模式)
- 8.[装饰模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8装饰模式)
- 9.[观察者模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9观察者模式)
- 10.[责任链模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10责任链模式)
- 11.[命令模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11命令模式)
- 12.[适配器模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12适配器模式)
- 13.[桥接模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13桥接模式)
- 14.[代理委托模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14代理委托模式)
- 15.[单例模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15单例模式)
- [补充：单例弊端？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充单例弊端)
- 16.[类工厂模式](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#16类工厂模式)


## WebView
- 1.[说一下 JS 和 OC 互相调用的几种方式？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1说一下-js-和-oc-互相调用的几种方式)
- 2.[在使用 WKWedView 时遇到过哪些问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2在使用-wkwedview-时遇到过哪些问题)
- 3.[是否了解 UIWebView 的插件化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3是否了解-uiwebview-的插件化)
- 4.[是否了解 SFSafariViewController ？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4是否了解-sfsafariviewcontroller-)


## 音频处理

## 视频处理

## 图像处理
- 1.[图像的压缩、解压。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1图像的压缩解压)
- 2.[一张物理体积20KB、分辨率为 200 * 300 的图片，在内存中占用多大的空间？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2一张物理体积20kb分辨率为-200--300-的图片在内存中占用多大的空间)

## iOS 动画
- 1.[简要说一下常用的动画库。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1简要说一下常用的动画库)
- 2.[请说一下对 CALayer 的认识。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2请说一下对-calayer-的认识)
- 3.[解释一下 CALayer.contents 属性。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3解释一下-calayercontents-属性)
- 4.[在 iOS 中，动画有哪几种类型？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4在-ios-中动画有哪几种类型)
- 5.[隐式动画](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5隐式动画)
- 6.[显式动画](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6显式动画)

## 蓝牙

## ARKit

## Core ML

## 代码管理、持续集成、项目托管
- 1.Git
    - 1.[`git pull` 和 `git fetch` 的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1git-pull-和-git-fetch-的区别)
    - 2.[`git merge` 和 `git rebase` 的区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2git-merge-和-git-rebase-的区别)
    - 3.[如何在本地新建一个分支，并 push 到远程服务器上？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3如何在本地新建一个分支并-push-到远程服务器上)
    - 4.[如果 fork 了一个别人的仓库，怎样与源仓库保持同步](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4如果-fork-了一个别人的仓库怎样与源仓库保持同步)
    - 5.[总结一下 Git 常用的命令？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5总结一下-git-常用的命令)
- 2.Svn
- 3.CocoaPods
    - 1.[说一下 `CocoaPods` 的原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1说一下-cocoapods-的原理)
    - 2.[如何让自己写的框架支持 `CocoaPods`？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2如何让自己写的框架支持-cocoapods)
    - 3.[`pod update` 和 `pod install` 有什么区别？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3pod-update-和-pod-install-有什么区别)
    - 4.[`Podfile.lock` 文件起什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4podfilelock-文件起什么作用)
    - 5.[CocoaPods 常用指令？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5cocoapods-常用指令)
    - 6.[在使用 CocoaPods 中遇到过哪些问题？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6在使用-cocoapods-中遇到过哪些问题)
    - 7.[如何使用 CocoaPods 集成远程私有库？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7如何使用-cocoapods-集成远程私有库)
    - 8.[如果自己写的库需要依赖其他的三方库，该怎么办？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8如果自己写的库需要依赖其他的三方库该怎么办)
    - 9.[CocoaPods 中的 Subspec 字段有什么用处？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9cocoapods-中的-subspec-字段有什么用处)
- 4.Carthage
- 5.Fastlane
- 6.Jenkins
- 7.fir.im
- 8.蒲公英
- 9.TestFlight

## 数据安全及加密
- 1.[RSA非对称加密 ](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1rsa非对称加密) 
- 2.[AES对称加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2aes对称加密)
- 3.[DES加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3des加密)
- 4.[Base64加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4base64加密)
- 5.[MD5加密](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5md5加密)
- 6.[简述 `SSL` 加密的过程用了哪些加密方法，为何这么作？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6简述-ssl-加密的过程用了哪些加密方法为何这么作)
- 7.[是否了解 `iOS` 的签名机制？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7是否了解-ios-的签名机制)
- 8.[如何对 `APP` 进行重签名？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8如何对-app-进行重签名)

## 源代码阅读
- 1.YYKit
- 2.SDWebImage
- 3.AFNetworking
- 4.SVProgressHub 
- 5.Texture（ASDK）

## iOS逆向及安全
- [补充：怎么防止反编译？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充怎么防止反编译)
- [补充：项目中网络层如何做安全处理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充项目中网络层如何做安全处理)

## Coretext
## 项目组件化
- 1.说一下你之前项目的组件化方案？
- 2.项目的组件化模块应该如何划分？
- 3.如何集成本地私有库？
- 4.如何集成远程私有库？

## 性能优化
- 1.[如何提升 `tableview` 的流畅度？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1如何提升-tableview-的流畅度)
- 2.[如何使用 `Instruments` 进行性能调优？(Time Profiler、Zombies、Allocations、Leaks)](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2如何使用-instruments-进行性能调优time-profilerzombiesallocationsleaks)
- 3.[如何优化 `APP` 的启动时间？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3如何优化-app-的启动时间)
- [补充：今日头条的启动优化方案](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充今日头条的启动优化方案)
- 4.[如何对 `APP` 进行内存、电量、网络流量的优化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4如何对-app-进行内存电量网络流量的优化)
- 5.[如何有效降低 `APP` 包的大小？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5如何有效降低-app-包的大小)
- 6.[日常如何检查内存泄露？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6日常如何检查内存泄露)
- 7.[能不能说一下物理屏幕显示的原理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7能不能说一下物理屏幕显示的原理)
- 8.[解释一下什么是屏幕卡顿、掉帧？该如何避免？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8解释一下什么是屏幕卡顿掉帧该如何避免)
- 9.[什么是 `离屏渲染`？什么情况下会触发？该如何应对？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9什么是-离屏渲染什么情况下会触发该如何应对)
- [补充：如何检测离屏渲染？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充如何检测离屏渲染)
- 10.[如何高性能的画一个圆角？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10如何高性能的画一个圆角)
- 11.[如何优化 APP 的内存？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11如何优化-app-的内存)
- 12.[如何优化 APP 的电量？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12如何优化-app-的电量)
- [补充：假如Controller太臃肿，如何优化？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充假如controller太臃肿如何优化)

## 调试技巧 & 软件使用
- 1.`LLDB` 调试。
- 2.断点调试- breakPoint。
- 3.`NSAssert` 的使用。
- 4.`Charles` 的使用。
    - 使用 Charles 下载过去任意版本的 App。
- 5.`Reveal` 的使用。
- 6.iOS 常见的崩溃类型有哪些？
- 7.当页面 AutoLayout 出现了问题，怎样快速调试？

## 扩展问题
- 1.无痕埋点
- 2.APM（应用程序性能监测）
- 3.Hot Patch（热修补）
- 4.崩溃的处理
- 补充：各个app之间是怎么相互切换的

## 其他问题
- [补充：在OC中对象方法的几种访问权限，分别是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充在oc中对象方法的几种访问权限分别是什么)
- [补充：列出 #import 和 #include 的区别，另外什么时候使用@class？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充列出-import-和-include-的区别另外什么时候使用class)
- 1.[`load` 和 `Initialize` 的区别?](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#1load-和-initialize-的区别)
- 2.[`Designated Initializer`的规则？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#2designated-initializer的规则)
- 3.[`App` 编译过程有了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#3app-编译过程有了解吗)
- [补充：介绍下App启动的完成过程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充介绍下app启动的完成过程)
- 4.[`JS` 和 `Native` 交互。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#4js-和-native-交互)
- 5.[`LoadView`方法了解吗？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#5loadview方法了解吗)
- 6.[说一下对 `APNS` 的认识？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#6说一下对-apns-的认识)
- 7.[`UIButton` 的父类是什么？`UILabel` 的父类又是什么？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#7uibutton-的父类是什么uilabel-的父类又是什么)
- 8.[实现一个控件，可以浮在任意界面的上层并支持拖动？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#8实现一个控件可以浮在任意界面的上层并支持拖动)
- 9.[解释一下 `copy` 关键字涉及的方方面面，说的越全越好。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#9解释一下-copy-关键字涉及的方方面面说的越全越好)
- 10.[说一下控制器 `View` 的生命周期，一旦收到内存警告会如何处理？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#10说一下控制器-view-的生命周期一旦收到内存警告会如何处理)
- 11.[简述事件传递、事件响应机制。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#11简述事件传递事件响应机制)
- 12.[说一下对 `Super` 关键字的理解。](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#12说一下对-super-关键字的理解)
- 13.[`@synthesize` 和 `@dynamic` 分别有什么作用？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#13synthesize-和-dynamic-分别有什么作用)
- [补充：简述Xcode7和Xcode8的异同](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充简述xcode7和xcode8的异同)
- [补充：描述iOS 10的一些新特性（包括系统和开发环境）](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充描述ios-10的一些新特性包括系统和开发环境)
- 14.[App 上有一数据列表，客户端和服务端均没有任何缓存，当服务端有数据更新时，该列表在 wifi 下能获取到数据，在 4G 下刷新不到，但是在 4g 环境下其他 App 都可以正常打开，分析其产生的原因？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#14app-上有一数据列表客户端和服务端均没有任何缓存当服务端有数据更新时该列表在-wifi-下能获取到数据在-4g-下刷新不到但是在-4g-环境下其他-app-都可以正常打开分析其产生的原因)
- 15.[是否了解链式编程？](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#15是否了解链式编程)
- [补充：dSYM你是如何分析的](https://github.com/ReginaVicky/iOSInterviewQuestions/blob/master/03《微博%40Liberalisman面试知识点总结》/03《微博%40Liberalisman面试知识点总结》.md#补充dsym你是如何分析的)


## 25.计算题
1.**输出如下的计算结果**

```objc
int a=5,b;
b=(++a)+(++a);
```

2.**不使用第三个变量，交换两个变量的值。**

```
int a = 5;
int b = 10;
```
3.**给出 i值得取值范围？ （大于或等于10000）**

```
__block int i = 0;

    while (i<10000) {

    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        i++;
    });
}
    NSLog(@"i=%d",i);
}
```
4.**编码求，给定一个整数，按照十进制的编码计算包含多少个 0? ）**

## 26.开放性问题

- 1.你最近在业余时间研究那些技术点？可不可以分享一下你的心得？
- 2.你对自己未来的职业发展有什么想法？有没有对自己做过职业规划？
- 3.和同事产生矛盾（包括意见分歧），你一般怎么解决？
- 4.能不能说一下你的业余精力都花在什么方面，或者介绍一下你的爱好？
- 5.学习技术知识通常通过哪些途径？
- 6.遇到疑难问题一般怎么解决？能不能说一个你印象颇深的技术难点，后来怎么解决的？
- 7.作为开发苹果应用者有多长时间，拥有哪些苹果设备？
- 8.平时你经常访问哪些技术类网址
- 9.为什么选择iOS开发，你对它的前景和本身有什么想法？请简要回答。
- 10.你有自己的开源项目吗，用什么托管的代码


# 数据结构及算法

## 数据结构
### 1.数组
### 2.字符串
### 3.链表
### 4.树
### 5.栈
### 6.队列
### 7.哈希表（有哪些功能是通过哈希表实现的）

## 算法
### 基本概念
#### 时间复杂度
#### 空间复杂度

### 常见的摘要算法
#### HEX编码
#### Base64
#### MD5
#### SHA1
#### SHA256
#### MAC算法

### 常见对称加密算法
#### AES
#### DES
#### 3DES
#### - Blowfish

### 常见的排序算法
#### 快速排序
#### 堆排序
#### 冒泡排序
#### 选择排序
#### 希尔排序
#### 归并排序

### 常见的字符编码方法
#### ASCII
#### ISO-8859-1
#### GB2312
#### GBK
#### UTF-8
#### UTF-16
#### Unicode

### 常考算法题
#### 1.字符串反转 
#### 2.链表反转
#### 3.有序数组合并
#### 4.查找第一个只出现一次的字符
#### 5.查找两个子视图的共同父视图
#### 6.无序数组中的中位数
#### 7.两数之和为特定值
#### 8.求出数组中连续数字的和值
#### 9.白鼠与毒酒的算法问题
#### 10.在一个数组中找出前四个最大的数字。
#### 11.假如有 10亿 条数据，每条数据的大小在 10k-100k 之间，我们有一台内存为 4G 的电脑，如何算出播放次数最多的一条微博？
#### 12.如何打印一个矩阵？
#### 13.如何验证一个 IP 地址的有效性？
#### 14.栈中储存着一组无序的数字，不用遍历的方式，如何找出最小值？
#### 15.二维数组查找一个值。
#### 补充：插入排序
#### 补充：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
##### 方法一：最笨效率最低的办法，两个for循环，找出出现相同数字的次数

```
- (void)test1{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
   
    for (int i = 0; i < array.count; i++) {
        NSString *itemi = array[i];
         int count = 0;
        for (int j = 0; j<array.count; j++) {
             NSString *itemj = array[j];
            if ([itemi isEqualToString:itemj]) {
                count++;
            }
        }
        if (count == 1) {
            NSLog(@"只出现一次数为：%@", array[i]);
        }
    }
}
```
##### 方法二：利用数组比较元素的方法，如果数组中没有出现该元素则添加，如果该元素出现了则删除该元素

```
- (void)test2{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
    
    NSMutableArray *mArray = [[NSMutableArray alloc] init];
   
    for (int i = 0; i < array.count; i++) {
         NSString *item = array[i];
        if (![mArray containsObject:item]) {
            [mArray addObject:item];
        }else{
            [mArray removeObject:item];
        }
    }
    NSLog(@"只出现一次数为：%@", mArray);
}

```
##### 方法三：直接遍历整个数组，建成hash的数组。最后再遍历一次hash，取出对应key的数组有几个元素，如果有一个元素的key则是要找的只出现一次的元素。

```
- (void)test3{
    NSArray *array = @[@"1",@"1",@"2",@"2",@"3",@"3",@"4",@"4",@"5",@"6"];
    
    NSMutableDictionary *dict = [NSMutableDictionary dictionary];
    for (int i = 0; i < array.count; i++) {
        NSString *item = array[i];
       // 如果字典中不存在该key
        if (![[dict allKeys] containsObject:item]) {
            NSMutableArray *mArray = [[NSMutableArray alloc] init];
            [mArray addObject:item];
            [dict setObject:mArray forKey:item];
        }
        else{
            // 如果字典中存在key,则取出数组增加元素
            NSMutableArray *mArray = [dict objectForKey:item];
            [mArray addObject:item];
        }
        
    }
    
    NSArray *keyArr = dict.allKeys;
// 遍历字典，取出的数组如果只有一个元素的则是我们要找的
    for (int i = 0; i < keyArr.count; i++) {
        NSString *key = keyArr[i];
        NSMutableArray *arr = [dict objectForKey:key];
        if (arr.count == 1) {
            NSLog(@"只出现一个数为：%@", key);
        }
    }
    
}
```


#### 补充：100层楼，扔两个鸡蛋，寻找使鸡蛋摔碎的楼层最快要扔多少次？（Google经典的面试题，有一个100层的楼，你手里现在有两个一模一样的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事，要你用这两个鸡蛋确定哪一层是鸡蛋可以安全落下的最高位置？）

解释：两个鸡蛋一样，只有在达到某个楼层高度时，才会摔碎。可以假设这个摔碎临界楼层是N。
* 最笨的方法:只用一个鸡蛋遍历——N次尝试
    - 一个鸡蛋遍历那就是从一楼顶开始，逐层尝试，如果摔不碎那就继续往上层尝试，直到N层摔碎了。这样就尝试了N次，而且浪费了一个鸡蛋的使用。
* 二分查找——两个鸡蛋，鸡蛋A用来二分尝试，鸡蛋B用来在A摔碎后做局部遍历尝试
    - 鸡蛋A用来做二分尝试，即第一次从50层扔下。
    - 最悲观情况，直接摔碎，说明N在1-50之间，那么鸡蛋B也只能从1开始遍历，回到了第一种情况（最多尝试次数也是N）。
    - 乐观情况，鸡蛋A没摔碎，接下来就可以尝试从75层扔下，碎了那就是N在51-74之间了。尝试次数为1+1+（74-51）=25次。
    - 更乐观情况，鸡蛋A在75层也没碎，接下来可以在87层扔下；A碎了则N在76-86之间，故是需要1+1+1+（86-76）=13次。
    - A没碎，接下来在93层扔下；A碎了则N在88-92之间，故需要扔1+1+1+1+（92-88）=8次。
    - A没碎，接下来在96层扔下；A碎了则N在94-95之间，故需要扔1+1+1+1+1+（95-94）=6次。
    - A没碎，接下来在98层扔下；A碎了则N在97-98，故需要扔1+1+1+1+1+1=6次。
    - A没碎，则A在99-100之间，如需要扔6+1=7次。
* 可见，用二分法结果很不稳定，特别是N小于50时最糟糕（甚至会比第一种直接遍历的还要多一次）。N越大越好找，需要尝试的次数越少。
如果这个题目换成鸡蛋个数不限制，那就是用二分法最快了。
* 平均分割楼层法——假设总共扔X次，其中鸡蛋A扔了X1次，鸡蛋B扔了X2次
    - X=X1+X2
    - 鸡蛋A用来做楼层平均分割，大步尝试；鸡蛋B作为每一小部分的遍历小步尝试。
    - 假设将100层平均分为10部分，即鸡蛋A分别在第10、20、30、40、50、60、70、80、90、100层扔；则鸡蛋B在A摔碎后在细分的那个楼层小步遍历寻找即可。如此的平均尝试次数又要比二分查找更好。
    - 但问题是如何找到最优的平均分割n段，X1=n，X2=100/n。X=n+100/n，可见n平方=100即n等于10时，X=20。
    - 若能在后面每一段更准确地分析出应该分的楼层数（如图2），而不是平均10层一段（如图1），会有更优的效果。下一个方法就是这样。
* 假设法——假设最多允许尝试X次，问能尝试到的最高的楼层。
    - 第1次从X楼扔下来。因为即使摔坏了，也可以用另一个鸡蛋遍历X-1次找到该楼层。
    - 第2次（还剩X-1次尝试次数）可以从X+(X-1)层扔下来。因为即使摔碎了，也可以用另一个鸡蛋遍历X-1-1次找到该楼层。
    - 同理，第3次，可以从X+(X-1)+(X-2)层扔下来。
    - 第X次。可以从第X+(X-1)+(X-2)+...+(X-(X-2))+1层扔下来，这就是最高可能尝试到的楼层X*(X+1)/2，下面所有的楼层都可以在X次尝试中到达。
    - 当最高楼层为100时，可列出不等式：最高可能尝试到的楼层X*(X+1)/2 > 100，解出X=14次。这就是最稳定的最快寻找到该楼层的扔鸡蛋次数。也就是说第一次扔鸡蛋要从14楼开始扔。14+13+12+11+...+2+1 = 105层，也就是14次尝试一定可以在1-105层中找到那个第N层。推出了公式X*(X+1)/2后，要想编程求任意总楼层条件下，就都很方便了。

   ![image](https://upload-images.jianshu.io/upload_images/1197643-f14862e6af2c67c9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/198)
   
* 动态规划法——找最优解常用方法

在我们编程解决问题的过程中，如果遇到最优问题的时候，往往可以先尝试一下动态规划的方法。而动态规划的方法，首要的我们要找到构成这个最优问题的最优子问题。所以，下面的分析，我们首先尝试动态规划的方法，如何解决这个问题，这也是典型的程序员的思路；其次，在众多的问题当中，有不少可以直接归结为数学方程式，如果我们能够写出数学方程式，那么，答案将是更加的简洁、美妙（比如上一种方法推导出来的公式）。
* 基于动态规划的方法
    - 前面提到，若要采用动态规划的方法，最重要的是要找到子问题。做如下面的分析，假设F{n}表示从第n层楼扔下鸡蛋，找到不摔碎鸡蛋楼层的最少尝试次数。第一个鸡蛋可能从第i层扔下，有两个情况：
    - 碎了，第二个鸡蛋，需要从第一层开始试验，最多要尝试i-1次。
    - 没碎，两个鸡蛋，还有n-i层。这个就是子问题了f[n-i] 。
* 所以，当第一个鸡蛋，由第i个位置落下的时候，要尝试的次数为f[i]= 1 + max(i - 1, f[n-i])用max是确保一定可以在这么多次内找到。那么对于每一个i对f(i)进行比较，非最小的f(i)，就是F{n}的值。状态转移方程如下： F{n} = min f[i] = min(1 + max(i - 1, f[n-i]) ) 其中: i的范围为(1, n), f[1] = 1 完毕。
* 推广动态规划的方法，可以推广为n层楼，m个鸡蛋。如下分析： 假设f{n,m}表示n层楼、m个鸡蛋时找到最高楼层的最少尝试次数。当第一个鸡蛋从第i层扔下，如果碎了，还剩m-1个鸡蛋，为确定下面楼层中的安全楼层，还需要f{i-1,m-1}次，找到子问题；不碎的话，上面还有n-i层，还需要f[n-i,m]次，又一个子问题。 状态转移方程如下： f{n, m} = min(1 + max(f{i - 1, m - 1}, f{n - i, m}) ) 其中： i为(1, n), f{i, 1} = 1
* 拓展一下，如果不是100楼层，是N楼层，曾怎么计算呢？

![image](https://upload-images.jianshu.io/upload_images/1197643-336110312293e97a.png?imageMogr2/auto-orient/strip|imageView2/2/w/283)
* 再次拓展，如果我们有三个鸡蛋，有k次机会，我们最大可以测试多少层楼？

![image](https://upload-images.jianshu.io/upload_images/1197643-5a0a44afdb597907.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/690)
* 如果我们有M个鸡蛋，有k次机会，我们最大可以测试多少层楼？

#### 补充：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。或者是问：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

##### 题解一
- 对于排序的数组，数组中出现次数超过一半的数字一定会出现在数组的中间。于是先将数组排序，然后输出中位数即可。但是由于输入的数组不一定满足要求，所以别忘了检查得到的数字是否真的在数组中出现的次数超过一半。
- 时间复杂度为O(nlogn)，空间复杂度为O(1)。
##### 题解二
- 一个直观的解法是使用哈希表。遍历一遍数组，将数组中每个元素出现的次数存入哈希表，然后遍历哈希表，找出出现次数大于一半的数字。
- 时间复杂度为O(n)，空间复杂度为O(n)。
##### 题解三
- 考虑数组的特性，若数组中有一个数字出现的次数超过了数组长度的一半，那么数组中第 n/2 大的数字一定是这个数字。
- 可以借助快排的思想来寻找特定的下标，这里我们需要寻找的下标就是 n/2，每次 Partition 都可以将 pivot放置到其对应的位置，且所有小于pivot的数字都在 pivot 左边，大于 pivot 的数字都在 pivot右边。排序后数组中的下标为数组长度一半的数字即为数组中第 n/2 大的数字（数组的中位数）。
- 为了找到这个数字，我们可以使用递归，如果 pivot 的坐标小于 n/2，那么继续在 pivot 右边进行查找；如果 pivot 的坐标大于 n/2，那么继续在 pivot 左边进行查找；如果 pivot 的坐标刚好等于n/2，那么就返回数组中对应的数字。
- 最后别忘了检查得到的数字是否真的在数组中出现的次数超过一半，毕竟上述算法得到的只是这个数组中第 n/2大的数字，并不保证这个数字出现次数超过一半。
- 时间复杂度为O(n)，空间复杂度为O(1)。
##### 题解四
- 还有另外一种巧妙的方法。遍历数组，同时维护两个变量：一个是数组中的一个数字，另一个是次数。在遍历数组时，第一个数字作为守方，设置count=1，接下来的数字进行攻击。在遇到相同元素时守方即count加1，遇到不同元素时count-1。在count为0时，新的数字成为新的守方，接受接下来的攻击。
- 若数组中有一个出现次数超过一半的数字，那么它一定是最终的胜利者。但也有可能不存在这与的数字，所以在结束之后也要像之前一样进行检查。
- 时间复杂度为O(n)，空间复杂度为O(1)。

## iOS 内存管理

### 1.讲一下 `iOS` 内存管理的理解？(三种方案的结合)

OC中的内存管理主要有三种方式：ARC、MRC、自动释放池
* MRC（Mannul Reference Counting）手动引用计数
* ARC（automatic reference counting）自动引用计数
* 在5.0版本以前，OC内存管理遵循“谁创建、谁释放、谁引用、谁管理”的机制，当创建或引用一个对象的时候，需要向她发送alloc、copy、retain消息，当释放该对象时需要发送release消息，当对象引用计数为0时，系统将释放该对象，其实这就是手动管理机制。
* 在5.0以后，引用自动管理机制，其实管理机制和手动管理机制一样，只是不再需要调用retain、release、autorelease；它编译时的特性，当你使用ARC时，在适当位置插入release和autorelease；它引用strong和weak关键字，strong修饰的指针变量指向对象时，当指针指向新值或者指针不复存在，相关联的对象就会自动释放，而weak修饰的指针变量指向对象，当对象的拥有者指向新值或者不存在时weak修饰的指针会自动置为nil。如果使用alloc、copy或者retain一个对象时，你就有义务，向它发送一条release或者autorelease消息。其他方法创建的对象，不需要由自己来管理内存
* 自动释放池：（NSAutoRealeasePool）可以通过创建和释放内存池控制内存申请和收回的时机。向一个对象发送一条autorelease消息，这个对象并不会立即销毁，而是将这个对象放入了自动释放池，待池子释放时，它会向池子中每一个对象发送一条release消息，以此来释放对象。向一个对象发送release消息，并不意味着这个对象被销毁了，而是当这个对象的引用计数为0时，系统才会调用dealloc方法，释放该对象和对象本身他所拥有的实例。

也就是说，iOS中对内存管理的机制（堆内存），是通过 retainCount 的机制来决定对象是否需要释放。每一个对象都有一个与之关联的retainCount， 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。

#### OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。retain引用计数+1，release反之。

例如

```
// MRC代码
NSObject * obj = [[NSObject alloc] init]; //引用计数为1

//不需要的时候
[obj release] //引用计数减1

//持有这个对象
[obj retain] //引用计数加1

//放到AutoReleasePool
[obj autorelease]//在auto release pool释放的时候，引用计数减1
```

```
// ARC代码
NSObject * obj;
{
    obj = [[NSObject alloc] init]; //引用计数为1
}
NSLog(@"%@",obj);
```
* 我们可以先来看看ratain和release内部是如何实现的。
    - retain
    
```
- (id)retain {
    return ((id)self)->rootRetain();
}

inline id objc_object::rootRetain()
{
    if (isTaggedPointer()) return (id)this;
    return sidetable_retain();
}
```
可以看出retain底层是调用了sidetable_retain()

```
id objc_object::sidetable_retain()
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];//获取引用计数表
    
    table.lock(); // 加锁
    size_t& refcntStorage = table.refcnts[this]; // 根据对象的引用计数
    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
        refcntStorage += SIDE_TABLE_RC_ONE;
    }
    table.unlock(); // 解锁

    return (id)this;
}
```
SideTable数据结构：
SideTable 这个结构体，我给他起名引用计数和弱引用依赖表，因为它主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构：
```
struct SideTable {
// 保证原子操作的自旋锁
    spinlock_t slock;
    // 引用计数的 hash 表
    RefcountMap refcnts;
    // weak 引用全局 hash 表
    weak_table_t weak_table;

    // 省略...
};
```
通过代码可以看出，SideTable拥有一个自旋锁，一个引用计数map。这个引用计数的map以对象的地址作为key，引用计数作为value；对于 slock 和 refcnts 两个成员不用多说，第一个是为了防止竞争选择的自旋锁，第二个是协助对象的 isa 指针的 extra_rc 共同引用计数的变量。这里主要看 weak 全局 hash 表的结构与作用。

* release

```
- (oneway void)release {
    ((id)self)->rootRelease();
}

inline bool objc_object::rootRelease()
{
    if (isTaggedPointer()) return false;
    return sidetable_release(true);
}
```

```
uintptr_t objc_object::sidetable_release(bool performDealloc)
{
#if SUPPORT_NONPOINTER_ISA
    assert(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];

    bool do_dealloc = false;

    table.lock(); // 加锁
    RefcountMap::iterator it = table.refcnts.find(this); // 先找到对象的地址
    if (it == table.refcnts.end()) {
        do_dealloc = true; //引用计数小于阈值，最后执行dealloc
        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;
    } else if (it->second < SIDE_TABLE_DEALLOCATING) {
        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.
        do_dealloc = true;
        it->second |= SIDE_TABLE_DEALLOCATING;
    } else if (! (it->second & SIDE_TABLE_RC_PINNED)) {
        it->second -= SIDE_TABLE_RC_ONE; //引用计数减去1
    }
    table.unlock(); // 解锁
    if (do_dealloc  &&  performDealloc) {
        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);
    }
    return do_dealloc;
}
```
release过程：查找map，对引用计数减1，如果引用计数小于阈值，则调用SEL_dealloc

#### 关于内存管理的方案（三种方案的结合）

* 第一种方案：Tagged Pointer（标记指针）
    - 一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但像NSNumber、NSDate一类的对象所占用的内存会翻倍，进而浪费内存。为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。
    - 我们将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。
    - Tagged Pointer特点
        - Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate
        - Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。
        - 在内存读取上有着3倍的效率，创建时比以前快106倍。
    - 总体来说，如果一个对象使用了Tagged Pointer技术（比如NSString，NSNumber等），指针里面会直接存数据内容，不会再作为“指针”指向其它地址，从Runtime来理解就是不会使用isa指针，也就不会继承苹果的内存管理方式（Reference Counting）。
    - 注意：所有对象都有 isa 指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以如果你直接访问Tagged Pointer的isa成员的话，在编译时将会有如下警告：
    ![image](https://res.infoq.com/articles/deep-understanding-of-tagged-pointer/zh/resources/0519063.jpg)
   
应该换成相应的方法调用，如 isKindOfClass 和 object_getClass。只要避免在代码中直接访问对象的isa变量，即可避免这个问题。
    
* 第二种方案：isa 指针（NONPOINTER_ISA）
    - 指针的内存空间很大，有时候可以优化指针，在指针中存储一部分内容。
    - 不同架构下的64位环境中isa指针结构:
    
```
union isa_t 
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

#if SUPPORT_NONPOINTER_ISA
# if __arm64__
#   define ISA_MASK        0x00000001fffffff8ULL
#   define ISA_MAGIC_MASK  0x000003fe00000001ULL
#   define ISA_MAGIC_VALUE 0x000001a400000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 30; // MACH_VM_MAX_ADDRESS 0x1a0000000
        uintptr_t magic             : 9;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 19;
#       define RC_ONE   (1ULL<<45)
#       define RC_HALF  (1ULL<<18)
    };

# elif __x86_64__
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x0000000000000001ULL
#   define ISA_MAGIC_VALUE 0x0000000000000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 14;
#       define RC_ONE   (1ULL<<50)
#       define RC_HALF  (1ULL<<13)
    };

# else
    // Available bits in isa field are architecture-specific.
#   error unknown architecture
# endif

// SUPPORT_NONPOINTER_ISA
#endif

};

```

   - 只有arm64架构的设备支持优化，下面列出了isa指针中变量对应的含义:
 
变量名 | 含义
---|---
indexed | 0 表示普通的isa指针，1 表示使用优化，存储引用计数
has_assoc | 表示该对象是否包含 associated object，如果没有，则析构时会更快
has_cxx_dtor | 表示该对象是否有 C++ 或 ARC 的析构函数，如果没有，则析构时更快
shiftcls | 类的指针
magic | 固定值为 0xd2，用于在调试时分辨对象是否未完成初始化
weakly_referenced | 表示该对象是否有过weak对象，如果没有，则析构时更快
deallocating | 表示该对象是否正在析构
has_sidetable_rc | 表示该对象的引用计数值是否过大无法存储在isa指针
extra_rc | 存储引用计数值减一后的结果 

* 第三种方案：散列表
    - 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
    - 散列表就是把Key通过一个固定的算法函数既所谓的散列函数转换成一个整型数字即散列值，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。而当使用散列表进行查询的时候，就是再次使用散列函数将key转换为对应的数组下标，并定位到该空间获取value，如此一来，就可以充分利用到数组的定位性能进行数据定位。
    - 哈希表的本质是一个数组，数组中每一个元素称为一个箱子(bin)，箱子中存放的是键值对。
    - 散列表来存储引用计数具体是用DenseMap类来实现，实现中有锁保证其安全性。
    - DenseMap类中包含好多映射实例到其引用计数的键值对，并支持用 DenseMapIterator 迭代器快速查找遍历这些键值对。
    - 引用计数表、weak表都是散列表；

### 2.使用自动引用计（ARC）数应该遵循的原则?

* ARC规则：
    - 不能使用retain/release/retainCount/autorelease
    - 不能使用NSAllocateObject/NSDeallocateObject
    - 必须遵守内存管理的方法命名规则
    - 不要显式调用dealloc
    - 使用@autoreleasepool块替代NSAutoreleasePool
    - 不能使用区域NSZone
    - 对象型变量不能作为c语言结构体的成员
    - 显式转换id和void*



### 3.ARC 自动内存管理的原则?

* 自己生成的对象，自己持有
* 非自己生成的对象，自己可以持有
* 自己持有的对象不再需要时，需要对其进行释放
* 非自己持有的对象无法释放

### 4.访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？

* 在访问__weak修饰的变量时，必定要访问注册到autoreleasepool的对象，这是因为：__weak修饰符只持有对象的弱引用，他不能持有对象实例，所以在超出其变量作用域时，对象即被释放。 而在访问引用对象的过程中，该对象可能被废弃，而如果把要访问的对象注册到autoreleasepool中，在@autoreleasepool块结束之前都能确保该对象存在。

### 5.ARC 的 retainCount 怎么存储的？

* 采用散列表（引用计数表）来管理引用计数。
![image](http://upload-images.jianshu.io/upload_images/131615-d1212b1150b575e7.png)

GNUstep将引用计数保存在对象占用内存块头部的变量中，而苹果的实现，则是保存在引用计数表的记录中。
* 通过内存卡头部管理引用计数的好处如下：
    - 少量代码即可完成
    - 能够统一管理引用计数用内存块与对象用内存块
* 通过引用计数表管理引用计数的好处如下：
    - 对象用内存块的分配无需考虑内存块头部
    - 引用计数表各记录中存有内存块地址，可从各个记录中追溯到各对象的内存块
* 即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置
![image](http://upload-images.jianshu.io/upload_images/131615-6ebbb4f2275a7362.png)

### 6.简要说一下 @autoreleasePool 的数据结构？
- 简单说是双向链表，每张链表头尾相接，有parent、child指针
- 每创建一个池子，会在首部创建一个哨兵对象,作为标记
- 最外层池子的顶端会有一个next指针。当链表容量满了，就会在链表的顶端，并指向下一张表。

### 7.__weak 和 _Unsafe_Unretain 的区别？
- weak 修饰的指针变量，在指向的内存地址销毁后，会在 Runtime 的机制下，自动置为 nil。
- _Unsafe_Unretain不会置为 nil，容易出现 悬垂指针，发生崩溃。但是 _Unsafe_Unretain 比 __weak 效率高。

### 8.为什么已经有了 ARC ,但还是需要 @AutoreleasePool 的存在？
### 9.__weak 属性修饰的变量，如何实现在变量没有强引用后自动置为 nil
- 用的弱引用 - weak表。也是一张 哈希表。
- 被 weak 修饰的指针变量所指向的地址是 key ，所有指向这块内存地址的指针会被添加在一个数组里，这个数组是 Value。当内存地址销毁，数组里的所有对象被置为 nil。

### 10.说一下对 retain,copy,assign,weak,_Unsafe_Unretain 关键字的理解。
- Strong：修饰符表示指向并持有该对象，其修饰对象的引用计数会加1。该对象只要引用计数不为0就不会被销毁。当然可以通过将变量强制赋值 nil 来进行销毁。
- weak：修饰符指向但是并不持有该对象，引用计数也不会加1。在 Runtime 中对该属性进行了相关操作，无需处理，可以自动销毁。weak用来修饰对象，多用于避免循环引用的地方。weak 不可以修饰基本数据类型。
- assign：主要用于修饰基本数据类型，例如NSInteger，CGFloat，存储在栈中，内存不用程序员管理。assign是可以修饰对象的，但是会出现问题。
- copy：关键字和strong类似，copy多用于修饰有可变类型的不可变对象上NSString,NSArray,NSDictionary上。
- __unsafe_unretain：类似于weak，但是当对象被释放后，指针已然保存着之前的地址，被释放后的地址变为僵尸对象，访问被释放的地址就会出问题，所以说他是不安全的。
- __autoreleasing：将对象赋值给附有__autoreleasing修饰的变量等同于 ARC 无效时调用对象的autorelease方法,实质就是扔进了自动释放池。

### 补充：简述下列属性的作用：readwrite、readonly、assign、retain、copy、nonatomic、weak、strong
- readwrite：可读可写特性,需要生成setter和getter方法时使用, 可被外界读取和修改；
- readonly：只读特性,只会生成getter方法,只可被外界读取, 不能修改；
- assign：赋值特性,作用于非OC对象的赋值,setter方法将参数传给变量；
- retain：持有特性,他的setter方法会释放旧址,然后引用住新值, 并且将新值的引用计数+1,只能作用于OC对象(基本数据类型和CoreFoundation对象没有引用计数的概念, 因此不能用retain)
- copy
    * 复制特性,此属性只对遵守了NSCopying协议的对象类型有效,一般作用于NSString,NSArray,NSDictionary等有可变类型的对象
    * 如果copy的是不可变类型,就不会开辟新的内存空间, 并且为指针拷贝, 指向同一个内存地址:浅拷贝
    * 如果copy的是可变类型, 就会开辟新的内存空间, 并且将内容copy下来单独保存: 深拷贝
    * 注意: 如果在系统中创建内容相同的不可变字符串, 系统会自动做出优化, 指向同一块内存空间
- nonatomic
    * 非原子性,即非线程安全的,不给变量提供线程锁保护, 这样会提高性能
    * 在iOS的移动端,一般不会出现多线程访问同一个属性的情况,就算发生情况,atomic也不能完美的保证安全, 并且还需要手动增加线程锁,因此对于变量都应该使用nonatomic
- atomic
    * atomic会给属性加上一个同步锁,这是为了防止多线程同时访问属性出现异常需要添加的属性,但是这样会增加额外的内存开销并且在变编程习惯中,我们都应该避免多线程访问统一资源
    * 即便是使用atomic,在多线程时也无法完全保证线程安全, 往往是需要手动添加线程锁

### 补充：automic的实现机制；
- 添加属性时使用了automic声明的，系统会自动在setter和getter方法中添加锁来实现读写安全。
- 通过源码查看发现automic的原理是使用OSSPinLock来实现的，这种自旋锁会出现优先级反转导致死锁的问题，所以不推荐automic。
- 在iOS 10之后系统推荐使用os_unfair_lock来代替OSSPinlock，并且automic在iOS10之后也使用os_unfair_lock来实现了。

### 11.ARC 在编译时做了哪些工作？
- 主要是指 weak 关键字。weak 修饰的变量能够在引用计数为0 时被自动设置成 nil，显然是有运行时逻辑在工作的。
- 为了保证向后兼容性，ARC 在运行时检测到类函数中的 autorelease 后紧跟其后 retain，此时不直接调用对象的 autorelease 方法，而是改为调用 objc_autoreleaseReturnValue。
objc_autoreleaseReturnValue会检视当前方法返回之后即将要执行的那段代码，若那段代码要在返回对象上执行 retain 操作，则设置全局数据结构中的一个标志位，而不执行 autorelease操作，与之相似，如果方法返回了一个自动释放的对象，而调用方法的代码要保留此对象，那么此时不直接执行 retain ，而是改为执行 objc_retainAoutoreleasedReturnValue函数。此函数要检测刚才提到的标志位，若已经置位，则不执行 retain 操作，设置并检测标志位，要比调用 autorelease 和retain更快。

### 12.ARC 在运行时做了哪些工作？
- 根据代码执行的上下文语境，在适当的位置插入 retain，release

### 13.函数返回一个对象时，会对对象 autorelease 么？为什么？
- 会 ，为了延长返回对象的生命周期，给其他使用者留足调用的时间

### 14.说一下什么是 悬垂指针？什么是 野指针?
- 悬垂指针：指针指向的内存已经被释放了，但是指针还存在，这就是一个 悬垂指针 或者说 迷途指针
- 野指针：没有进行初始化的指针，其实都是 野指针

### 补充：循环引用
- 循环引用的实质：多个对象相互之间有强引用，不能释放让系统回收。
- 如何解决循环引用？
    * 避免产生循环引用，通常是将 strong 引用改为 weak 引用。 比如在修饰属性时用weak 在block内调用对象方法时，使用其弱引用，
    * 还可以使用__block来修饰变量，在MRC下，__block不会增加其引用计数，避免了循环引用，在ARC下，__block修饰对象会被强引用，无法避免循环引用，需要手动解除。
- 在合适时机去手动断开循环引用。
    * 代理(delegate)循环引用属于相互循环引用
        * delegate 是iOS中开发中比较常遇到的循环引用，一般在声明delegate的时候都要使用弱引用 weak,或者assign,当然怎么选择使用assign还是weak，MRC的话只能用assign，在ARC的情况下最好使用weak，因为weak修饰的变量在释放后自动指向nil，防止野指针存在
    * NSTimer循环引用属于相互循环使用
        * 在控制器内，创建NSTimer作为其属性，由于定时器创建后也会强引用该控制器对象，那么该对象和定时器就相互循环引用了。如何解决呢？这里我们可以使用手动断开循环引用：
如果是不重复定时器，在回调方法里将定时器invalidate并置为nil即可。如果是重复定时器，在合适的位置将其invalidate并置为nil即可
    * block循环引用

```
@property (copy, nonatomic) dispatch_block_t myBlock;
@property (copy, nonatomic) NSString *blockString;

- (void)testBlock {
    self.myBlock = ^() {
        NSLog(@"%@",self.blockString);
    };
}
```
- 由于block会对block中的对象进行持有操作,就相当于持有了其中的对象，而如果此时block中的对象又持有了该block，则会造成循环引用。
- 解决方案就是使用__weak修饰self即可

```
__weak typeof(self) weakSelf = self;

self.myBlock = ^() {
        NSLog(@"%@",weakSelf.blockString);
 };
```
- 并不是所有block都会造成循环引用。只有被强引用了的block才会产生循环引用，而比如dispatch_async(dispatch_get_main_queue(), ^{}),[UIView animateWithDuration:1animations:^{}]这些系统方法等或者block并不是其属性而是临时变量,即栈block

```
[self testWithBlock:^{
    NSLog(@"%@",self);
}];

- (void)testWithBlock:(dispatch_block_t)block {
    block();
}
```
- 还有一种场景，在block执行开始时self对象还未被释放，而执行过程中，self被释放了，由于是用weak修饰的，那么weakSelf也被释放了，此时在block里访问weakSelf时，就可能会发生错误(向nil对象发消息并不会崩溃，但也没任何效果)。对于这种场景，应该在block中对 对象使用__strong修饰，使得在block期间对对象持有，block执行结束后，解除其持有。

```
__weak typeof(self) weakSelf = self;

self.myBlock = ^() {

        __strong __typeof(self) strongSelf = weakSelf;

        [strongSelf test];
 };
```

### 15.内存管理默认的关键字是什么？
- MRC

```
@property (atomic,readWrite,retain) UIView *view;
```
- ARC

```
@property (atomic,readWrite,strong) UIView *view;
```
- 如果改为基本数据类型，那就是 assign。

### 16.内存中的5大区分别是什么？
- 栈区：编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。
- 堆区：由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在iOS 中 alloc 都是存放在堆中。
- 全局区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。
- 文字常量区：存放常量字符串，程序结束后由系统释放程序结束释放。
- 代码区：存放函数的二进制代码

### 补充：iOS程序内存的每个分区怎么存储（举例说明）
- 栈区：存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等，内存地址从高到低分配。
- 堆区：堆区的地址是从低到高分配，通过程序员通过alloc手动分配。
- 全局区：包含两个部分，未初始化区，初始化区域。全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；
- 代码区存放于低地址，栈区存放于高地址。区与区之间并不是连续的。堆区的内存是应用程序共享的，堆中的内存分配是系统负责的；当引用计数为0的时候，系统会回收该内存。

### 补充：block一般存在哪里（分ARC和MRC）
- 在 MRC 下，Block 默认是分配在栈上的，除非进行显式执行的copy方法，只要block没有引用外部的局部变量，block放在全局区里面
- 在ARC的中，对象默认是用__strong修饰的，所以大部分情况下编译器都会将 block从栈自动复制到堆上。有一个特殊情况，如果仅仅定义了block没有赋值给变量的话，仍是在栈上。这种情况下随着作用域结束，block将会销毁回收。

### 补充：代码区存储的是什么？
- 代码区存放的是程序中函数编译后的CPU指令

### 17.是否了解 深拷贝 和 浅拷贝 的概念，集合类深拷贝如何实现？
- 对不可变的非集合对象，copy是指针拷贝，mutablecopy是内容拷贝
- 对于可变的非集合对象，copy，mutablecopy都是内容拷贝
- 对不可变的数组、字典、集合等集合类对象，copy是指针拷贝，mutablecopy是内容拷贝
- 对于可变的数组、字典、集合等集合类对象，copy，mutablecopy都是内容拷贝
- 但是，对于集合对象的内容复制仅仅是对对象本身，但是对象的里面的元素还是指针复制。要想复制整个集合对象，就要用集合深复制的方法，有两种：
- 使用initWithArray:copyItems:方法，将第二个参数设置为YES即可

```
NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];
```
- 将集合对象进行归档（archive）然后解归档（unarchive）：

```
NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];
```

### 18.BAD_ACCESS 在什么情况下出现?
- 访问了已经被销毁的内存空间，就会报出这个错误。
根本原因是有 悬垂指针 没有被释放。

### 19.讲一下 @dynamic 关键字？
- @dynamic 意味着编译器不会帮助我们自动合成 setter 和 getter 方法。我们需要手动实现

### 20.@autoreleasrPool 的释放时机？
- App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。
- 第一个 Observer监视的事件是Entry(即将进入Loop)，其回调内会调用_objc_autoreleasePoolPush()创建自动释放池。其 order是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。
- 第二个 Observer监视了两个事件：BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和_objc_autoreleasePoolPush()释放旧的池并创建新池；Exit(即将退出Loop)时调用_objc_autoreleasePoolPop() 来释放自动释放池。这个Observer的order是2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。
- 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被RunLoop创建好的AutoreleasePool环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。

### 21.retain、release 的实现机制？
- Retain的实现机制。

```
SideTable& table = SideTables()[This];

size_t& refcntStorage = table.refcnts[This];

refcntStorage += SIZE_TABLE_RC_ONE;
```
- Release的实现机制。

```
SideTable& table = SideTables()[This];

size_t& refcntStorage = table.refcnts[This];

refcntStorage -= SIZE_TABLE_RC_ONE;
```
- 二者的实现机制类似，概括讲就是通过第一层 hash 算法，找到 指针变量 所对应的 sideTable。然后再通过一层 hash 算法，找到存储 引用计数 的 size_t，然后对其进行增减操作。retainCount 不是固定的 1，SIZE_TABLE_RC_ONE 是一个宏定义，实际上是一个值为 4 的偏移量。

### 补充：在OC里 alloc 和 retain 语义相反的方法是？
- OC 使用了一种叫做引用计数的机制来管理对象，如果对一个对象使用了alloc、[Mutable]copy，retain，那么你必须使用相应的realease或者autorelease。也可以理解为自己生成的对象，自己持有。非自己生成的对象，自己也能持有。不在需要自己持有的对象时释放。非自己持有的对象无法释放。生成并持有对象<alloc,new,copy,mutableCopy 等>，持有对象<retain>，释放对象
<release>,废弃对象<dealloc>。

### 补充：realease作用是什么和 autorelease 有什么区别？
- realease释放对象，防止内存泄漏；
- 如果插入，该函数若用weak指针持有函数返回值，马上会将其置为nil；为了解决这个问题，用Autorelease，就是用autorelease来代替release，将要释放的对象先放入一个“释放池”，而不是马上释放。

### 22.能不能简述一下 Dealloc 的实现机制？
- Dealloc 调用流程
    * 首先调用 _objc_rootDealloc()
    * 接下来调用 rootDealloc()
    * 这时候会判断是否可以被释放，判断的依据主要有5个，判断是否有以上五种情况
        * NONPointer_ISA
        * weakly_reference
        * has_cxx_dtor
        * has_sidetable_rc
    * 如果有以上五中任意一种，将会调用 object_dispose()方法，做下一步的处理。
    * 如果没有之前五种情况的任意一种，则可以执行释放操作，C函数的 free()。
    * 执行完毕。
- object_dispose() 调用流程。
    * 直接调用 objc_destructInstance()。
    * 之后调用 C函数的 free()。
- objc_destructInstance() 调用流程
    * 先判断 hasCxxDtor，如果有 C++ 的相关内容，要调用 object_cxxDestruct() ，销毁 C++ 相关的内容。
    * 再判断 hasAssocitatedObjects，如果有的话，要调用 object_remove_associations()，销毁关联对象的一系列操作。
    * 然后调用 clearDeallocating()。
    * 执行完毕。
- clearDeallocating() 调用流程
    * 先执行 sideTable_clearDellocating()。
    * 再执行 weak_clear_no_lock,在这一步骤中，会将指向该对象的弱引用指针置为 nil。
    * 接下来执行 table.refcnts.eraser()，从引用计数表中擦除该对象的引用计数。
    * 至此为止，Dealloc 的执行流程结束。

### 23.在 MRC 下如何重写属性的 Setter 和 Getter?
- setter

```
-(void)setBrand:(NSString *)brand{
//如果实例变量指向的地址和参数指向的地址不同
    if (_brand != brand)
    {
        //将实例变量的引用计数减一
        [_brand release];
       //将参数变量的引用计数加一,并赋值给实例变量
        _brand = [brand retain];
    }
}
```
- getter

```
-(NSString *)brand{
    //将实例变量的引用计数加1后,添加自动减1
    //作用,保证调用getter方法取值时可以取到值的同时在完全不需要使用后释放
    return [[_brand retain] autorelease];
}
```
- 重写dealloc

```
//MRC下 手动释放内存 可重写dealloc但不要调用dealloc  会崩溃
-(void)dealloc{
    [_string release];
    //必须最后调用super dealloc
    [super  dealloc];
}
```

### 24.在 Obj-C 中，如何检测内存泄漏？你知道哪些方式？
- 目前我知道的方式有以下几种
    * Memory Leaks
    * Alloctions
    * Analyse
    * Debug Memory Graph
    * MLeaksFinder
- 泄露的内存主要有以下两种：
    * Laek Memory 这种是忘记 Release 操作所泄露的内存。
    * Abandon Memory 这种是循环引用，无法释放掉的内存。

## Runtime
### 1.实例对象的数据结构？

```
struct objc_object {
    isa_t isa;
    //...
}
```
- 本质上 objc_object 的私有属性只有一个 isa 指针。指向 类对象 的内存地址。

### 2.类对象的数据结构？
- 类对象就是 objc_class。

```
struct objc_class : objc_object {
    // Class ISA;
    Class superclass; //父类指针
    cache_t cache;             // formerly cache pointer and vtable 方法缓存
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags 用于获取地址

    class_rw_t *data() { 
        return bits.data(); // &FAST_DATA_MASK 获取地址值
    }
```
- 它的结构相对丰富一些。继承自objc_object结构体，所以包含isa指针
    * isa：指向元类
    * superClass: 指向父类
    * Cache: 方法的缓存列表
    * data: 顾名思义，就是数据。是一个被封装好的 class_rw_t 。

### 3.元类对象的数据结构?
### 4.Obj-C 对象、类的本质是通过什么数据结构实现的？
### 5.Obj-C 中的类信息存放在哪里？
### 6.一个 NSObject 对象占用多少内存空间？
- 受限于内存分配的机制，一个 NSObject对象都会分配 16byte 的内存空间。
- 但是实际上在 64位 下，只使用了 8byte;
- 在32位下，只使用了 4byte
- 一个 NSObject 实例对象成员变量所占的大小，实际上是 8 字节

```
#import <Objc/Runtime>
Class_getInstanceSize([NSObject Class])
```
- 本质是

```
size_t class_getInstanceSize(Class cls)
{
    if (!cls) return 0;
    return cls->alignedInstanceSize();
}
```
- 获取 Obj-C 指针所指向的内存的大小，实际上是16 字节

```
#import <malloc/malloc.h>
malloc_size((__bridge const void *)obj); 
```
- 对象在分配内存空间时，会进行内存对齐，所以在 iOS 中，分配内存空间都是 16字节 的倍数。

### 7.说一下对 class_rw_t 的理解？
- rw代表可读可写。
- ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中：

```
// 可读可写
struct class_rw_t {
    // Be warned that Symbolication knows the layout of this structure.
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro; // 指向只读的结构体,存放类初始信息

    /*
     这三个都是二位数组，是可读可写的，包含了类的初始内容、分类的内容。
     methods中，存储 method_list_t ----> method_t
     二维数组，method_list_t --> method_t
     这三个二位数组中的数据有一部分是从class_ro_t中合并过来的。
     */
    method_array_t methods; // 方法列表（类对象存放对象方法，元类对象存放类方法）
    property_array_t properties; // 属性列表
    protocol_array_t protocols; //协议列表

    Class firstSubclass;
    Class nextSiblingClass;
    
    //...
    }
```

### 8.说一下对 class_ro_t 的理解？
- 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。

```
struct class_ro_t {  
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
    uint32_t reserved;

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;
};
```
- baseMethodList，baseProtocols，ivars，baseProperties三个都是以为数组。

### 9.Category 的实现原理？
- 被添加在了 class_rw_t 的对应结构里。
- Category 实际上是 Category_t 的结构体，在运行时，新添加的方法，都被以倒序插入到原有方法列表的最前面，所以不同的Category，添加了同一个方法，执行的实际上是最后一个。
- 拿方法列表举例，实际上是一个二维的数组。
- Category 如果翻看源码的话就会知道实际上是一个 _catrgory_t 的结构体。
- 例如我们在程序中写了一个 Nsobject+Tools 的分类，那么被编译为 C++ 之后，实际上是：

```
static struct _catrgory_t _OBJC_$_CATEGORY_NSObject_$_Tools __attribute__ ((used,section),("__DATA,__objc__const"))
{
    // name
    // class
    // instance method list
    // class method list
    // protocol list
    // properties
}
```
- Category 在刚刚编译完的时候，和原来的类是分开的，只有在程序运行起来后，通过 Runtime ，Category 和原来的类才会合并到一起。
- mememove，memcpy：这俩方法是位移、复制，简单理解就是原有的方法移动到最后，根根新开辟的控件，把前面的位置留给分类，然后分类中的方法，按照倒序依次插入，可以得出的结论就就是，越晚参与编译的分类，里面的方法才是生效的那个。

### 10.如何给 Category 添加属性？关联对象以什么形式进行存储？
- 关联对象 以哈希表的格式，存储在一个全局的单例中。

```
@interface NSObject (Extension)

@property (nonatomic,copy  ) NSString *name;

@end


@implementation NSObject (Extension)

- (void)setName:(NSString *)name {
    
    objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);
}


- (NSString *)name {
    
    return objc_getAssociatedObject(self,@selector(name));
}

@end
```

### 11.Category 有哪些用途？
- 给系统类添加方法、属性（需要关联对象）。
- 对某个类大量的方法，可以实现按照不同的名称归类。

### 补充：Category的优缺点
### 12.Category 和 Extension 有什么区别？
- extension 在编译期决定，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement 一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如 NSString 添加 extension。
- 但是 category 则完全不一样，它是在运行期决定的。就 category 和 extension 的区别来看，我们可以推导出一个明显的事实，extension 可以添加实例变量，而 category 是无法添加实例变量的
- category 的加载是发生在运行时，加载 category 的过程：
    * 把 category 的实例方法、协议以及属性添加到类上。
    * 把 category 的类方法和协议添加到类的 metaclass 上。
- 其中需要注意的是：
    * category 的方法没有「完全替换掉」原来类已经有的方法，也就是说如果 category 和原来类都有 methodA，那么 category 附加完成之后，类的方法列表里会有两个 methodA。
    * category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category 的方法会「覆盖」掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会返回
- 在类和 category中都可以有+load方法，那么有两个问题：
    * 在类的 +load方法调用的时候，我们可以调用 category 中声明的方法么？答案是：可以调用，因为附加 category 到类的工作会先于 +load方法的执行。
    * 这么些个+load方法，调用顺序是咋样的呢？答案是：+load的执行顺序是先类，后 category，而 category 的+load 执行顺序是根据编译顺序决定的。虽然对于 +load的执行顺序是这样，但是对于「覆盖」掉的方法，则会先找到最后一个编译的 category 里的对应方法。
- 上面讲到的方法覆盖，还有一个补充问题：怎么调用到原来类中被 category 覆盖掉的方法？对于这个问题，我们已经知道 category 其实并不是完全替换掉原来类的同名方法，只是 category 在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：

```
    // 假设被覆盖的方法名叫 printName。
    Class currentClass = [MyClass class];
    MyClass *my = [[MyClass alloc] init];

    if (currentClass) {
        unsigned int methodCount;
        Method *methodList = class_copyMethodList(currentClass, &methodCount);
        IMP lastImp = NULL;
        SEL lastSel = NULL;
        for (NSInteger i = 0; i < methodCount; i++) {
            Method method = methodList[i];
            NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding];
            if ([@"printName" isEqualToString:methodName]) {
                lastImp = method_getImplementation(method);
                lastSel = method_getName(method);
            }
        }
        typedef void (*fn)(id,SEL);

        if (lastImp != NULL) {
            fn f = (fn) lastImp;
            f(my, lastSel);
        }
        free(methodList);
    }
```

### 13.Category 可不可以添加实例对象？为什么？
### 14.Category 在编译过后，是在什么时机与原有的类合并到一起的？
- 程序启动后，通过编译之后，Runtime 会进行初始化，调用 _objc_init。
- 然后会 map_images。
- 接下来调用 map_images_nolock。
- 再然后就是 read_images，这个方法会读取所有的类的相关信息。
- 最后是调用 reMethodizeClass:，这个方法是重新方法化的意思。
- 在 reMethodizeClass: 方法内部会调用 attachCategories: ，这个方法会传入 Class 和 Category ，会将方法列表，协议列表等与原有的类合并。最后加入到 class_rw_t 结构体中。

### 15.说一下 Method Swizzling? 说一下在实际开发中你在什么场景下使用过?
- 简单说就是进行方法交换
- 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。
- 每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP。
- 换方法的几种实现方式
    * 利用 method_exchangeImplementations 交换两个方法的实现
    * 利用 class_replaceMethod替换方法的实现
    * 利用 method_setImplementation 来直接设置某个方法的IMP

![image](https://upload-images.jianshu.io/upload_images/11034989-c18ff3c6e3ab50c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/648)

### 16.如何实现动态添加方法和属性？
### 17.说一下对 isa 指针的理解， 对象的isa 指针指向哪里？isa 指针有哪两种类型？（注意区分不同对象）
- isa 等价于 is kind of
- 实例对象 isa 指向类对象
- 类对象指 isa 向元类对象
- 元类对象的 isa 指向元类的基类
- isa 有两种类型
    * 纯指针，指向内存地址
    * NON_POINTER_ISA，除了内存地址，还存有一些其他信息
- isa源码分析
- 在Runtime源码查看isa_t是共用体。简化结构如下：

```
union isa_t 
{
    Class cls;
    uintptr_t bits;
    # if __arm64__ // arm64架构
#   define ISA_MASK        0x0000000ffffffff8ULL //用来取出33位内存地址使用（&）操作
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
    struct {
        uintptr_t nonpointer        : 1; //0：代表普通指针，1：表示优化过的，可以存储更多信息。
        uintptr_t has_assoc         : 1; //是否设置过关联对象。如果没设置过，释放会更快
        uintptr_t has_cxx_dtor      : 1; //是否有C++的析构函数
        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 内存地址值
        uintptr_t magic             : 6; //用于在调试时分辨对象是否未完成初始化
        uintptr_t weakly_referenced : 1; //是否有被弱引用指向过
        uintptr_t deallocating      : 1; //是否正在释放
        uintptr_t has_sidetable_rc  : 1; //引用计数器是否过大无法存储在ISA中。如果为1，那么引用计数会存储在一个叫做SideTable的类的属性中
        uintptr_t extra_rc          : 19; //里面存储的值是引用计数器减1

#       define RC_ONE   (1ULL<<45)
#       define RC_HALF  (1ULL<<18)
    };

# elif __x86_64__ // arm86架构,模拟器是arm86
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x001f800000000001ULL
#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
    struct {
        uintptr_t nonpointer        : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 8;
#       define RC_ONE   (1ULL<<56)
#       define RC_HALF  (1ULL<<7)
    };

# else
#   error unknown architecture for packed isa
# endif

}
```

### 18.说一下 Runtime 消息解析。
### 19.说一下 Runtime 消息转发。
### 20.如何运用 Runtime 字典转模型？
### 21.如何运用 Runtime 进行模型的归解档？
### 22.在 Obj-C 中为什么叫发消息而不叫函数调用？
- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
- objc_msgSend底层有3大阶段，消息发送（当前类、父类中查找）、动态方法解析、消息转发

### 23.说一下对 runtime 的理解。（主要讲一下消息机制，是对上述的总结）
- OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）
- objc_msgSend底层有3大阶段，消息发送（当前类、父类中查找）、动态方法解析、消息转发

### 24.说一下 Runtime 的方法缓存？存储的形式、数据结构以及查找的过程？
- cache_t增量扩展的哈希表结构。哈希表内部存储的 bucket_t。
- bucket_t 中存储的是 SEL 和 IMP的键值对。
    * 如果是有序方法列表，采用二分查找
    * 如果是无序方法列表，直接遍历查找
- cache_t结构体

```
// 缓存曾经调用过的方法，提高查找速率
struct cache_t {
    struct bucket_t *_buckets; // 散列表
    mask_t _mask; //散列表的长度 - 1
    mask_t _occupied; // 已经缓存的方法数量，散列表的长度使大于已经缓存的数量的。
    //...
}
```

```
struct bucket_t {
    cache_key_t _key; //SEL作为Key @selector()
    IMP _imp; // 函数的内存地址
    //...
}
```
- 散列表查找过程，在objc-cache.mm文件中

```
// 查询散列表，k
bucket_t * cache_t::find(cache_key_t k, id receiver)
{
    assert(k != 0); // 断言

    bucket_t *b = buckets(); // 获取散列表
    mask_t m = mask(); // 散列表长度 - 1
    mask_t begin = cache_hash(k, m); // & 操作
    mask_t i = begin; // 索引值
    do {
        if (b[i].key() == 0  ||  b[i].key() == k) {
            return &b[i];
        }
    } while ((i = cache_next(i, m)) != begin);
    // i 的值最大等于mask,最小等于0。

    // hack
    Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache));
    cache_t::bad_cache(receiver, (SEL)k, cls);
}
```
- 上面是查询散列表函数，其中cache_hash(k, m)是静态内联方法，将传入的key和mask进行&操作返回uint32_t索引值。do-while循环查找过程，当发生冲突cache_next方法将索引值减1。

### 25.是否了解 Type Encoding?
### 26.Objective-C 如何实现多重继承？
- Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现
- 通过组合实现：A和B组合，作为C类的组件
- 通过协议实现：C类实现A和B类的协议方法
- 消息转发实现：forwardInvocation:方法

### 补充：runtime如何通过selector找到对应的IMP地址？
- 每一个类对象中都一个方法列表,方法列表中记录着方法的名称,方法实现,以及参数类型,其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.

### 补充：runtime具体应用
- 利用关联对象（AssociatedObject）给分类添加属性
- 遍历类的所有成员变量（修改textfield的占位文字颜色、字典转模型、自动归档解档）
- 交换方法实现（交换系统的方法）
- 利用消息转发机制解决方法找不到的异常问题
- KVC 字典转模型

### 补充：使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？
- 无论在MRC下还是ARC下均不需要，被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放。

```
1、调用 -release ：引用计数变为零
对象正在被销毁，生命周期即将结束. 
不能再有新的 __weak 弱引用，否则将指向 nil.
调用 [self dealloc]

2、 父类调用 -dealloc 
继承关系中最直接继承的父类再调用 -dealloc 
如果是 MRC 代码 则会手动释放实例变量们（iVars）
继承关系中每一层的父类 都再调用 -dealloc

>3、NSObject 调 -dealloc 
只做一件事：调用 Objective-C runtime 中object_dispose() 方法

>4. 调用 object_dispose()
为 C++ 的实例变量们（iVars）调用 destructors
为 ARC 状态下的 实例变量们（iVars） 调用 -release 
解除所有使用 runtime Associate方法关联的对象 
解除所有 __weak 引用 
调用 free()

```
### 补充：runtime如何实现weak变量的自动置nil？知道SideTable吗？
- runtime 对注册的类会进行布局，对于 weak 修饰的对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。
- 更细一点的回答：
    * 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。
    * 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数，objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
    * 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
- SideTable结构体是负责管理类的引用计数表和weak表
#### 详解：
##### 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。

```
{
    NSObject *obj = [[NSObject alloc] init];
    id __weak obj1 = obj;
}
```
- 当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。

```
// 编译器的模拟代码
 id obj1;
 objc_initWeak(&obj1, obj);
/*obj引用计数变为0，变量作用域结束*/
 objc_destroyWeak(&obj1);
```
- 通过objc_initWeak函数初始化“附有weak修饰符的变量（obj1）”，在变量作用域结束时通过objc_destoryWeak函数释放该变量（obj1）。
##### 添加引用时：objc_initWeak函数会调用objc_storeWeak() 函数，objc_storeWeak()的作用是更新指针指向，创建对应的弱引用表。
- objc_initWeak函数将“附有weak修饰符的变量（obj1）”初始化为0（nil）后，会将“赋值对象”（obj）作为参数，调用objc_storeWeak函数。

```
obj1 = 0；
obj_storeWeak(&obj1, obj);
```
- 也就是说：weak 修饰的指针默认值是 nil （在Objective-C中向nil发送消息是安全的）然后obj_destroyWeak函数将0（nil）作为参数，调用objc_storeWeak函数。

```
objc_storeWeak(&obj1, 0);
```
- 前面的源代码与下列源代码相同。

```
// 编译器的模拟代码
id obj1;
obj1 = 0;
objc_storeWeak(&obj1, obj);
/* ... obj的引用计数变为0，被置nil ... */
objc_storeWeak(&obj1, 0);
```
- objc_storeWeak函数把第二个参数的赋值对象（obj）的内存地址作为键值，将第一个参数__weak修饰的属性变量（obj1）的内存地址注册到weak表中。如果第二个参数（obj）为0（nil），那么把变量（obj1）的地址从weak表中删除。由于一个对象可同时赋值给多个附有__weak修饰符的变量中，所以对于一个键值，可注册多个变量的地址。可以把objc_storeWeak(&a,b)理解为：objc_storeWeak(value,key)，并且当key变nil，将value置nil。在b非nil时，a和b指向同一个内存地址，在b变nil时，a变nil。此时向a发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。
##### 释放时,调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。
- 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下：
    * 调用objc_release
    * 因为对象的引用计数为0，所以执行dealloc
    * 在dealloc中，调用了_objc_rootDealloc函数
    * 在_objc_rootDealloc中，调用了object_dispose函数
    * 调用objc_destructInstance
    * 最后调用objc_clear_deallocating
- 对象被释放时调用的objc_clear_deallocating函数:
    * 从weak表中获取废弃对象的地址为键值的记录
    * 将包含在记录中的所有附有weak修饰符变量的地址，赋值为nil
    * 将weak表中该记录删除
    * 从引用计数表中删除废弃对象的地址为键值的记录
- 其实Weak表是一个hash（哈希）表，Key是weak所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象指针的地址）数组。

## Runloop
### 补充：RunLoop概念
- RunLoop是通过内部维护的事件循环(Event Loop)来对事件/消息进行管理的一个对象。
    * 没有消息处理时，休眠已避免资源占用，由用户态切换到内核态(CPU-内核态和用户态)
    * 有消息需要处理时，立刻被唤醒，由内核态切换到用户态
- 为什么main函数不会退出？

```
int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```
- UIApplicationMain内部默认开启了主线程的RunLoop，并执行了一段无限循环的代码（不是简单的for循环或while循环）

```
//无限循环代码模式(伪代码)
int main(int argc, char * argv[]) {        
    BOOL running = YES;
    do {
        // 执行各种任务，处理各种事件
        // ......
    } while (running);

    return 0;
}
```
- UIApplicationMain函数一直没有返回，而是不断地接收处理消息以及等待休眠，所以运行程序之后会保持持续运行状态。

### 内核态和用户态
- CPU的两种工作状态：内核态和用户态
- 内核态
    * 系统中既有操作系统的程序，也由普通用户的程序。为了安全和稳定性操作系统的程序不能随便访问,这就是内核态
    * 内核态可以使用所有的硬件资源
- 用户态
    * 不能直接使用系统资源，也不能改变CPU的工作状态，并且只能访问这个用户程序自己的存储空间

### 补充：RunLoop的数据结构
- NSRunLoop(Foundation)是CFRunLoop(CoreFoundation)的封装，提供了面向对象的API
RunLoop 相关的主要涉及五个类：
    * CFRunLoop：RunLoop对象
    * CFRunLoopMode：运行模式
    * CFRunLoopSource：输入源/事件源
    * CFRunLoopTimer：定时源
    * CFRunLoopObserver：观察者
- CFRunLoop
    * 由pthread(线程对象，说明RunLoop和线程是一一对应的)、currentMode(当前所处的运行模式)、modes(多个运行模式的集合)、commonModes(模式名称字符串集合)、commonModelItems(Observer,Timer,Source集合)构成
- CFRunLoopMode
    * 由name、source0、source1、observers、timers构成
- CFRunLoopSource
    * 分为source0和source1两种
    * source0:即非基于port的，也就是用户触发的事件。需要手动唤醒线程，将当前线程从内核态切换到用户态
    * source1:基于port的，包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒RunLoop，接收分发系统事件。具备唤醒线程的能力
- CFRunLoopTimer
    * 基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒RunLoop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。
- CFRunLoopObserver
    * 监听以下时间点:CFRunLoopActivity
    * kCFRunLoopEntry：RunLoop准备启动
    * kCFRunLoopBeforeTimers ：RunLoop将要处理一些Timer相关事件
    * kCFRunLoopBeforeSources ：RunLoop将要处理一些Source事件
    * kCFRunLoopBeforeWaiting ：RunLoop将要进行休眠状态,即将由用户态切换到内核态
    * kCFRunLoopAfterWaiting：RunLoop被唤醒，即从内核态切换到用户态后
    * kCFRunLoopExit：RunLoop退出
    * kCFRunLoopAllActivities：监听所有状态
- 各数据结构之间的联系
    * 线程和RunLoop一一对应， RunLoop和Mode是一对多的，Mode和source、timer、observer也是一对多的
    * 一个RunLoop对象中包含若干个运行模式。而每一个运行模式下有3包含若干个输入源、定时源、观察者
    * 每次RunLoop启动时，只能指定其中一个运行模式，这个运行模式被称为当前运行模式
    * 如果需要切换运行模式，只能退出当前Loop，再重新制定一个运行模式进入，这样做主要是为了分隔开不同组的输入源、定时源、观察者，让其互不影响

### 1.Runloop 和线程的关系？
- 线程和RunLoop是一一对应的,其映射关系是保存在一个全局的 Dictionary 里
- 自己创建的线程默认是没有开启RunLoop的
- 怎么创建一个常驻线程？
    * 为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）
    * 向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）
    * 启动该RunLoop

```
@autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
        
    }
```
- 输出下边代码的执行顺序

```
NSLog(@"1");

dispatch_async(dispatch_get_global_queue(0, 0), ^{
    
    NSLog(@"2");

    [self performSelector:@selector(test) withObject:nil afterDelay:10];
    
    NSLog(@"3");
});

NSLog(@"4");

- (void)test
{
    
    NSLog(@"5");
}
```
- 答案是1423，test方法并不会执行。
原因是如果是带afterDelay的延时函数，会在内部创建一个 NSTimer，然后添加到当前线程的RunLoop中。也就是如果当前线程没有开启RunLoop，该方法会失效。
那么我们改成:

```
dispatch_async(dispatch_get_global_queue(0, 0), ^{
        
        NSLog(@"2");
        
        [[NSRunLoop currentRunLoop] run];
        
        [self performSelector:@selector(test) withObject:nil afterDelay:10];
  
        NSLog(@"3");
    });
```
- 然而test方法依然不执行。
原因是如果RunLoop的mode中一个item都没有，RunLoop会退出。即在调用RunLoop的run方法后，由于其mode中没有添加任何item去维持RunLoop的时间循环，RunLoop随即还是会退出。
所以我们自己启动RunLoop，一定要在添加item后

```
dispatch_async(dispatch_get_global_queue(0, 0), ^{
        
        NSLog(@"2");
        
        [self performSelector:@selector(test) withObject:nil afterDelay:10];
        
        [[NSRunLoop currentRunLoop] run];
  
        NSLog(@"3");
    });
```
- 怎样保证子线程数据回来更新UI的时候不打断用户的滑动操作？
    * 当我们在子请求数据的同时滑动浏览当前页面，如果数据请求成功要切回主线程更新UI，那么就会影响当前正在滑动的体验。
    * 我们就可以将更新UI事件放在主线程的NSDefaultRunLoopMode上执行即可，这样就会等用户不再滑动页面，主线程RunLoop由UITrackingRunLoopMode切换到NSDefaultRunLoopMode时再去更新UI

```
[self performSelectorOnMainThread:@selector(reloadData) withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]];
```

### 2.讲一下 Runloop 的 Mode?(越详细越好)
- 关于Mode首先要知道一个RunLoop 对象中可能包含多个Mode，且每次调用 RunLoop 的主函数时，只能指定其中一个Mode(CurrentMode)。切换 Mode，需要重新指定一个Mode。主要是为了分隔开不同的Source、Timer、Observer，让它们之间互不影响。
- 当RunLoop运行在Mode1上时，是无法接受处理Mode2或Mode3上的Source、Timer、Observer事件的总，共是有五种CFRunLoopMode:
    * kCFRunLoopDefaultMode：默认模式，主线程是在这个运行模式下运行
    * UITrackingRunLoopMode：跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）
    * UIInitializationRunLoopMode：在刚启动App时第进入的第一个 Mode，启动完成后就不再使用
    * GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到
    * kCFRunLoopCommonModes：伪模式，不是一种真正的运行模式，是同步Source/Timer/Observer到多个Mode中的一种解决方案

### 3.讲一下 Observer ？（Mode中的重点）

```
typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) {
    kCFRunLoopEntry         = (1UL << 0), // 即将进入Loop
    kCFRunLoopBeforeTimers  = (1UL << 1), // 即将处理 Timer
    kCFRunLoopBeforeSources = (1UL << 2), // 即将处理 Source
    kCFRunLoopBeforeWaiting = (1UL << 5), // 即将进入休眠
    kCFRunLoopAfterWaiting  = (1UL << 6), // 刚从休眠中唤醒
    kCFRunLoopExit          = (1UL << 7), // 即将退出Loop
};
```

### 4.讲一下 Runloop 的内部实现逻辑？（运行过程）

![image](https://upload-images.jianshu.io/upload_images/1782258-2f8dd696ecbf0275.png?imageMogr2/auto-orient/strip|imageView2/2/w/572)

- 对于RunLoop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。RunLoop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。
- RunLoop通过mach_msg()函数接收、发送消息。它的本质是调用函数mach_msg_trap()，相当于是一个系统调用，会触发内核状态切换。在用户态调用 mach_msg_trap()时会切换到内核态；内核态中内核实现的mach_msg()函数会完成实际的工作。
- 即基于port的source1，监听端口，端口有消息就会触发回调；而source0，要手动标记为待处理和手动唤醒RunLoop
- Mach消息发送机制，大致逻辑为：
    * 1.通知观察者 RunLoop 即将启动。
    * 2.通知观察者即将要处理Timer事件。
    * 3.通知观察者即将要处理source0事件。
    * 4.处理source0事件。
    * 5.如果基于端口的源(Source1)准备好并处于等待状态，进入步骤9。
    * 6.通知观察者线程即将进入休眠状态。
    * 7.将线程置于休眠状态，由用户态切换到内核态，直到下面的任一事件发生才唤醒线程。
        * 一个基于 port 的Source1 的事件(图里应该是source0)。
        * 一个 Timer 到时间了。
        * RunLoop 自身的超时时间到了。
        * 被其他调用者手动唤醒。
    * 8.通知观察者线程将被唤醒。
    * 9.处理唤醒时收到的事件。
        * 如果用户定义的定时器启动，处理定时器事件并重启RunLoop。进入步骤2。
        * 如果输入源启动，传递相应的消息。
        * 如果RunLoop被显示唤醒而且时间还没超时，重启RunLoop。进入步骤2
    * 10.通知观察者RunLoop结束。

### 补充：RunLoop实战使用
#### NSTimer的使用
#### ImageView推迟显示
- 当界面中含有UITableView，而且每个UITableViewCell里边都有图片。这时候当我们滚动UITableView的时候，如果有一堆的图片需要显示，那么可能会出现卡顿的现象。
- 我们应该推迟图片的显示，也就是ImageView推迟显示图片。有两种方法：
    * 监听UIScrollView的滚动
        * 因为UITableView继承自UIScrollView，所以我们可以通过监听UIScrollView的滚动，实现UIScrollView相关delegate即可。
    * 利用PerformSelector设置当前线程的RunLoop的运行模式
        * 利用performSelector方法为UIImageView调用setImage:方法，并利用inModes将其设置为RunLoop下NSDefaultRunLoopMode运行模式。

```
[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@"tupian"] afterDelay:4.0 inModes:NSDefaultRunLoopMode];
```

#### 后台常驻线程

### 5.你所知的哪些三方框架使用了 Runloop?（AFNetworking、Texture 等）
- AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
```
- RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。

```
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
```
- 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。

### 6.autoreleasePool 在何时被释放？
- App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。
- 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是 -2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。
- 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。
- 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。

### 7.解释一下 事件响应 的过程？
- 响应者：响应者为响应事件的UIResponder子类对象，如UIButton、UIView等；
- 响应链：响应链是由链接在一起的响应者（UIResponse子类）组成的。
- 事件传递：获得响应链后，将事件由第一响应者往application传递的过程；
- 事件的传递过程

![image](https://upload-images.jianshu.io/upload_images/4986510-8e8307e475ec486f.png)

- 苹果基于mach port注册了一个Source1用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。
- 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个Source1就会触发回调，并调用_UIApplicationHandleEventQueue()进行应用内部的分发。
- _UIApplicationHandleEventQueue() 会把IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给UIWindow等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。
- 其实说白了就是：当iOS程序发生触摸事件后，系统会利用Runloop将事件加入到UIApplication的任务队列中；UIApplication分发触摸事件到UIWindow，然后UIWindow依次向下分发给UIView；UIView调用hitTest:withEvent:方法看看自己能否处理事件，以及触摸点是否在自己上面；如果满足条件，就遍历UIView上的子控件。重复上面的动作；直到找到最顶层的一个满足条件（既能处理触摸事件，触摸点又在上面）的子控件，此子控件就是我们需要找到的第一响应者。

```
// 此方法返回的View是本次点击事件需要的最佳View
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event

// 判断一个点是否落在范围内
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event
//返回最适合处理事件的视图，最好在父视图中指定子视图的响应

// 因为所有的视图类都是继承BaseView
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
   // 1.判断当前控件能否接收事件
   if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha <= 0.01) return nil;
   // 2. 判断点在不在当前控件
   if ([self pointInside:point withEvent:event] == NO) return nil;
   // 3.从后往前遍历自己的子控件
   NSInteger count = self.subviews.count;
   for (NSInteger i = count - 1; i >= 0; i--) {
       UIView *childView = self.subviews[I];
       // 把当前控件上的坐标系转换成子控件上的坐标系
    CGPoint childP = [self convertPoint:point toView:childView];
      UIView *fitView = [childView hitTest:childP withEvent:event];
       if (fitView) { // 寻找到最合适的view
           return fitView;
       }
   }
   // 循环结束,表示没有比自己更合适的view
   return self;
   
}
```

### 8.解释一下 手势识别 的过程？
- 当 _UIApplicationHandleEventQueue()识别了一个手势时，其首先会调用Cancel将当前的touchesBegin/Move/End 系列回调打断。随后系统将对应的UIGestureRecognizer 标记为待处理。
- 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的GestureRecognizer，并执行GestureRecognizer 的回调。
- 当有 UIGestureRecognizer的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

### 9.解释一下 GCD 在 Runloop 中的使用？
### 10.解释一下 NSTimer，以及 NSTimer 的循环引用。
- NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop 为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。
- 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。
- CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动 TableView 时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop。

### 补充：NStimer准吗？谈谈你的看法？如果不准该怎样实现一个精确的NSTimer?
#### 不准
#### 不准的原因如下：
- NSTimer加在main runloop中，模式是NSDefaultRunLoopMode，main负责所有主线程事件，例如UI界面的操作，复杂的运算，这样在同一个runloop中timer就会产生阻塞。
- 模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。
- 当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个ScrollView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到NSTimer不准的情况。（DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。）
#### 解决方法：
- 方法一：
    * 在主线程中进行NSTimer操作，但是将NSTimer实例加到mainrunloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。
```
self.timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];

```
    * 在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；
```
- (void)timerMethod2 { 
 NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil];
  [thread start];
  } 
- (void)newThread 
 { 
 @autoreleasepool 
 {
 [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES];
 [[NSRunLoop currentRunLoop] run]; 
 } 
 }
 
```
- 总结：
    * 一开始的时候系统就为我们将主线程的main runloop隐式的启动了。
    * 在创建线程的时候，可以主动获取当前线程的runloop。每个子线程对应一个runloop
 
- 方法二：    
    * 使用mach内核级的函数可以使用mach_absolute_time()获取到CPU的tickcount的计数值，可以通过”mach_timebase_info”函数获取到纳秒级的精确度 。然后使用mach_wait_until(uint64_t deadline)函数，直到指定的时间之后，就可以执行指定任务了。

- 方法三：
    * 直接使用GCD替代！

### 11.AFNetworking 中如何运用 Runloop?
- AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：

```
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
```
- RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。

```
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
```
- 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。

### 12.PerformSelector 的实现原理？
- 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个Timer并添加到当前线程的 RunLoop 中。所以如果当前线程没有RunLoop，则这个方法会失效。
- 当调用 performSelector:onThread:时，实际上其会创建一个 Timer加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。

### 13.利用 runloop 解释一下页面的渲染的过程？
- 当我们调用 [UIView setNeedsDisplay]时，这时会调用当前 View.layer 的 [view.layer setNeedsDisplay]方法。
- 这等于给当前的layer打上了一个脏标记，而此时并没有直接进行绘制工作。而是会到当前的Runloop即将休眠，也就是 beforeWaiting 时才会进行绘制工作。
- 紧接着会调用 [CALayer display]，进入到真正绘制的工作。CALayer层会判断自己的 delegate有没有实现异步绘制的代理方法displayer:，这个代理方法是异步绘制的入口，如果没有实现这个方法，那么会继续进行系统绘制的流程，然后绘制结束。
- CALayer 内部会创建一个 Backing Store，用来获取图形上下文。接下来会判断这个 layer 是否有 delegate。
- 如果有的话，会调用 [layer.delegate drawLayer:inContext:]，并且会返回给我们 [UIView DrawRect:] 的回调，让我们在系统绘制的基础之上再做一些事情。
- 如果没有 delegate，那么会调用 [CALayer drawInContext:]。
- 以上两个分支，最终 CALayer 都会将位图提交到 Backing Store，最后提交给 GPU。
- 至此绘制的过程结束。

### 14.如何使用 Runloop 实现一个常驻线程？这种线程一般有什么作用？
* 为当前线程开启一个RunLoop（第一次调用 [NSRunLoop currentRunLoop]方法时实际是会先去创建一个RunLoop）
* 向当前RunLoop中添加一个Port/Source等维持RunLoop的事件循环（如果RunLoop的mode中一个item都没有，RunLoop会退出）
* 启动该RunLoop

```
@autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
        
    }
```

### 补充：NSThread+runloop实现常驻线程
- NSThread在实际开发中比较常用到的场景就是去实现常驻线程。
- 由于每次开辟子线程都会消耗cpu，在需要频繁使用子线程的情况下，频繁开辟子线程会消耗大量的cpu，而且创建线程都是任务执行完成之后也就释放了，不能再次利用，那么如何创建一个线程可以让它可以再次工作呢？也就是创建一个常驻线程。
- 首先常驻线程既然是常驻，那么我们可以用GCD实现一个单例来保存NSThread

```
+ (NSThread *)shareThread {
    
    static NSThread *shareThread = nil;
    
    static dispatch_once_t oncePredicate;
    
    dispatch_once(&oncePredicate, ^{
        
        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest) object:nil];

        [shareThread setName:@"threadTest"];
        
        [shareThread start];
    });
    
    return shareThread;
}
```
- 可以用runloop来让线程常驻

```
+ (NSThread *)shareThread {
    
    static NSThread *shareThread = nil;
    
    static dispatch_once_t oncePredicate;
    
    dispatch_once(&oncePredicate, ^{
        
        shareThread = [[NSThread alloc] initWithTarget:self selector:@selector(threadTest2) object:nil];
        
        [shareThread setName:@"threadTest"];
        
        [shareThread start];
    });
    
    return shareThread;
}

+ (void)threadTest
{
    @autoreleasepool {
        
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        
        [runLoop run];
    }
}
```

### 15.为什么 NSTimer 有时候不好使？（不同类型的Mode）

- 因为创建的 NSTimer 默认是被加入到了 defaultMode，所以当 Runloop 的 Mode 变化时，当前的 NSTimer 就不会工作了。

### 补充：滑动tableView时，定时器还会生效吗？

- 默认情况下RunLoop运行在kCFRunLoopDefaultMode下，而当滑动tableVie时，RunLoop切换到UITrackingRunLoopMode，而Timer是在kCFRunLoopDefaultMode下的，就无法接受处理Timer的事件。
- 解决：把Timer添加到UITrackingRunLoopMode上并不能解决问题，因为这样在默认情况下就无法接受定时器事件了。所以我们需要把Timer同时添加到UITrackingRunLoopMode和kCFRunLoopDefaultMode上。
- 那么如何把timer同时添加到多个mode上呢？就要用到NSRunLoopCommonModes了

```
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
```
- Timer就被添加到多个mode上，这样即使RunLoop由kCFRunLoopDefaultMode切换到UITrackingRunLoopMode下，也不会影响接收Timer事件

### 16.PerformSelector:afterDelay:这个方法在子线程中是否起作用？为什么？怎么解决？
- 不起作用，子线程默认没有 Runloop，也就没有 Timer。
- 解决的办法是可以使用 GCD 来实现：Dispatch_after

### 17.什么是异步绘制？
- 异步绘制，就是可以在子线程把需要绘制的图形，提前在子线程处理好。将准备好的图像数据直接返给主线程使用，这样可以降低主线程的压力。
- 异步绘制的过程
    * 要通过系统的 [view.delegate displayLayer:] 这个入口来实现异步绘制。
        * 代理负责生成对应的 Bitmap
        * 设置该 Bitmap 为 layer.contents 属性的值。

### 18.如何检测 App 运行过程中是否卡顿？

## UIKit
### 1.UIView 和 CALayer 是什么关系？
- 首先从继承关系来分析两者：UIView : UIResponder，CALayer : NSObject。
#### UIView
- UIView 响应事件，UIView 继承 UIResponder，而 UIResponder 是响应者对象，所以UIView 响应事件
- 实现了如下 API，所以继承自 UIResponder 的都具有响应事件的能力：

```
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesMoved:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEnded:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesCancelled:(NSSet<UITouch *> *)touches withEvent:(nullable UIEvent *)event;
- (void)touchesEstimatedPropertiesUpdated:(NSSet<UITouch *> *)touches NS_AVAILABLE_IOS(9_1);
```
- 并且 UIView 提供了以下两个方法，来进行 iOS 中的事件的响应及传递（响应者链）：

```
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;
- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event;  
```
#### CALayer 绘制 UI
- CALayer 绘制 UI：CALayer 没有继承自 UIResponder，所以CALayer不具备响应处理事件的能力。CALayer 是 QuartzCore中的类，是一个比较底层的用来绘制内容的类。
#### UIView 对 CALayer 封装属性
- UIView 中持有一个 layer 对象，同时这个 layer 对象 delegate，UIView 和 CALayer 协同工作。
- 平时我们对 UIView 设置 frame、center、bounds 等位置信息，其实都是UIView对CALayer进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性，UIView就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。
- Frame 属性主要是依赖：bounds、anchorPoint、transform、和position。
- 我们这主要说一下 anchorPoint 和position如何影响 Frame 的：anchorPoint锚点是相对于当前Layer的一个点，position 是 Layer 中 anchorPoint 锚点在 superLayer 中的点，即 position 是由 anchorPoint 来确认的。
- 这里有几个通用的公式：

```
position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  
position.y = frame.origin.y + anchorPoint.y * bounds.size.height；
  
frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；    
```
- 故有：
    * position 是 layer 中的 anchorPoint 在 superLayer 中的位置坐标。
    * 单独修改 position 与 anchorPoint 中任何一个属性都不影响另一个属性。
#### UIView 是 CALayer 的代理
- UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 行的数据，例如动画和绘制。

```
//绘制相关
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;

//动画相关
- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;
```
#### 动画相关
- Layer 中很多属性都是 animatable 的，这就意味着修改这些属性会产生隐式动画。当是如果修改 UIView主Layer的话，此时隐式动画会失效，因为：UIView 默认情况下禁止了 layer 动画，但是在 animation block 中又重新启用了它们。
- 当一个 animatable 属性变化时，Layer 会询问代理方法该如何处理这个动画，即需要在代理方法中返回合适的 CAAction 对象。
- 属性改变时 layer会向view请求一个动作，而一般情况下 view 将返回一个NSNull，只有当属性改变发生在动画 block 中时，view 才会返回实际的动作。
#### 绘制相关
- CALayer 在屏幕上绘制东西是因为 CALayer 内部有一个 contents (CGImage)的属性，contents 也被称为寄宿图。绘制相关的 API 如下：

```
- (void)displayLayer:(CALayer *)layer;
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;

- (void)drawRect:(CGRect)rect
```
#### drawRect 方法实现
- 平时为自定义View添加空间或者在上下文画图都会使用到这个函数，但是如果当我们实现了这个方法的时候，这个时候会生成一张寄宿图，这个寄宿图的尺寸是 layer 的宽 * 高*contentsScale，其实算出来的是有多少像素。然后每个像素占用4个字节，总共消耗的内存大小为：宽 * 高 * contentsScale * 4 字节。
- 这里跟我们图片显示是一个道理：一张图片需要解压成位图才能显示到屏幕上，图片的颜色空间一般是RGBA，每个像素点需要包含RGBA四个信息，所以一张图片解压成位图需要占用内存大小为：像素宽 * 像素高 * 4 个字节。（PS：将图片解压成位图是比较耗时的，这就是为什么通常会在子线程解压图片，然后再到主线程中显示，避免卡主主线程）
- 所以在使用 drawRect方法来实现功能之前，需要看看是否有替代方案，避免产生寄宿图增加程序的内存，使用 CAShapeLayer 来绘制是一个不错的方案。
#### UILabel 绘制文字占用内存的情况
- 这里讲到绘制占用内存的情况，我们简单来了解下 Label 绘制文字占用的内存情况，实例代码如下：

```
//绘制一个全屏的 Label
        UILabel *label1 = [[UILabel alloc] initWithFrame:self.view.bounds];
    label1.text = @"11111";
    [self.view addSubview:label1];
    
    UILabel *label2 = [[UILabel alloc] initWithFrame:self.view.bounds];
    label2.text = @"😀11111";
    [self.view addSubview:label2];
```
- 绘制一个全屏的 Label，按理由需要占用内存：宽 * 高 * 4，iPhone 6SP 像素为：1242 * 2208，全屏差不多是占用 10 M 左右，但是 label1 大概会占用 3 M左右， label2 会占用 10 M左右；其实这里是因为如果使用黑白位图，苹果会优化颜色空间，这里每个像素就只会占用 1 个字节，比 4 字节节省 75% 的空间。
#### 总结
- 如果确定是不需要交互的，可以将 UIView 替换成 CALayer，来省去UIView封装带来的损耗，AsyncDisplayKit 库利用 ASDisplayNode 来替代UIView来节省资源。

### 2.Bounds 和 Frame 的区别?
#### frame
- 是每个view必备的属性，代表的是当前视图的位置和大小，没有设置他，当前视图是看不到的。
- 在iOS坐标系中以左上角为坐标原点，往右为X正方向，往下是Y正方向
- frame中的位置是以父视图的坐标系为标准来确定当前视图的位置
- 同样的默认情况下，本视图的左上角就是子视图的坐标原点
- 更改frame中位置，则当前视图的位置会发生改变
- 更改frame的大小，则当前视图以当前视图的左上角为基准的进行大小的修改
#### bounds
- 是每个View都有的属性，这个属性我们一般不进行设置，他同样代表位置和大小；
每个视图都有自己的坐标系，且这个坐标系默认以自身的左上角为坐标原点，所有子视图以这个坐标系的原点为基准点。
- bounds的位置代表的是子视图看待当前视图左上角的位置;bounds的大小代表当前视图的大小；
- 更改bounds中的位置对于当前视图没有影响，相当于更改了当前视图的坐标系，对于子视图来说当前视图的左上角已经不再是(0,0), 而是改变后的坐标，坐标系改了，那么所有子视图的位置也会跟着改变
- 更改bounds的大小，bounds的大小代表当前视图的长和宽，修改长宽后，中心点继续保持不变, 长宽进行改变；通过bounds修改长宽看起来就像是以中心点为基准点对长宽两边同时进行缩放；
#### frame和bounds

![image](https://upload-images.jianshu.io/upload_images/1196725-188e8cb0157b3cee.png?imageMogr2/auto-orient/strip|imageView2/2/w/779)

- 因为是View A是顶层视图，所以其实相当于覆盖在框架上，因此位置从父视图的（0，0）开始，大小为550*400
- 默认情况下，本视图的坐标系是没有发生改变的即当前视图(view A)的左上角就是所有子视图的原点，大小就是当前视图的大小.
- 因为View B是ViewA的子视图，所以ViewB的frame位置需要以View A的左上角为参照，因此位置为(200, 100), 大小为200*250
- bounds在默认情况下本视图的坐标系是没有发生改变的即当前视图(viewB)的左上角就是当前视图所有子视图的原点.

![image](https://upload-images.jianshu.io/upload_images/1196725-2844fc5a83246fca.png?imageMogr2/auto-orient/strip|imageView2/2/w/893)

- 在上一个例子的基础上，我们更改了view A的bounds后，view B看待View A的左上角就已经发生改变了；这个时候我们看待View A的左上角就不是坐标原点了，而是我们通过bounds设置后的坐标，如图也就是(0, 100);
在View B的frame没有保存不变的基础上，我们View B的位置向上移动了100

![image](https://upload-images.jianshu.io/upload_images/1196725-ed92b2bc1640b1bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/935)

#### 总结
- frame不管对于位置还是大小，改变的都是自己本身
- frame的位置是以父视图的坐标系为参照，从而确定当前视图在父视图中的位置
- frame的大小改变时，当前视图的左上角位置不会发生改变，只是大小发生改变
- bounds改变位置时，改变的是子视图的位置，自身没有影响；其实就是改变了本身的坐标系原点，默认本身坐标系的原点是左上角
- bounds的大小改变时，当前视图的中心点不会发生改变，当前视图的大小发生改变，看起来效果就想缩放一样

### 3.TableViewCell 如何根据 UILabel 内容长度自动调整高度?
### 4.LoadView方法了解吗？
### 5.UIButton 的父类是什么？UILabel 的父类又是什么？
### 6.实现一个控件，可以浮在任意界面的上层并支持拖动？
### 7.说一下控制器 View 的生命周期，一旦收到内存警告会如何处理？

![image](https://upload-images.jianshu.io/upload_images/1434508-370daf660ff330e4.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200)
- Phone下每个app可用的内存是被限制的，如果一个app使用的内存超过20M，则系统会向该app发送Memory Warning消息。
- 当应用程序占用了大约20MB内存时，iphone开始发出内存警告。当应用程序所占内存大约为30MB时，iphone OS会关闭应用程序。收到此消息后，app必须正确处理，否则可能出错或者出现内存泄露。app收到Memory Warning后会调用：
    * UIApplication::didReceiveMemoryWarning
    * UIApplicationDelegate::applicationDidReceiveMemoryWarning
- 然后调用当前所有的viewController进行处理。因此处理的主要工作是在viewController。
- 我们知道，创建viewcontroller时，执行顺序是loadview -> viewDidLoad。
- 当收到内存警告时，如果viewcontroller未显示（在后台），会执行didReceiveMemoryWarning -> viewDidUnLoad；如果viewcontroller当前正在显示（在前台），则只执行didReceiveMemoryWarning。
当重新显示该viewController时，执行过viewDidUnLoad的viewcontroller（即原来在后台）会重新调用loadview -> viewDidLoad。
- 重载didReceiveMemoryWarning时，一定调用这个函数的super实现来允许父类（一般是UIVIewController）释放self.view。self.view释放之后，会调用下面的viewDidUnload函数.也就是说，尽管self.view是被处理了，但是outlets的变量因为被retain过，所以不会被释放，为了解决这个问题，就需要在viewDidUnload中释放这些retain过的outlets变量。通常controller会保存nib文件建立的views的引用，但是也可能会保存着loadView函数创建的对象的引用。

#### 生命周期
- loadView： 加载view
- viewDidLoad： view加载完毕
- viewWillAppear： 控制器的view将要显示
- viewWillLayoutSubviews：控制器的view将要布局子控件
- viewDidLayoutSubviews：控制器的view布局子控件完成
- viewDidAppear: 控制器的view完全显示
- viewWillDisappear： 控制器的view即将消失的时候
- viewDidDisappear： 控制器的view完全消失的时候
- 控制器的view是延迟加载的：创建控制器并不一定会创建控制器的view，等用到时再加载
- 补充：
    * 如果a控制器push到b控制器,那么a和b的View都不会被销毁,因为它的控制器还存在，有一个强引用引用着它(除非内存警告会销毁a的View)如果b控制器pop到a控制器,那么b的View会被销毁a和b都在导航控制器的栈里被管理,就是个数组
    * 此时如果你打印会发现方法的调用顺序是:
        * 控制器b的View的viewDidLoad
        * 控制器b的View的viewWillAppear
        * 控制器a的View的viewDidDisappear
#### 内存警告的处理
- 两个内存警告
    * 当application接收到内存警告的时候，会先通知它的代理，代理在接收到内存警告的时候会调用applicationDidReceiveMemoryWarning方法
    * 之后代理会通知它的window,window会通知它的根控制器，根控制器会通知它的子控制器,内存警告是由上往下一层一层往下传的,最后传给控制器View,控制器View会调用它的didReceiveMemoryWarning方法
- 内存警告的处理

![image](https://upload-images.jianshu.io/upload_images/6950351-dd67f46bce6d4073.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200)

- 

### 8.如何暂停一个 UIView 中正在播放的动画？暂停后如何恢复？
### 9.说一下 UIView 的生命周期？
- viewDidLoad
- viewWillAppear
- viewWillLayoutSubviews
- viewDidLayoutSubviews
- viewDidAppear
- viewWillDisappear
- viewDidDisappear

### 10.UIViewController 的生命周期？
### 11.如何以通用的方法找到当前显示的ViewController?
### 12.setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？
### 补充：多个类型的cell如何优雅加载？
#### 题解一
- 一种就是常见的if else，但是如果修改的话，就会代码很多，一旦修改，就会修改太多，太繁琐了；

#### 题解二
- modle，根据model来对应cell，cell面向model开发，一般都是一个类型的数据（model）对应一种类型的cell，所以类型是固定的，所以我们用一个枚举来定义所有类型的cell，cellType或者model就知道如何去处理相应的cell了；但是会有重复的操作和数据处理。

#### 题解三
- Model：对 Cell 类型进行更高层次的抽象，将model抽出相同的数据，定义BaseModel，通过继承的方式，分为数据类型 DataModel 和非数据类型 SpecialModel 两种，进行定义，通过多层继承可进一步避免重复定义变量。将非数据类型也定义为类型的好处是，将这部分 UI 控制逻辑下沉到 Model 创建之处：网络/持久化数据 Entity -> UIModel，在这个过程中，创建额外的非数据型UIModel，只要数据创建好，后期就不用再理相关逻辑了。
- Cell：定义BaseCell, Cell子类型通过运行时动态创建，UI显示通过CardBaseView作为容器，加载到Cell 的ContentView上。
- 通过一系列解耦，将变化分散到两端：Model 和 View；
- View：因为是View放置在Cell的ContentView上，因此，View的Delegate是Cell，Cell通过消息转发实现回调，避免Cell实现中手写回调中转。

## Foundation
### 1.`Bounds` 和 `Frame` 的区别?
#### frame
- 是每个view必备的属性，代表的是当前视图的位置和大小，没有设置他，当前视图是看不到的。
- 在iOS坐标系中以左上角为坐标原点，往右为X正方向，往下是Y正方向
- frame中的位置是以父视图的坐标系为标准来确定当前视图的位置
- 同样的默认情况下，本视图的左上角就是子视图的坐标原点
- 更改frame中位置，则当前视图的位置会发生改变
- 更改frame的大小，则当前视图以当前视图的左上角为基准的进行大小的修改
#### bounds
- 是每个View都有的属性，这个属性我们一般不进行设置，他同样代表位置和大小；
每个视图都有自己的坐标系，且这个坐标系默认以自身的左上角为坐标原点，所有子视图以这个坐标系的原点为基准点。
- bounds的位置代表的是子视图看待当前视图左上角的位置;bounds的大小代表当前视图的大小；
- 更改bounds中的位置对于当前视图没有影响，相当于更改了当前视图的坐标系，对于子视图来说当前视图的左上角已经不再是(0,0), 而是改变后的坐标，坐标系改了，那么所有子视图的位置也会跟着改变
- 更改bounds的大小，bounds的大小代表当前视图的长和宽，修改长宽后，中心点继续保持不变, 长宽进行改变；通过bounds修改长宽看起来就像是以中心点为基准点对长宽两边同时进行缩放；
#### frame和bounds

![image](https://upload-images.jianshu.io/upload_images/1196725-188e8cb0157b3cee.png?imageMogr2/auto-orient/strip|imageView2/2/w/779)

- 因为是View A是顶层视图，所以其实相当于覆盖在框架上，因此位置从父视图的（0，0）开始，大小为550*400
- 默认情况下，本视图的坐标系是没有发生改变的即当前视图(view A)的左上角就是所有子视图的原点，大小就是当前视图的大小.
- 因为View B是ViewA的子视图，所以ViewB的frame位置需要以View A的左上角为参照，因此位置为(200, 100), 大小为200*250
- bounds在默认情况下本视图的坐标系是没有发生改变的即当前视图(viewB)的左上角就是当前视图所有子视图的原点.

![image](https://upload-images.jianshu.io/upload_images/1196725-2844fc5a83246fca.png?imageMogr2/auto-orient/strip|imageView2/2/w/893)

- 在上一个例子的基础上，我们更改了view A的bounds后，view B看待View A的左上角就已经发生改变了；这个时候我们看待View A的左上角就不是坐标原点了，而是我们通过bounds设置后的坐标，如图也就是(0, 100);
在View B的frame没有保存不变的基础上，我们View B的位置向上移动了100

![image](https://upload-images.jianshu.io/upload_images/1196725-ed92b2bc1640b1bd.png?imageMogr2/auto-orient/strip|imageView2/2/w/935)

#### 总结
- frame不管对于位置还是大小，改变的都是自己本身
- frame的位置是以父视图的坐标系为参照，从而确定当前视图在父视图中的位置
- frame的大小改变时，当前视图的左上角位置不会发生改变，只是大小发生改变
- bounds改变位置时，改变的是子视图的位置，自身没有影响；其实就是改变了本身的坐标系原点，默认本身坐标系的原点是左上角
- bounds的大小改变时，当前视图的中心点不会发生改变，当前视图的大小发生改变，看起来效果就想缩放一样

### 2.`nil`、`NIL`、`NSNULL` 有什么区别？
### 3.如何实现一个线程安全的 `NSMutableArray`?
### 4.如何定义一台 iOS 设备的唯一性?
### 5.`atomic` 修饰的属性是绝对安全的吗？为什么？
### 6.实现 `isEqual` 和 `hash` 方法时要注意什么？
### 7.`id` 和 `instanceType` 有什么区别？
### 8.简述事件传递、事件响应机制。
### 9.说一下对 `Super` 关键字的理解。
### 10.了解 逆变 和 协变 吗？
### 11.`@synthesize` 和 `@dynamic` 分别有什么作用？
### 12.Obj-C 中的反射机制了解吗？
### 13.`typeof` 和 `__typeof`，`typeof` 的区别?
### 14.如何判断一个文件在沙盒中是否存在？
### 15.头文件导入的方式？
### 16.如何将 Obj-C 代码改变为 C++/C 的代码？
### 17.知不知道在哪里下载苹果的源代码？
### 1.objc_getClass()、object_getClass()、Class 这三个方法用来获取类对象有什么不同？


## 网络
### 1.NSUrlConnect相关知识。
- NSURLConnection 是 iOS 开发中最经典的网络请求方案。虽然在苹果公司推出 NSURLSession 后已经不推荐使用 NSURLConnection 了（NSURLConnection 在 iOS 9 被宣布弃用了），但是在一些早先构建的项目和框架中可能任使用了 NSURLConnection 技术，所以还是有必要了解 NSURLConnection。
- NSURLConnection 使用步骤
    * 创建一个 NSURL 对象，用于设置请求路径。
    * 创建一个 NSURLRequest 对象，并设置请求头、请求体等请求参数。
    * 创建一个 NSURLResponse 对象用于接收响应数据，一般用 NSURLResponse 的子类 NSHPPTURLResponse。
    * 使用 NSURLConnection 发送同步或异步请求。
    * 可以使用 NSURLConnectionDelegate 监听网络请求的响应。

### 2.NSUrlSession相关知识。
- 在 iOS 9.0 之后，以前使用的 NSURLConnection 被弃用，苹果推荐使用 NSURLSession 来替换NSURLConnection 完成网路请求相关操作。
- NSURLSession 使用步骤
    * NSURLSession 的使用非常简单，先根据会话对象创建一个请求Task，然后执行该Task即可。
    * NSURLSessionTask 本身是一个抽象类，在使用的时候，通常是根据具体的需求使用它的几个子类。

### 补充：简要说一下Https；
### 3.Http 和 Https 的区别？为什么更加安全？
- HTTP协议
    * HTTP（Hypertext Transfer Protocol）协议是超文本传输协议，是互联网上应用最为广泛的一种网络协议。简单来说，HTTP 是客户端和服务器端之间请求和应答的标准。
- HTTP 协议工作过程，分为4个步骤：
    * 客户端与服务器需要建立连接。例如，单击某个超链接，浏览器和服务器将建立通信连接。
    * 建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户端信息和可能的内容。
    * 服务器接收到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后面是 MIME 信息包括服务器信息、实体信息和可能的内容。
    * 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。
- HTTPS协议
    * HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。
- HTTPS和HTTP的区别：
    * https协议需要到ca申请证书，一般免费证书很少，需要交费。
    * http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
    * http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。
    * http的连接很简单,是无状态的。
    * HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议要比http协议安全。
- iOS9中新增App Transport Security（简称ATS）特性, 让原来请求时候用到的HTTP，全部都转向TLS1.2协议进行传输，这意味着所有的HTTP协议都强制使用了HTTPS协议进行传输。如果我们在iOS9下直接进行HTTP请求是会报错，系统会告诉我们不能直接使用HTTP进行请求，需要在Info.plist中控制ATS的配置。

### 4.Http的请求方式有哪些？Http 有什么特性？
### 5.解释一下 三次握手 和 四次挥手？解释一下为什么是三次握手 又为什么是 四次挥手？
* tcp的三次握手
    * 所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：
    * TCP三次握手
        * 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
        * 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为 1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
        * 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发 送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入 ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
* 补充：SYN攻击：
    * 在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：
  #netstat -nap | grep SYN_RECV
* tcp的四次握手
    * 所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：
![image](https://upload-images.jianshu.io/upload_images/2744128-70075430fcb3ca99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000)
* TCP四次挥手
    * 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个 FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的 一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
        * 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
        * 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
        * 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
        * 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。
* 原因
    * 因为连接时服务端收到了客户端的SYN连接请求的报文后, 可以直接发送SYN+ACK报文, 其中的ACK报文是用来响应, SYN报文是用来同步的。
    * 而当关闭连接时, 服务端收到FIN报文后, 很可能并不会马上就关闭Socket连接, 所以只能先回复一个ACK报文, 告诉客户端, 你发的FIN报文我收到了, 只有等到服务器的所有报文发送完了, 服务端才会发送FIN报文, 所以才需要四次挥手。

### 6.GET 和 POST 请求的区别？
- ET请求：参数在地址后拼接，没有请求数据，不安全（因为所有参数都拼接在地址后面），不适合传输大量数据（长度有限制，为1024个字节）。
- GET提交、请求的数据会附在URL之后，即把数据放置在HTTP协议头<requestline>中。以分割URL和传输数据，多个参数用&连接。如果数据是英文字母或数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密。
- POST请求：参数在请求数据区放着，相对GET请求更安全，并且数据大小没有限制。把提交的数据放置在HTTP包的包体<request-body>中.
- ET提交的数据会在地址栏显示出来，而POST提交，地址栏不会改变。
- GET提交时，传输数据就会受到URL长度限制，POST由于不是通过URL传值，理论上书不受限。
- POST的安全性要比GET的安全性高；
- 通过GET提交数据，用户名和密码将明文出现在URL上，比如登陆界面有可能被浏览器缓存。

### 7.HTTP 请求报文 和 响应报文的结构？
- HTTP超文本传输协议，是短连接，是客户端主动发送请求，服务器做出响应，服务器响应之后，链接断开。HTTP是一个属于应用层面向对象的协议，HTTP有两类报文：请求报文和响应报文。
- HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。
- HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。

### 8.什么是 Mimetype ?
### 9.数据传输的加密过程？
### 10.说一下 TCP/IP 五层模型的协议?
* OSI七层模型：
    * OSI七层网络模型称为开发式系统互联网参考模型，是一个逻辑上的定义和规范；
    * 把网络从逻辑上分为七层，每一层都有相应的物理设备 
    * OSI七层网络模型是一种框架式的设计方法，最主要的功能就是帮助不同类型的主机实现数据传输； 
    * 最大的优点就是将服务、接口和协议三个概念明确的区分起来 
    * 复杂且不实用；经常使用的是TCP/IP四层模型。
* 各部分及功能
    * 应用层：针对你特定应用的协议 
    * 表示层：设备固定的数据格式和网络标准数据格式之间的转化 
    * 会话层：通信管理，负责建立和单开通信连接，管理传输层 以下分层 
    * 传输层：管理两个节点之间的数据传递。负责可靠传输 
    * 网络层：地址管理和路由选择 
    * 数据链路层：互联设备之间传送和识别数据帧 
    * 物理层：界定连接器和网线之间的规格
* TCP/IP四（五）层模型。
    * 每一层都呼叫它的下一层提供的网络来完成自己的需求。（如果是四层模型数据链路层和物理层在一层） 
    * 物理层：负责光电信号传递方式。集线器工作在物理层。以太网协议。 
    * 数据链路层：负责设备之间的数据帧的传输和识别。交换机工作在数据链路层。例如网卡设备的驱动，帧同步，冲突检测，数据差错校验等工作。 
    * 网络层：负责地址管理和路由选择。路由器工作在网络层。 
    * 传输层：负责两台主机之间的数据传输。 
    * 应用层：负责应用程序之间的沟通。网络编程主要针对的就是应用层。
    * 传输层和网络层的封装在操作系统完成。应用层的封装在应用程序中完成。 
数据链路层和物理层的封装在设备驱动程序与网络接口中完成。

### 11.说一下 OSI 七层模型的协议?
- OSI模型，即开放式通信系统互联参考模型，是国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。
- 0SI／RM协议是由IS0(国际标准化组织)制定的，它有三个基本的功能：
    * 提供给开发者一个必须的
    * 通用的概念以便开发完善
    * 可以用来解释连接不同系统的框架
- OSI的层次划分：OSI将计算机网络体系结构(architecture)划分为以下七层：
    * 物理层  Physical Layer：物理接口规范，传输比特流,网卡是工作在物理层的。
    * 数据链路层  Data Link Layer：成帧，保证帧的无误传输，MAC地址，形成EHTHERNET帧
    * 网络层  Network Layer：路由选择，流量控制，IP地址，形成IP包
    * 传输层  Transport Layer：端口地址，如HTTP对应80端口。TCP和UDP工作于该层,还有就是差错校验和流量控制。
    * 会话层  Session Layer：组织两个会话进程之间的通信,并管理数据的交换使用NETBIOS和WINSOCK协议。QQ等软件进行        通讯因该是工作在会话层的。
    * 表示层  Presentation Layer：使得不同操作系统之间通信成为可能。
    * 应用层 Application Layer：对应于各个应用软件

### 12.大文件下载 的功能有什么注意点？
- 大文件下载分四步：
    * NSURLSessionConfiguration初始化
    * NSURLSession初始化
    * 创建NSURLSessionDownloadTask
    * 实现四个代理方法
#### NSURLSessionConfiguration初始化
- 在初始化NSURLSession之前需要配置NSURLSessionConfiguration，有三种模式可以选择。

```
//默认模式，使用的是持久化的硬盘缓存
defaultSessionConfiguration;
//仅使用内存缓存，不会做持久存储到磁盘等，在session被释放后，数据会被清除，一般用于浏览器的无痕浏览
ephemeralSessionConfiguration;
//后台传输模式，咱们主要用的是这个模式，
backgroundSessionConfigurationWithIdentifier

```
#### NSURLSession初始化
- NSURLSessionConfiguration配置好以后就可以设置NSURLSession了，注意,文件下载只需要有一个Session就够了，要下载多个文件可以创建多个NSURLSessionDownloadTask。

```
//默认单线程执行大文件下载
NSOperationQueue *queue = [[NSOperationQueue alloc] init];
queue.maxConcurrentOperationCount = 1;//这里可以设置它的最大并发数
        
//创建会话
self.session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:queue];
```
#### 创建NSURLSessionDownloadTask
- session设置完以后就可以进行下载操作了，一行代码的事儿

```
NSURLSessionDownloadTask *downloadTask = [self.session downloadTaskWithURL:[NSURL URLWithString:urlStr]];
```

#### 实现四个代理方法

```
#pragma mark - NSURLSessionDownloadDelegate
/**
 每次传一个包调用一次该方法,可以从中获得下载进度,速度和文件大小

 @param session 当前的session会话
 @param downloadTask 当前的下载任务NSURLSessionDownloadTask
 @param bytesWritten 这次传递过来的数据量
 @param totalBytesWritten 目前为止下载了多少的数据
 @param totalBytesExpectedToWrite 一共有多少的数据要下载
 */
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten
 totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite {
    //进度
    float progress = 1.0 * totalBytesWritten / totalBytesExpectedToWrite;
    self.downloadProgressBlock(progress);
}

/**
 下载完成后，会调用该方法

 @param session 当前的session会话
 @param downloadTask 当前的下载任务NSURLSessionDownloadTask
 @param location 文件下载下来后系统自动保存的地址，location下的文件会被系统自动删除
 */
- (void)URLSession:(NSURLSession *)session
      downloadTask:(nonnull NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(nonnull NSURL *)location {
    //移动文件到自己想要保存的路径下,location下的文件会被系统自动删除
    NSError *saveError = nil;
    NSFileManager *fileManager = [NSFileManager defaultManager];
    NSString *savePath = [self savePathWithUrl:downloadTask.taskDescription];
    if ([fileManager fileExistsAtPath:savePath]) {
        [fileManager removeItemAtPath:savePath error:nil];
    }
    BOOL success = [fileManager moveItemAtPath:location.path toPath:savePath error:&saveError];
    if (success) {
        NSLog(@"文件下载完成,路径为 == %@", savePath);
        self.downloadSuccessBlock([NSURL URLWithString:savePath]);
        //删除之前保存的用来断点续传的resumeData
        [self removeDownloadTmpFileWithUrl:downloadTask.taskDescription];
    } else {
        NSLog(@"在转移文件时发生错误 %@", saveError);
    }
}

#pragma mark - NSURLSessionTaskDelegate
/**
 每次任务结束后调用，结束并不代表它下载完了，有以下几种情况
 1、没错误
 2、用户取消下载
 3、进程在后台被杀死了
 4、其他错误
 偷偷说一句，这个error里面有断点续传需要的resumeData
 @param session 当前的session会话
 @param task 当前的下载任务NSURLSessionTask，
            NSURLSessionDownloadTask继承它
 @param error 错误信息
 */
-(void)URLSession:(nonnull NSURLSession *)session
             task:(nonnull NSURLSessionTask *)task
didCompleteWithError:(nullable NSError *)error {
    if (error) {
        
        //用户取消下载会回调一个error,
        if ([error.localizedDescription isEqualToString:@"cancelled"]) {
            return;
        }
        
        //如果是在后台进程被杀死了,则保存一下resumeData
        if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
            [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
        }
        
        //暂时就是出任何错都让resumeData保存一下吧
        [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
        NSLog(@"error = %@", error);
    }
}

#pragma mark - NSURLSessionDelegate
//应用处于后台,所有下载任务已经完成，且其他代理方法都调用完以后调用
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session {
    NSLog(@"应用在后台该做的事儿都做完了");
}
```

### 补充：后台下载
- 在AppDelegate中调用一行代码

```
- (void)applicationDidEnterBackground:(UIApplication *)application {
    //调用这句,防止应用在进入后台后所有任务被终止
    [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{
    }];
}
```
调用完这个代码以后，App即使被压入后台，应用会继续把没执行完的任务执行完，一般是3分钟，在后台中应用任务完成后会调用上面介绍的四个回调，应用被强制杀死会走下面这个回调

```
-(void)URLSession:(nonnull NSURLSession *)session
             task:(nonnull NSURLSessionTask *)task
didCompleteWithError:(nullable NSError *)error {
//如果是在后台进程被杀死了,则保存一下resumeData，用于以后断点续传
        if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
              NSData *resumeData = [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData];
        }
}

```

### 13.断点续传 功能该怎么实现？
- 断点续传需要在创建NSURLSessionDownloadTask的时候传入resumeData，这样任务它就知道了上次的文件已经下载到这了，那就接着下载
#### 保存resumeData
- 一般在什么时刻保存resumeData呢
- 暂停下载

```
[downloadTask cancelByProducingResumeData:^(NSData * _Nullable resumeData) {
        if (!isRemove) {
            //将目前传递的文件数据resumeData存储到Document中
            [self saveDownloadTmpFileWithResumeData:resumeData url:urlStr];
        } else {
            [self removeDownloadTmpFileWithUrl:urlStr];
        }
}];
```
- 应用被强行杀死

```
//如果是在后台进程被杀死了,则保存一下resumeData
if ([error.userInfo objectForKey:NSURLErrorBackgroundTaskCancelledReasonKey]) {
        //将目前传递的文件数据resumeData存储到Document中
        [self saveDownloadTmpFileWithResumeData:[error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData] url:task.taskDescription];
}
```
- 下载过程中出现任何错误时
#### 在下次再下载这个文件时用resumeData创建NSURLSessionDownloadTask

```
        NSURLSessionDownloadTask *downloadTask = nil;
        //之前是否有过这个文件的下载任务
        if ([self.resumeDataDic.allKeys containsObject:base64Url]) {
            //到document中找找有没有之前下载过一些的resumeData文件
            //有resumeData就恢复下载
            downloadTask = [self.session downloadTaskWithResumeData:self.resumeDataDic[base64Url]];
        } else {
            //之前没下载过这个文件,就从头下载吧
            downloadTask = [self.session downloadTaskWithURL:[NSURL URLWithString:urlStr]];
        }
        
        //设置任务描述标签为文件url
        downloadTask.taskDescription = urlStr;
        //存储downloadTask对象
        self.downloadTaskDic[base64Url] = downloadTask;
        
        //启动任务
        [downloadTask resume];
```

### 14.封装一个网络框架有哪些注意点？
### 15.Wireshark、Charles、Paw 等工具会使用吗？
### 16.NSUrlProtocol用过吗？用在什么地方了？
### 17.如何在测试过程中 MOCK 各种网络环境？
### 18.DNS 的解析过程？网络的 DNS 优化。
### 19.Post请求体有哪些格式？
### 20.网络请求的状态码都大致代表什么意思？
### 21.抓包软件 Charles 的原理是什么？说一下中间人攻击的过程。
### 22.如何判断一个请求是否结束？
### 23.SSL 传输协议？说一下 SSL 验证过程？
### 24.解释一下 Http 的持久连接？
### 25.说一下传输控制协议 - TCP ?
### 26.说一下用户数据报协议 - UDP ?
### 27.谈一谈网络中的 session 和 cookie?
### 28.发送网络请求的时候，如果带宽 1M，如何针对某些请求，限制其流量?
### 补充：使用异步请求的方式抓取一个网站的内容，请考虑超时，状态码的异常情况（请用原生API或者Socket/Cocoa Socket）
### 补充：在网络请求中，如何处理网络网速慢，网络中断、网络抖动等等网络问题？
### 补充：https的缓存问题。
### 补充：你平时怎么解决网络请求的依赖关系：当一个接口的请求需要依赖于另一个网络请求的结果
#### 思路一：操作依赖：NSOperation 操作依赖和优先级（不适用，异步网络请求并不是立刻返回，无法保证回调时再开启下一个网络请求）

```
[operationB addDependency:operationA]; // 操作B依赖于操作
```
#### 思路二：逻辑判断：在上一个网络请求的响应回调中进行下一网络请求的激活（不适用，可能拿不到回调）
#### 思路三：线程同步 -- 组队列（dispatch_group）
- 当group里所有事件都完成GCD API有两种方式发送通知，第一种是DispatchGroup.wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用DispatchGroup.notify，异步执行闭包，不会阻塞当前线程。

```
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片… …
});
```

```
//阻塞当前的线程,直到dispatch group中的所有任务完成才会返回,可能会卡住主线程,造成页面卡顿,谨慎使用
dispatch_group_wait(serviceGroup,DISPATCH_TIME_FOREVER);
```

#### 思路四：线程同步 --阻塞任务（dispatch_barrier）也叫栅栏函数：

```
/* 创建并发队列 */
dispatch_queue_t concurrentQueue = dispatch_queue_create("test.concurrent.queue", DISPATCH_QUEUE_CONCURRENT);
/* 添加两个并发操作A和B，即A和B会并发执行 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationA");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationB");
});
/* 添加barrier障碍操作，会等待前面的并发操作结束，并暂时阻塞后面的并发操作直到其完成 */
dispatch_barrier_async(concurrentQueue, ^(){
    NSLog(@"OperationBarrier!");
});
/* 继续添加并发操作C和D，要等待barrier障碍操作结束才能开始 */
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationC");
});
dispatch_async(concurrentQueue, ^(){
    NSLog(@"OperationD");
});
```
#### 思路五：线程同步 -- 信号量机制（dispatch_semaphore）：

```
/* 创建一个信号量 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

/* 任务1 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 耗时任务1 */
    NSLog(@"任务1开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务1结束");
    /* 任务1结束，发送信号告诉任务2可以开始了 */
    dispatch_semaphore_signal(semaphore);
});

/* 任务2 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 等待任务1结束获得信号量, 无限等待 */
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    /* 如果获得信号量则开始任务2 */
    NSLog(@"任务2开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务2结束");
});
[NSThread sleepForTimeInterval:10];
```
- 或者

```
/* 创建一个信号量 */
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
/* 任务1 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 耗时任务1 */
    NSLog(@"任务1开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务1结束");
    /* 任务1结束，发送信号告诉任务2可以开始了 */
    dispatch_semaphore_signal(semaphore);
});
/* 任务2 */
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    /* 等待任务1结束获得信号量, 无限等待 */
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    /* 如果获得信号量则开始任务2 */
    NSLog(@"任务2开始");
    [NSThread sleepForTimeInterval:3];
    NSLog(@"任务2结束");
});

//我们每一次遍历，都让其dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER)，这个时候线程会等待，阻塞当前线程，直到dispatch_semaphore_signal(sem)调用之后，而我们dispatch_semaphore_signal(sem)是在网络请求的回调里调用的

    dispatch_semaphore_t sem = dispatch_semaphore_create(0);
    for (int i=0; i<10; i++) {
        
        NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
            
            NSLog(@"%d---%d",i,i);
            dispatch_semaphore_signal(sem);
        }];
        
        [task resume];
        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);
    }
    
    dispatch_async(dispatch_get_main_queue(), ^{
        NSLog(@"end");
    });
```


## 多线程
### 补充：进程和线程、多进程和多线程、任务和队列、并行与串行、同步和异步
- 进程：
    * 进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元.
    * 进程是指在系统中正在运行的一个应用程序，就是一段程序的执行过程,我们可以理解为手机上的一个app.
    * 每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内，拥有独立运行所需的全部资源
- 线程：
    * 程序执行流的最小单元，线程是进程中的一个实体.
    * 一个进程要想执行任务,必须至少有一条线程.应用程序启动的时候，系统会默认开启一条线程,也就是主线程
- 进程和线程的关系
    * 线程是进程的执行单元，进程的所有任务都在线程中执行
    * 线程是 CPU 分配资源和调度的最小单位
    * 一个程序可以对应多个进程(多进程),一个进程中可有多个线程,但至少要有一条线程
    * 同一个进程内的线程共享进程资源
- 多进程，打开mac的活动监视器，可以看到很多个进程同时运行：
    * 进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。显然，程序是死的(静态的)，进程是活的(动态的)。
    * 进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程，它们就是处于运行状态下的操作系统本身;所有由用户启动的进程都是用户进程。进程是操作系统进行资源分配的单位。
    * 进程又被细化为线程，也就是一个进程下有多个能独立运行的更小的单位。在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态，这便是多进程。
- 多线程
    * 同一时间，CPU只能处理1条线程，只有1条线程在执行。多线程并发执行，其实是CPU快速地在多条线程之间调度（切换）。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
    * 如果线程非常非常多，CPU会在N多线程之间调度，消耗大量的CPU资源，每条线程被调度执行的频次会降低（线程的执行效率降低）
    * 多线程的优点:
        * 能适当提高程序的执行效率
        * 能适当提高资源利用率（CPU、内存利用率）
    * 多线程的缺点:
        * 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能
        * 线程越多，CPU在调度线程上的开销就越大
        * 程序设计更加复杂：比如线程之间的通信、多线程的数据共享
- 任务
    * 就是执行操作的意思，也就是在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：同步执行（sync）和异步执行（async）
    * 同步(Sync)：同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行，即会阻塞线程。只能在当前线程中执行任务(是当前线程，不一定是主线程)，不具备开启新线程的能力。
    * 异步(Async)：线程会立即返回，无需等待就会继续执行下面的任务，不阻塞当前线程。可以在新的线程中执行任务，具备开启新线程的能力(并不一定开启新线程)。如果不是添加到主队列上，异步会在子线程中执行任务
- 队列
    * 队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务
    * 在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。
    * 串行队列（Serial Dispatch Queue）：同一时间内，队列中只能执行一个任务，只有当前的任务执行完成之后，才能执行下一个任务。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）。主队列是主线程上的一个串行队列,是系统自动为我们创建的
    * 并发队列（Concurrent Dispatch Queue）：同时允许多个任务并发执行。（可以开启多个线程，并且同时执行任务）。并发队列的并发功能只有在异步（dispatch_async）函数下才有效
- 并行与串行：决定了任务的执行方式
    * 并行：多个任务并发（同时）执行。类型迅雷，多个任务同时开启下载
    * 串行：一个任务执行完毕后，再执行下一个任务。类似浏览器的一个接一个下载
- 同步和异步：决定了可不可以开启新的线程
    * 同步：在当前线程中执行任务，不具备开启新线程的能力
    * 异步：在新的线程中执行任务，具备开启新线程的能力

### 补充：谈谈你对多线程开发的理解(多线程的好处，多线程的作用)？ios中有几种实现多线程的方法？
- 好处：
    - 使用线程可以把占据时间长的程序中的任务放到后台去处理
    - 用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度
    - 程序的运行效率可能提高
    - 在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。
- 缺点：
    - 如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换。
    - 更多的线程需要更多的内存空间。
    - 线程的中止需要考虑其对程序运行的影响。
- 实现多线程的方法：
    - NSObject的类方法 
        - -(void)performSelectornBackground/OnMainThread:(SEL)aSelector withObject:(id)arg
    - NSThread
    - NSOperation
    - GCD
- NSThread:(两种创建方式)

```
[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];
 
NSThread *myThread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:) object:nil];
 
[myThread start];
```
- 优点：NSThread 比其他两个轻量级。 
- 缺点：需要自己管理线程的生命周期，线程同步，线程同步时对数据的加锁会有一定的系统开销。
- Cocoa Operation

```
NSOperationQueue*oprationQueue= [[NSOperationQueuealloc] init];
 
oprationQueueaddOperationWithBlock:^{
 
//这个block语句块在子线程中执行
 
}
```
- 优点：不需要关心线程管理，数据同步的事情。 Cocoa Operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行，我们会把我们的执行操作放在NSOperation中main函数中。
- GCD Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法，GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。它让程序平行排队的特定任务，根据可用的处理资源，安排他们在任何可用的处理器核心上执行任务，一个任务可以是一个函数(function)或者是一个block。 dispatch queue分为下面三种： private dispatch queues，同时只执行一个任务，通常用于同步访问特定的资源或数据。 global dispatch queue，可以并发地执行多个任务，但是执行完成的顺序是随机的。 Main dispatch queue 它是在应用程序主线程上执行任务的。

### 1.NSThread相关知识？

### 2.GCD 相关知识？
### 3.NSOperation 和 NSOperationQueue相关知识？
- 操作（Operation）：
    * 执行操作的意思，换句话说就是你在线程中执行的那段代码。
    * 在 GCD 中是放在 block 中的。在 NSOperation 中，使用 NSOperation子类NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。
- 操作队列（Operation Queues）：
    * 这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。
    * 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。
    * NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。

### 补充：NSOperationQueue的优点
- NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。
- 可以添加任务依赖，方便控制执行顺序
- 可以设定操作执行的优先级
- 任务执行状态控制:isReady,isExecuting,isFinished,isCancelled如果只是重写NSOperation的main方法，由底层控制变更任务执行及完成状态，以及任务退出，如果重写了NSOperation的start方法，自行控制任务状态
系统通过KVO的方式移除isFinished==YES的NSOperation
- 可以设置最大并发量

### 补充：NSOperation与GCD的关系？
- GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
- GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便
- GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序
- NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂
- NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）
- 实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选
- 如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持
- 不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销

### 4.如何实现线性编程？
### 5.说一下 GCD 并发队列实现机制？
### 补充：GCD的并行队列一定会开辟新的线程？
### 6.NSLock？是否会出现死锁？
### 7.NSContion
### 8.条件锁 - NSContionLock
### 9.递归锁 - NSRecursiveLock
### 10.同步锁 - Synchronized(self) {// code}
### 11.信号量 - dispatch_semaphore。
### 12.自旋锁 - OSSpinLock 。
- 是一种用于保护多线程共享资源的锁，与一般互斥锁（mutex）不同之处在于当自旋锁尝试获取锁时以忙等待（busy waiting）的形式不断地循环检查锁是否可用。当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。
在多CPU的环境中，对持有锁较短的程序来说，使用自旋锁代替一般的互斥锁往往能够提高程序的性能。
- 自旋锁会忙等: 所谓忙等，即在访问被锁资源时，调用者线程不会休眠，而是不停循环在那里，直到被锁资源释放锁。

### 补充：互斥锁
- 当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。
- 互斥锁会休眠: 所谓休眠，即在访问被锁资源时，调用者线程会休眠，此时cpu可以调度其他线程工作。直到被锁资源释放锁。此时会唤醒休眠线程。

### 13.多功能锁 - pthread_mutex
### 14.分步锁 - NSDistributedLock。
### 15.如何确保线程安全？
### 16.NSMutableArray、和 NSMutableDictionary是线程安全的吗？NSCache呢？
### 17.多线程的 并行 和 并发 有什么区别？
### 18.多线程有哪些优缺点？
### 19.如何自定义 NSOperation ?
### 20.GCD 与 NSOperationQueue 有哪些异同？
- GCD是面向底层的C语言的API，NSOpertaionQueue用GCD构建封装的，是GCD的高级抽象。
- GCD执行效率更高，而且由于队列中执行的是由block构成的任务，这是一个轻量级的数据结构，写起来更方便
- GCD只支持FIFO的队列，而NSOperationQueue可以通过设置最大并发数，设置优先级，添加依赖关系等调整执行顺序
- NSOperationQueue甚至可以跨队列设置依赖关系，但是GCD只能通过设置串行队列，或者在队列内添加barrier(dispatch_barrier_async)任务，才能控制执行顺序,较为复杂
- NSOperationQueue因为面向对象，所以支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished）、是否取消（isCanceld）
- 实际项目开发中，很多时候只是会用到异步操作，不会有特别复杂的线程关系管理，所以苹果推崇的且优化完善、运行快速的GCD是首选
- 如果考虑异步操作之间的事务性，顺序行，依赖关系，比如多线程并发下载，GCD需要自己写更多的代码来实现，而NSOperationQueue已经内建了这些支持
- 不论是GCD还是NSOperationQueue，我们接触的都是任务和队列，都没有直接接触到线程，事实上线程管理也的确不需要我们操心，系统对于线程的创建，调度管理和释放都做得很好。而NSThread需要我们自己去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销

### 补充：你们项目中为什么多线程用GCD而不用NSOperation呢? 你有没有发现国外的大牛他们多线程都是用NSOperation? 你能告诉我他们这样做的理由吗?
### 21.解释一下多线程中的死锁？
### 补充：列举几种进程的同步机制、进程的通信途径、死锁及死锁的处理方法。
### 22.子线程是否会出现死锁？说一下场景？
### 23.多线程技术在使用过程中有哪些注意事项？
### 补充：并行和并发的区别？串行/并行、同步异步的区别?
### 补充：请说明同步请求与异步请求的区别?
### 补充：默认最大并发？
### 补充：dispatch_once如何实现一次性代码？
### 补充：如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）
### 补充：线程与进程的区别和联系?
### 补充：iOS线程间怎么通信？
### 补充：Object C中创建线程的方法是什么?如果在主线程中执行代码，方法是什么?如果想延时执行代码、方法又是什么?
### 补充：请说明同步请求与异步请求的区别?
### 补充：如何把异步线程转换成同步任务进行单元测试？



## 项目架构
### 1.什么是 MVC?
- MVC最大的优势就是快速开发，当项目初期，追求快速上线的时候可以使用MVC，并且苹果提供了MVC的官方支持，项目初期无疑选择MVC是最佳的。
- MVC结构简单即使对于经验不那么丰富的开发者来讲维护起来也较为容易。

### 2.什么是 MVVM?
- MVVM的优势就是，任务均摊每部分都承担各自的责任，结构清晰更加符合软件设计原则
- 其次就是可测试性强，我们只需要测试ViewModel就能够轻易的测试UI上的问题
- 通过观察者模式，来进行属性绑定，代码量将会小的多

### 3.什么是 MVP?
- 通过观察者模式，来进行属性绑定，代码量将会小的多

### 4.什么是 CDD?
### 5.项目的组件化？
#### 1.说一下你了解的项目组件化方案？
#### 2.什么样的团队及项目适合采用组件化的形式进行开发？
#### 3.组件之间的通信方式。
#### 4.各组件之间的解耦。
### 6.还了解哪些项目架构？你之前所在公司的架构师什么样的，简单说一下？
### 7.从宏观上来讲 App 可以分为哪些层？
### 8.多工程连编之静态库


## 消息传递的方式
### 1.说一下 NSNotification 的实现机制？
- 使用观察者模式来实现的用于跨层传递信息的机制。传递方式是一对多的。
- 如果实现通知机制？
    * 应用服务提供商从服务器端把要发送的消息和设备令牌（device token）发送给苹果的消息推送服务器APNs。
    * APNs根据设备令牌在已注册的设备（iPhone、iPad、iTouch、mac等）查找对应的设备，将消息发送给相应的设备。
    * 客户端设备接将接收到的消息传递给相应的应用程序，应用程序根据用户设置弹出通知消息。

### 2.说一下 NSNotification 的特点。
### 3.简述 KVO 的实现机制。
- 概述
    * KVO，即：Key-Value Observing，它提供一种机制，当指定的对象的属性被修改后，则其观察者就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。
    * KVO其实也是“观察者”设计模式的一种应用。这种模式有利于两个类间的解耦合，尤其是对于 业务逻辑与视图控制 这两个功能的解耦合。
    
- 实现原理
    * KVO 是基于运行时实现的 isa   Class   NSKVONotifying_Person
    * 基本的原理：当观察某对象A时，KVO机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性keyPath的setter 方法。setter 方法随后负责通知观察对象属性的改变状况。
    * 基本的步骤：
        - 注册观察者，实施监听；
        - 在回调方法中处理属性发生的变化；
        - 移除观察者
    * Apple 使用了 isa 混写（isa-swizzling）来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为： NSKVONotifying_A的新类，该类继承自对象A的本类，且KVO为NSKVONotifying_A重写观察属性的setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。（备注： isa 混写（isa-swizzling）isa：is a kind of ； swizzling：混合，搅合；）
        - NSKVONotifying_A类剖析：在这个过程，被观察对象的 isa 指针从指向原来的A类，被KVO机制修改为指向系统新创建的子类 NSKVONotifying_A类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对KVO的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类()，就会发现系统运行到注册KVO的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为NSKVONotifying_A的中间类，并指向这个中间类了。（isa 指针的作用：每个对象都有isa 指针，指向该对象的类，它告诉 Runtime 系统这个对象的类是什么。所以对象注册为观察者时，isa指针指向新子类，那么这个被观察的对象就神奇地变成新子类的对象（或实例）了。） 因而在该对象上对 setter 的调用就会调用已重写的 setter，从而激活键值通知机制。
        - 子类setter方法剖析：KVO的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangevlueForKey:，在存取数值的前后分别调用2个方法：被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更；当改变发生后， didChangeValueForKey: 被调用，通知系统该 keyPath 的属性值已经变更；之后observeValueForKey:ofObject:change:context: 也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。

- KVC与KVO的不同？
    * KVC(键值编码)，即Key-Value Coding，一个非正式的Protocol，使用字符串(键)访问一个对象实例变量的机制。而不是通过调用Setter、Getter方法等显式的存取方式去问。
    * KVO(键值监听)，即Key-Value Observing，它提供一种机制,当指定的对象的属性被修改后,对象就会接受到通知，前提是执行了setter方法、或者使用了KVC赋值。

- 和notification(通知)的区别？
    * notification比KVO多了发送通知的一步。两者都是一对多，但是对象之间直接的交互，notification明显得多，需要notificationCenter来做为中间交互。而KVO如我们介绍的，设置观察者->处理属性变化，至于中间通知这一环，则隐秘多了，只留一句“交由系统通知”，具体的可参照以上实现过程的剖析。
notification的优点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，例如键盘、前后台等系统通知的使用也更显灵活方便。

- 与delegate的不同？
    * 和delegate一样，KVO和NSNotification的作用都是类与类之间的通信。但是与delegate不同的是：
这两个都是负责发送接收通知，剩下的事情由系统处理，所以不用返回值；而delegate 则需要通信的对象通过变量(代理)联系；
delegate一般是一对一，而这两个可以一对多。

- 总结
    * 对比其他的回调方式，KVO机制的运用的实现，更多的由系统支持，相比notification、delegate等更简洁些，并且能够提供观察属性的最新值以及原始值；但是相应的在创建子类、重写方法等等方面的内存消耗是很巨大的。所以对于两个类之间的通信，我们可以根据实际开发的环境采用不同的方法，使得开发的项目更加简洁实用。
    * 另外需要注意的是，由于这种继承方式的注入是在运行时而不是编译时实现的，如果给定的实例没有观察者，那么KVO不会有任何开销，因为此时根本就没有KVO代码存在。但是即使没有观察者，委托和NSNotification还是得工作，这也是KVO此处零开销观察的优势。
    * 异步:监听通知 主线程:发出通知 接收通知代码在主线程
    * 主线程:监听通知 异步:发出通知 接收通知代码在异步
    * 注意:在接收通知代码中 可以加上主队列任务
    * 总结:接收通知代码 由 发出通知线程决定, KVO也一样

- 代码
```
#import "ViewController.h"
#import "Person.h"

@interface ViewController ()
/** p1 */
@property (strong, nonatomic) Person *p1;

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    // 1.什么是通知
    
    // 3个对象
    self.p1 = [[Person alloc] init];
    self.p1.name = @"p1";
    //打印监听前类信息
    [p1 printInfo];
    // KVO是监听对象的属性值的改变的
    [self.p1 addObserver:self forKeyPath:@"name" options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];
    self.p1.name = @"123";
    //打印监听后类信息
     [p1 printInfo];
     [p1 removeObserver:self forKeyPath:@"name"];
     //打印移除监听后类信息
     [p1 printInfo];
}

// 这个方法时属于 NSObject 类的，任何对象都可以作为观察者
- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSString *,id> *)change context:(void *)context
{
    NSLog(@"监听到了%@的%@属性发生了改变", object, keyPath);
    NSLog(@"%@", change);
}

@end

person类方法：

-(void)printInfo
{
    NSLog(@"isa:%@, supper class:%@", NSStringFromClass(object_getClass(self)),
          class_getSuperclass(object_getClass(self)));
    
    NSLog(@"self:%@, [self superclass]:%@", self, [self superclass]);
    
    NSLog(@"age setter function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(setAge:)));
    
    NSLog(@"name setter function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(setName:)));
    NSLog(@"printInfo function pointer:%p", class_getMethodImplementation(object_getClass(self), @selector(printInfo)));
}
```
- KVO为子类的观察者属性重写调用存取方法的工作原理在代码中相当于：
    * 上述例子中，当 p1.name 的值改变时，p1对象的 isa 指针会指向 NSKVONotifying_Person，意味着，在程序运行时，会动态生成一个 NSKVONotifying_Person 类，该类继承于 Person，而且该类中也有个 -setName: 方法，方法中在设置 name 的同时实现了：
```
- (void)setName:(NSString *)name
{
    [super setName:name];
    
    // 这两个方法底层会调用observer的- (void)observeValueForKeyPath: ofObject: change: context:这个方法
    [self willChangeValueForKey:@"age"];
    [self didChangeValueForKey:@"age"];
}

```
- 观察者观察的是属性，只有遵循 KVO 变更属性值的方式才会执行KVO的回调方法，例如是否执行了setter方法、或者是否使用了KVC赋值。
如果赋值没有通过setter方法或者KVC，而是直接修改属性对应的成员变量，例如：仅调用_name = @"newName"，这时是不会触发kvo机制，更加不会调用回调方法的。
所以使用KVO机制的前提是遵循 KVO 的属性设置方式来变更属性值。

### 4.KVO 在使用过程中有哪些注意点？有没有使用过其他优秀的 KVO 三方替代框架？
### 5.简述 KVO 的注册依赖键是什么？
### 6.如何做到 KVO 手动通知？
### 7.在什么情况下会触发 KVO?
### 8.给实例变量赋值时，是否会触发 KVO?
### 9.Delegate通常用什么关键字修饰？为什么？
### 10通知 和 代理 有什么区别？各自适应的场景？
#### 分类
- 分类的作用？
    * 声明私有方法，分解体积大的类文件，把framework的私有方法公开
- 分类的特点
    * 运行时决议，可以为系统类添加分类 。
    * 说得详细些，在运行时时期，将 Category 中的实例方法列表、协议列表、属性列表添加到主类中后（所以Category中的方法在方法列表中的位置是在主类的同名方法之前的），然后会递归调用所有类的 load 方法，这一切都是在main函数之前执行的。
- 分类可以添加哪些内容？
    * 实例方法，类方法，协议，属性（添加getter和setter方法，并没有实例变量，添加实例变量需要用关联对象）
- 如果工程里有两个分类A和B，两个分类中有一个同名的方法，哪个方法最终生效？
    * 取决于分类的编译顺序，最后编译的那个分类的同名方法最终生效，而之前的都会被覆盖掉(这里并不是真正的覆盖，因为其余方法仍然存在，只是访问不到，因为在动态添加类的方法的时候是倒序遍历方法列表的，而最后编译的分类的方法会放在方法列表前面，访问的时候就会先被访问到，同理如果声明了一个和原类方法同名的方法，也会覆盖掉原类的方法)。
- 如果声明了两个同名的分类会怎样？
    * 会报错，所以第三方的分类，一般都带有命名前缀
- 分类能添加成员变量吗？
    * 不能。只能通过关联对象(objc_setAssociatedObject)来模拟实现成员变量，但其实质是关联内容，所有对象的关联内容都放在同一个全局容器哈希表中:AssociationsHashMap,由AssociationsManager统一管理。
#### 扩展
- 一般用扩展做什么？
    * 声明私有属性，声明方法（没什么意义），声明私有成员变量
- 扩展的特点
    * 编译时决议，只能以声明的形式存在，多数情况下寄生在宿主类的.m中，不能为系统类添加扩展。
#### 代理（Delegate）
- 代理是一种设计模式，以@protocol形式体现，一般是一对一传递。
- 一般以weak关键词以规避循环引用。

### 11.__block 的解释以及在 ARC 和 MRC 下有什么不同？
### 补充：在block内如何修改block外部变量?
- 默认情况下,在block中访问的外部变量是复制过去的,即:写操作不对原变量生效
- 这里是把栈中的a,复制了一份到堆中(只是一个简单的值传递,堆中的暂且称之为b,下面也这样称呼),两个内存空间,所以修改栈中的a,不影响堆中的b.
- 如果我们想要修改外部变量的值,我们可以加上__block来进行操作
- 为什么加上__block就生效了？
    * Block不允许修改外部变量的值,这里所说的外部变量的值,指的是.__block 所起到的作用就是只要观察到该变量被 block 所持有,就会将a包装成一个结构体__Block_byref_a_0,初始化a=0,然后将该结构体的指针传递到了堆中.因而在block内部也可以修改外部变量的值.a在结构体里变成了一个属性(该结构体持有局部的原始变量),也有__forwarding这个指针. 这时候栈里面结构体的__forwarding 指向了堆中的结构体,堆中结构体的__forwarding 指向了自己,这就保证了无论是栈中的还是堆中的,都是访问的同一个值a
- Block不允许修改外部变量的值这样的设计,应该是考虑到了block的特殊性,block也属于“函数”的范畴,变量进入block,实际就是已经改变了作用域.在几个作用域之间进行切换时,如果不加上这样的限制,变量的可维护性将大大降低.又比如我想在block内声明了一个与外部同名的变量,此时是允许呢还是不允许呢?
- 可以看到,定义后和block内部内存地址是一样的,我们都知道 block 内部的变量会被放到堆区,“block内部”打印的是堆地址,因而也就可以知道,“定义后”打印的也是堆的地址.
- 结论:a在定义前是在栈区(),进入block区域后,变成了堆区.这才是__block关键字的作用

### 12.Block 的内存管理。
### 13.Block 自动截取变量。
#### 局部变量截获 是值截获。 比如:

```
    NSInteger num = 3;
    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){
        
        return n*num;
    };
    
    num = 1;
    
    NSLog(@"%zd",block(2));
```
- 这里的输出是6而不是2，原因就是对局部变量num的截获是值截获。
- 同样，在block里如果修改变量num，也是无效的，甚至编译器会报错。

```
NSMutableArray * arr = [NSMutableArray arrayWithObjects:@"1",@"2", nil];
    
    void(^block)(void) = ^{
        
        NSLog(@"%@",arr);//局部变量
        
        [arr addObject:@"4"];
    };
    
    [arr addObject:@"3"];
    
    arr = nil;
    
    block();
```
- 打印为1，2，3
- 局部对象变量也是一样，截获的是值，而不是指针，在外部将其置为nil，对block没有影响，而该对象调用方法会影响
#### 局部静态变量截获 是指针截获。

```
static  NSInteger num = 3;
    
    NSInteger(^block)(NSInteger) = ^NSInteger(NSInteger n){
        
        return n*num;
    };
    
    num = 1;
    
    NSLog(@"%zd",block(2));
```
- 输出为2，意味着num=1这里的修改num值是有效的，即是指针截获。
- 同样，在block里去修改变量m，也是有效的。
#### 全局变量，静态全局变量截获：不截获,直接取值。
- 我们同样用clang编译看下结果。

```
static NSInteger num3 = 300;

NSInteger num4 = 3000;

- (void)blockTest
{
    NSInteger num = 30;
    
    static NSInteger num2 = 3;
    
    __block NSInteger num5 = 30000;
    
    void(^block)(void) = ^{
        
        NSLog(@"%zd",num);//局部变量
        
        NSLog(@"%zd",num2);//静态变量
        
        NSLog(@"%zd",num3);//全局变量
        
        NSLog(@"%zd",num4);//全局静态变量
        
        NSLog(@"%zd",num5);//__block修饰变量
    };
    
    block();
}
```
- 编译后

```
struct __WYTest__blockTest_block_impl_0 {
  struct __block_impl impl;
  struct __WYTest__blockTest_block_desc_0* Desc;
  NSInteger num;//局部变量
  NSInteger *num2;//静态变量
  __Block_byref_num5_0 *num5; // by ref//__block修饰变量
  __WYTest__blockTest_block_impl_0(void *fp, struct __WYTest__blockTest_block_desc_0 *desc, NSInteger _num, NSInteger *_num2, __Block_byref_num5_0 *_num5, int flags=0) : num(_num), num2(_num2), num5(_num5->__forwarding) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
-  impl.isa = &_NSConcreteStackBlock;这里注意到这一句，即说明该block是栈block）
可以看到局部变量被编译成值形式，而静态变量被编成指针形式，全局变量并未截获。而__block修饰的变量也是以指针形式截获的，并且生成了一个新的结构体对象：

```
struct __Block_byref_num5_0 {
  void *__isa;
__Block_byref_num5_0 *__forwarding;
 int __flags;
 int __size;
 NSInteger num5;
};
```
- 该对象有个属性：num5，即我们用__block修饰的变量。这里__forwarding是指向自身的(栈block)。一般情况下，如果我们要对block截获的局部变量进行赋值操作需添加__block修饰符，而对全局变量，静态变量是不需要添加__block修饰符的。另外，block里访问self或成员变量都会去截获self。

### 14.Block 处理循环引用。
### 15.Block 有几种类型？分别是什么？
- 分为全局Block(_NSConcreteGlobalBlock)、栈Block(_NSConcreteStackBlock)、堆Block(_NSConcreteMallocBlock)三种形式其中栈Block存储在栈(stack)区，堆Block存储在堆(heap)区，全局Block存储在已初始化数据(.data)区
- 不使用外部变量的block是全局block
- 比如：

```
NSLog(@"%@",[^{
        NSLog(@"globalBlock");
    } class]);
```
- 输出：

```
__NSGlobalBlock__
```
- 使用外部变量并且未进行copy操作的block是栈block
- 比如

```
NSInteger num = 10;
    NSLog(@"%@",[^{
        NSLog(@"stackBlock:%zd",num);
    } class]);
```
- 输出：

```
__NSStackBlock__
```
- 日常开发常用于这种情况:

```
[self testWithBlock:^{
    NSLog(@"%@",self);
}];

- (void)testWithBlock:(dispatch_block_t)block {
    block();

    NSLog(@"%@",[block class]);
}
```
- 对栈block进行copy操作，就是堆block，而对全局block进行copy，仍是全局block
    * 比如堆1中的全局进行copy操作，即赋值：

```
void (^globalBlock)(void) = ^{
        NSLog(@"globalBlock");
    };

 NSLog(@"%@",[globalBlock class]);
```
- 输出：

```
__NSGlobalBlock__
```
- 仍是全局block
- 而对2中的栈block进行赋值操作：

```
NSInteger num = 10;

void (^mallocBlock)(void) = ^{

        NSLog(@"stackBlock:%zd",num);
    };

NSLog(@"%@",[mallocBlock class]);
```
- 输出：

```
__NSMallocBlock__
```
- 对栈blockcopy之后，并不代表着栈block就消失了，左边的mallock是堆block，右边被copy的仍是栈block
- 比如:

```
[self testWithBlock:^{
    
    NSLog(@"%@",self);
}];

- (void)testWithBlock:(dispatch_block_t)block
{
    block();
    
    dispatch_block_t tempBlock = block;
    
    NSLog(@"%@,%@",[block class],[tempBlock class]);
}
```
- 输出：

```
__NSStackBlock__,__NSMallocBlock__
```
- 即如果对栈Block进行copy，将会copy到堆区，对堆Block进行copy，将会增加引用计数，对全局Block进行copy，因为是已经初始化的，所以什么也不做。
- 另外，__block变量在copy时，由于__forwarding的存在，栈上的__forwarding指针会指向堆上的__forwarding变量，而堆上的__forwarding指针指向其自身，所以，如果对__block的修改，实际上是在修改堆上的__block变量。
- 即__forwarding指针存在的意义就是，无论在任何内存位置，都可以顺利地访问同一个__block变量。
- 另外由于block捕获的__block修饰的变量会去持有变量，那么如果用__block修饰self，且self持有block，并且block内部使用到__block修饰的self时，就会造成多循环引用，即self持有block，block 持有__block变量，而__block变量持有self，造成内存泄漏。
- 比如:

```
__block typeof(self) weakSelf = self;
    
    _testBlock = ^{
        
        NSLog(@"%@",weakSelf);
    };
    
    _testBlock();
```
- 如果要解决这种循环引用，可以主动断开__block变量对self的持有，即在block内部使用完weakself后，将其置为nil，但这种方式有个问题，如果block一直不被调用，那么循环引用将一直存在。所以，我们最好还是用__weak来修饰self

### 16.说一下什么是Block?
### 17.Dispatch_block_t这个有没有用过？解释一下？
### 补充：Block 用什么修饰？copy，assign，strong有什么区别？
### 补充：Block 后面携带参数的时候，有数量限制吗？为什么？
### 补充：消息通知有几种？如何判断是否发送通知。



## 数据存储
### 1.Sqlite3
#### 1.简单说一下 Sqlite3
#### 2.Sqlite3 常用的执行语句
#### 3.Sqlite3 在不同版本的APP，数据库结构变化了，如何处理?
### 2.FMDB (Sqlite3 的封装)
### 3.Realm
### 4.NSKeyArchieve
### 5.Preperfence
### 6.Plist
### 7.CoreDate
### 8.Keychain
### 9.UIPasteBoard(感谢 lilingyu0620 同学提醒)
### 10.FoundationDB
### 11.LRU(最少最近使用)缓存


## iOS设计模式
### 1.编程中的六大设计原则？
- 单一职责原则
    * 通俗地讲就是一个类只做一件事
        * CALayer：动画和视图的显示。
        * UIView：只负责事件传递、事件响应。
- 开闭原则
    * 对修改关闭，对扩展开放。
    * 要考虑到后续的扩展性，而不是在原有的基础上来回修改
- 接口隔离原则
    * 使用多个专门的协议、而不是一个庞大臃肿的协议
        * UITableviewDelegate
        * UITableViewDataSource
- 依赖倒置原则
    * 抽象不应该依赖于具体实现、具体实现可以依赖于抽象。
    * 调用接口感觉不到内部是如何操作的
- 里氏替换原则
    * 父类可以被子类无缝替换，且原有的功能不受任何影响，例如 KVO
- 迪米特法则
    * 一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合

### 2.如何设计一个图片缓存框架？
- 可以模仿 SDWebImage 来实现。
- 构成
    * Manager
    * 内存缓存
    * 磁盘缓存
    * 网络下载
    * Code Manager
        * 图片解码
        * 图片解压缩
        * 图片的存储是以图片的单向 hash 值为 Key
- 内存设计需要考虑的问题
    * 存储的 Size
        * 因为内存的空间有限，我们针对不同尺寸的图片，给出不同的方案
        * 10K 以下的50个
        * 100Kb 以下的20个
        * 100kb 以上的10个
    * 淘汰的策略
        * 内存的淘汰策略采取LRU（最近最少使用算法）
        * 触发淘汰策略的时机有三种
            * 定期检查（不建议，耗性能）
            * 提高检查触发频率（一定要注意开销）
                * 前后台切换的时候
                * 每次读写的时候
- 磁盘设计需要考虑的问题
    * 存储方式
    * 大小限制（有固定的大小）
    * 移除策略（可以设置为7天或者15天）
- 网络设计需要考虑的问题
    * 图片请求的最大并发量
    * 请求超时策略
    * 请求优先级
- 图片解码
    * 应用 策略模式，针对 jpg、png、gif 等不同的图片格式进行解码
    * 图片解码的时机
        * 在 子线程 图片刚下载完时
        * 在 子线程 刚从磁盘读取完时
        * 避免在主线程解压缩、解码，避免卡顿

### 3.如何设计一个时长统计框架？
- 记录器
    * 页面式记录器
    * 流式记录器
    * 自定义式
- 记录管理者
    * 内存记录缓存
    * 磁盘存储
    * 上传器
- 如何降低数据的丢失率？
    * 定期写入磁盘
    * 每当达到某个值的时候，就写入磁盘
- 记录上传的时机
    * 前后台切换的时候可以上传
    * 从无网到有网切换的时候可以上传
- 上传时机的选择
    * 立即上传
    * 定时上传
    * 延时上传

### 4.如何实现 App 换肤（夜间模式）？
### 5.外观模式
### 6.中介者模式
### 7.访问者模式
### 8.装饰模式
### 9.观察者模式
### 10.责任链模式
### 11.命令模式
### 12.适配器模式
### 13.桥接模式
### 14.代理委托模式
### 15.单例模式
### 补充：单例弊端？
- 优点：
    * 一个类只被实例化一次，提供了对唯一实例的受控访问。
    * 节省系统资源
    * 允许可变数目的实例。
- 缺点：
    * 一个类只有一个对象，可能造成责任过重，在一定程度上违背了“单一职责原则”。
    * 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。
    * 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

### 16.类工厂模式


## WebView
### 1.说一下 JS 和 OC 互相调用的几种方式？
### 2.在使用 WKWedView 时遇到过哪些问题？
### 3.是否了解 UIWebView 的插件化？
### 4.是否了解 SFSafariViewController ？


## 音频处理

## 视频处理
### 补充：AVFoundation原理

## 图像处理
### 1.图像的压缩、解压。
### 2.一张物理体积20KB、分辨率为 200 * 300 的图片，在内存中占用多大的空间？

## iOS 动画
### 1.简要说一下常用的动画库。
### 2.请说一下对 CALayer 的认识。
### 3.解释一下 CALayer.contents 属性。
### 4.在 iOS 中，动画有哪几种类型？
### 5.隐式动画
### 6.显式动画

## 蓝牙

## ARKit

## Core ML

## 代码管理、持续集成、项目托管
### 1.Git
#### 1.`git pull` 和 `git fetch` 的区别？
#### 2.`git merge` 和 `git rebase` 的区别？
#### 3.如何在本地新建一个分支，并 push 到远程服务器上？
#### 4.如果 fork 了一个别人的仓库，怎样与源仓库保持同步
#### 5.总结一下 Git 常用的命令？
### 2.Svn
### 3.CocoaPods
#### 1.说一下 `CocoaPods` 的原理？
#### 2.如何让自己写的框架支持 `CocoaPods`？
#### 3.`pod update` 和 `pod install` 有什么区别？
#### 4.`Podfile.lock` 文件起什么作用？
#### 5.CocoaPods 常用指令？
#### 6.在使用 CocoaPods 中遇到过哪些问题？
#### 7.如何使用 CocoaPods 集成远程私有库？
#### 8.如果自己写的库需要依赖其他的三方库，该怎么办？
#### 9.CocoaPods 中的 Subspec 字段有什么用处？
### 4.Carthage
### 5.Fastlane
### 6.Jenkins
### 7.fir.im
### 8.蒲公英
### 9.TestFlight

## 数据安全及加密
### 1.RSA非对称加密  
### 2.AES对称加密
### 3.DES加密
### 4.Base64加密
### 5.MD5加密
### 6.简述 `SSL` 加密的过程用了哪些加密方法，为何这么作？
### 7.是否了解 `iOS` 的签名机制？
### 8.如何对 `APP` 进行重签名？

## 源代码阅读
### 1.YYKit
### 2.SDWebImage
#### 面试常见问题
#### 1.看过sdwebimage的源码吗？说一下sdwebimage的原理
- SDWebImage加载图片的流程
    * 入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage显示，然后 SDWebImageManager根据 URL 开始处理图片。
    * 进入SDWebImageManager类中downloadWithURL:delegate:options:userInfo:，交给 SDImageCache从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:.
    * 先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate回调 imageCache:didFindImage:forKey:userInfo:到 SDWebImageManager。
    * SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage: 到 UIImageView+WebCache,等前端展示图片。
    * 如果内存缓存中没有，生成 ｀NSOperation ｀ 添加到队列，开始从硬盘查找图片是否已经缓存。
    * 根据 URL的MD5值Key在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。
    * 如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小， 会先清空内存缓存）。SDImageCacheDelegate'回调 imageCache:didFindImage:forKey:userInfo:`。进而回调展示图片。
    * 如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片， 回调 imageCache:didNotFindImageForKey:userInfo:。
    * 共享或重新生成一个下载器 SDWebImageDownloader开始下载图片。
    * 图片下载由 NSURLConnection来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。
    * connection:didReceiveData: 中利用 ImageIO做了按图片下载进度加载效果。
    * connectionDidFinishLoading: 数据下载完成后交给 SDWebImageDecoder做图片解码处理。
    * 图片解码处理在一个 NSOperationQueue完成，不会拖慢主线程 UI.如果有需要 对下载的图片进行二次处理，最好也在这里完成，效率会好很多。
    * 在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成 imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader`。
    * imageDownloader:didFinishWithImage:回调给 SDWebImageManager告知图片 下载完成。
    * 通知所有的 downloadDelegates下载完成，回调给需要的地方展示图片。
    * 将图片保存到 SDImageCache中，内存缓存和硬盘缓存同时保存。写文件到硬盘 也在以单独 NSOperation 完成，避免拖慢主线程。
    * SDImageCache 在初始化的时候会注册一些消息通知， 在内存警告或退到后台的时 候清理内存图片缓存，应用结束的时候清理过期图片。
#### 2.说一下SDWebImage的缓存策略？
- 有一个专门的 Cache 分类用来处理图片的缓存。 这里面也有两个类 SDImageCache 和 SDImageCacheConfig。 大部分的缓存处理都在 SDImageCache 这个类中实现。
- SDImageCache 中有一个叫做 memCache 的属性，它是一个 NSCache 对象，用于实现我们对图片的 Memory Cache，其实就是接受系统的内存警告通知，然后清除掉自身的图片缓存。Disk Cache，也就是文件缓存，SDWebImage 会将图片存放到 NSCachesDirectory目录中，然后为每一个缓存文件生成一个 md5 文件名, 存放到文件中。
- Memory 和 Disk 双缓存
    * Memory(内存)中查找：SDImageCache 类的 queryDiskCacheForKey方法，查询图片缓存，queryDiskCacheForKey 方法内部， 先会查询 Memory Cache ，如果查找到就直接返回，反之进入下面的硬盘查找。
    * Disk(硬盘) 中查找：如果 Memory Cache查找不到， 就会查询 Disk Cache，查询Disk Cache 的时候有一个小插曲，就是如果 Disk Cache 查询成功，还会把得到的图片再次设置到 Memory Cache 中。这样做可以最大化那些高频率展现图片的效率。如果找不到就进入下面的网络下载。
    * 网路下载：请求网络使用的是imageDownloader属性，这个示例专门负责下载图片数据。如果下载失败， 会把失败的图片地址写入failedURLs集合，为什么要有这个 failedURLs 呢，因为SDWebImage默认会有一个对上次加载失败的图片拒绝再次加载的机制。也就是说，一张图片在本次会话加载失败了，如果再次加载就会直接拒绝，SDWebImage这样做可能是为了提高性能。如果下载图片成功了，接下来就会使用 [self.imageCache storeImage]方法将它写入缓存，同时也会写入硬盘，并且调用 completedBlock 告诉前端显示图片。
    * Disk(硬盘)缓存清理策略：SDWebImage 会在每次 APP 结束的时候执行清理任务。清理缓存的规则分两步进行。第一步先清除掉过期的缓存文件。如果清除掉过期的缓存之后，空间还不够。那么就继续按文件时间从早到晚排序，先清除最早的缓存文件，直到剩余空间达到要求。

#### 3.磁盘缓存时间，默认的缓存路径，怎么处理图片的名称?默认的超时时间是多少?最大并发数？
#### 4.该框架内部对内存警告的处理方式?（或者问：当app接收到内存警告时，SDWebImage做了什么？）
#### 5.NSCache和字典的区别？
#### 6.如何计算图片的成本?
#### 7.保证错误的URL不会被尝试重新下载，使用什么来下载图片的 
#### 8.sdwebimage是一个异步下载图片的三方，怎么保证线程安全的？
#### 9.如果一个页面 加载图片很卡 ，什么原因，会跟sdwebimage有关吗，还是跟图片渲染有关？
#### 补充：如果收到内存警告怎么办
- 如果使用了SDWebImage框架,使用如下代码,可以有效的减少内存:

```
[[SDImageCache sharedImageCache] setValue:nil forKey:@"memCache"];//清除内存中通过SDWebImage框架下载的图片,建议在收到内存警告时在调用
```
#### 补充：SDWebImage是如何做到Url不变的情况下，更新图片内容的？
- SDWebImage它是基于URL作为Key来实现图片缓存机制的。大多数情况下，片与URL是一一对应的，即使服务器修改了图片也会相应的变更URL。但是在少数情况下，服务器修改了图片后不会变更相应的URL，也就是说图片本身的内容变了然而它的URL没有变化，那么按照对SDWebImage的常规使用方法的话，客户端肯定更新不到同一URL对应到服务器已变更的图片内容。
- 客户端第一次请求图片时，Charles抓包得知response header里有一个名为Last-Modified、数据是时间戳的键值对。
- 客户端第二次及以后请求图片时，通过Charles抓包发现，服务器返回304 not modified状态，说明服务器在接收客户端请求后通过某种判断逻辑得出结论：“客户端已缓存的图片与服务器图片都是最新的”，那么服务器如何判断的呢？
- 通过查阅HTTP协议相关的资料得知，与服务器返回的Last-Modified相对应的request header里可以加一个名为If-Modified-Since的key，value即是服务器回传的服务端图片最后被修改的时间，第一次图片请求时If-Modified-Since的值为空，第二次及以后的客户端请求会把服务器回传的Last-Modified值作为If-Modified-Since的值传给服务器，这样服务器每次接收到图片请求时就将If-Modified-Since与Last-Modified进行比较，如果客户端图片已陈旧那么返回状态码200、Last-Modified、图片内容，客户端存储Last-Modified和图片；如果客户端图片是最新的那么返回304 Not Modified、不会返回Last-Modified、图片内容。
- Apache比较时是看If-Modified-Since之后有没有更新图片，Nginx比较时是看If-Modified-Since与Last-Modified是否相等，所以对于Apache服务器环境客户端每次都要严格的存储服务器回传的Last-Modified以便下次请求时作为If-Modified-Since的值传给服务器，对于Nginx服务器环境客户端不必存储服务器回传的Last-Modified，每次请求时只需将图片自身的fileModificationDate作为If-Modified-Since的值传服务器即可。在实际开发中，如果遇到明明传了If-Modified-Since、服务器图片也变更了、但是客户端却请求不到最新的图片的情况时，那么就需要查看一下服务器对这两个时间戳的比较逻辑。
- 那么，现在我们可以回到SDWebImage上来了。通过查看SDWebImageDownloader的源码得知，它开放了一个headersFilter的block，意在让开发者可以对所有图片请求追加一些额外的header，这正合我意。那么我们就可以在诸如AppDelegate didFinishLaunching的地方追加如下代码：

```
SDWebImageDownloader *imgDownloader = SDWebImageManager.sharedManager.imageDownloader;
imgDownloader.headersFilter  = ^NSDictionary *(NSURL *url, NSDictionary *headers) {

    NSFileManager *fm = [[NSFileManager alloc] init];
    NSString *imgKey = [SDWebImageManager.sharedManager cacheKeyForURL:url];
    NSString *imgPath = [SDWebImageManager.sharedManager.imageCache defaultCachePathForKey:imgKey];
    NSDictionary *fileAttr = [fm attributesOfItemAtPath:imgPath error:nil];

    NSMutableDictionary *mutableHeaders = [headers mutableCopy];

    NSDate *lastModifiedDate = nil;

    if (fileAttr.count > 0) {
        if (fileAttr.count > 0) {
            lastModifiedDate = (NSDate *)fileAttr[NSFileModificationDate];
        }

    }
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    formatter.timeZone = [NSTimeZone timeZoneWithAbbreviation:@"GMT"];
    formatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US"];
    formatter.dateFormat = @"EEE, dd MMM yyyy HH:mm:ss z";

    NSString *lastModifiedStr = [formatter stringFromDate:lastModifiedDate];
    lastModifiedStr = lastModifiedStr.length > 0 ? lastModifiedStr : @"";
    [mutableHeaders setValue:lastModifiedStr forKey:@"If-Modified-Since"];

    return mutableHeaders;
};

```
- 然后，加载图片的地方以前怎么写还是怎么写，但别忘了Option是SDWebImageRefreshCached

```
NSURL *imgURL = [NSURL URLWithString:@"http://handy-img-storage.b0.upaiyun.com/3.jpg"];  
[[self imageView] sd_setImageWithURL:imgURL  
                    placeholderImage:nil  
                             options:SDWebImageRefreshCached];
                             
```
- 经测试，服务器只修改图片不变更URL的时候，客户端也可以更新到最新的图片。
从以上第一段代码内容可以看出我采用的是与ngix服务器比较逻辑对应的代码，BTW:我测试的服务器是又拍云，说明又拍云的比较逻辑是等与不等的关系判断，不是大小关系的判断。
- 这里顺便说一下，如果服务器的环境是类似于Apache的比较逻辑时，客户端可以把Last-Modified存放在图片的名称上(这需要修改SDWebImage源码，不建议)，或者用一个plist文件存放图片key名称与时间的对应关系(这个不用修改源码)。
- OK，到此这次的主题已得到完美解决。
- 其实，在抓取服务器返回的数据包时，还发现response header中还有一个ETag，与之相对应的request header中可以追加一个If-None-Match的key，这对header与Last-Modified、If-Modified-Since的作用是相同的，即服务器是否需要返回最新的图片，当然它们在服务器端的判断逻辑应该是等与不等的判断，Etag在客户端的存储同样可以采用在plist文件中存放图片key名称与Etag的对应关系。

### 3.AFNetworking
### 4.SVProgressHub 
### 5.Texture（ASDK）

## iOS逆向及安全
### 补充：怎么防止反编译？
- 本地数据加密。
    * iOS应用防反编译加密技术之一：对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息
- URL编码加密。
    * iOS应用防反编译加密技术之二：对程序中出现的URL进行编码加密，防止URL被静态分析
- 网络传输数据加密。
    * iOS应用防反编译加密技术之三：对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取数据
- 方法体，方法名高级混淆。
    * iOS应用防反编译加密技术之四：对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码
- 程序结构混排加密。
    * iOS应用防反编译加密技术之五：对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低

### 补充：项目中网络层如何做安全处理？
- 尽量使用https
    * https可以过滤掉大部分的安全问题。https在证书申请，服务器配置，性能优化，客户端配置上都需要投入精力，所以缺乏安全意识的开发人员容易跳过https，或者拖到以后遇到问题再优化。https除了性能优化麻烦一些以外其他都比想象中的简单，如果没精力优化性能，至少在注册登录模块需要启用https，这部分业务对性能要求比较低。
- 不要传输明文密码
    * 不知道现在还有多少app后台是明文存储密码的。无论客户端，server还是网络传输都要避免明文密码，要使用hash值。客户端不要做任何密码相关的存储，hash值也不行。存储token进行下一次的认证，而且token需要设置有效期，使用refresh，token去申请新的token。
- Post并不比Get安全
    * 事实上，Post和Get一样不安全，都是明文。参数放在QueryString或者Body没任何安全上的差别。在Http的环境下，使用Post或者Get都需要做加密和签名处理。
- 不要使用301跳转
    * 301跳转很容易被Http劫持攻击。移动端http使用301比桌面端更危险，用户看不到浏览器地址，无法察觉到被重定向到了其他地址。如果一定要使用，确保跳转发生在https的环境下，而且https做了证书绑定校验。
- http请求都带上MAC
    * 所有客户端发出的请求，无论是查询还是写操作，都带上MAC（Message Authentication Code）。MAC不但能保证请求没有被篡改（Integrity），还能保证请求确实来自你的合法客户端（Signing）。当然前提是你客户端的key没有被泄漏，如何保证客户端key的安全是另一个话题。MAC值的计算可以简单的处理为hash（request params＋key）。带上MAC之后，服务器就可以过滤掉绝大部分的非法请求。MAC虽然带有签名的功能，和RSA证书的电子签名方式却不一样，原因是MAC签名和签名验证使用的是同一个key，而RSA是使用私钥签名，公钥验证，MAC的签名并不具备法律效应。
- http请求使用临时密钥
    * 高延迟的网络环境下，不经优化https的体验确实会明显不如http。在不具备https条件或对网络性能要求较高且缺乏https优化经验的场景下，http的流量也应该使用AES进行加密。AES的密钥可以由客户端来临时生成，不过这个临时的AES key需要使用服务器的公钥进行加密，确保只有自己的服务器才能解开这个请求的信息，当然服务器的response也需要使用同样的AES key进行加密。由于http的应用场景都是由客户端发起，服务器响应，所以这种由客户端单方生成密钥的方式可以一定程度上便捷的保证通信安全。
- AES使用CBC模式
    * 不要使用ECB模式，记得设置初始化向量，每个block加密之前要和上个block的秘文进行运算。

## Coretext
## 项目组件化
### 1.说一下你之前项目的组件化方案？
### 2.项目的组件化模块应该如何划分？
### 3.如何集成本地私有库？
### 4.如何集成远程私有库？

## 性能优化
### 1.如何提升 `tableview` 的流畅度？
- 本质上是降低 CPU、GPU 的工作，从这两个大的方面去提升性能。
    * CPU：对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制
    * GPU：纹理的渲染
- 卡顿优化在 CPU 层面
    * 尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView
    * 不要频繁地调用 UIView 的相关属性，比如 frame、bounds、transform 等属性，尽量减少不必要的修改
    * 尽量提前计算好布局，在有需要时一次性调整对应的属性，不要多次修改属性
    * Autolayout 会比直接设置 frame 消耗更多的 CPU 资源
    * 图片的 size 最好刚好跟 UIImageView 的 size 保持一致
    * 控制一下线程的最大并发数量
    * 尽量把耗时的操作放到子线程
        * 文本处理（尺寸计算、绘制）
        * 图片处理（解码、绘制）
- 卡顿优化在 GPU层面
    * 尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示
    * GPU能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行处理，所以纹理尽量不要超过这个尺寸
    * 尽量减少视图数量和层次
    * 减少透明的视图（alpha<1），不透明的就设置 opaque 为 YES
    * 尽量避免出现离屏渲染
- iOS 保持界面流畅的技巧
    * 预排版，提前计算
        * 在接收到服务端返回的数据后，尽量将 CoreText 排版的结果、单个控件的高度、cell 整体的高度提前计算好，将其存储在模型的属性中。需要使用时，直接从模型中往外取，避免了计算的过程。
        * 尽量少用 UILabel，可以使用 CALayer 。避免使用AutoLayout的自动布局技术，采取纯代码的方式
    * 预渲染，提前绘制
        * 例如圆形的图标可以提前在，在接收到网络返回数据时，在后台线程进行处理，直接存储在模型数据里，回到主线程后直接调用就可以了，避免使用CALayer的Border、corner、shadow、mask 等技术，这些都会触发离屏渲染。
    * 异步绘制
    * 全局并发线程
    * 高效的图片异步加载

### 2.如何使用 `Instruments` 进行性能调优？(Time Profiler、Zombies、Allocations、Leaks)
### 3.如何优化 `APP` 的启动时间
- App启动过程
    * 解析Info.plist
    * 加载相关信息，例如闪屏
    * 沙箱建立、权限检查
    * Mach-O加载
    * 如果是胖二进制文件，寻找合适当前CPU类别的部分
    * 加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）
    * 定位内部、外部指针引用，例如字符串、函数等
    * 执行声明为attribute((constructor))的C函数
    * 加载类扩展（Category）中的方法
    * C++静态对象加载、调用ObjC的 +load 函数
    * 程序执行
    * 调用main()
    * 调用UIApplicationMain()
    * 调用applicationWillFinishLaunching
- 影响启动性能的因素
    * main()函数之前耗时的影响因素
        * 动态库加载越多，启动越慢。
        * ObjC类越多，启动越慢
        * C的constructor函数越多，启动越慢
        * C++静态对象越多，启动越慢
        * ObjC的+load越多，启动越慢
    * main()函数之后耗时的影响因素
        * 执行main()函数的耗时
        * 执行applicationWillFinishLaunching的耗时
        * rootViewController及其childViewController的加载、view及其subviews的加载

### 补充：今日头条的启动优化方案
- 针对于今日头条这个App我们可以优化的点如下：
    * 纯代码方式而不是storyboard加载首页UI。
    * 对didFinishLaunching里的函数考虑能否挖掘可以延迟加载或者懒加载，需要与各个业务方pm和rd共同check 对于一些已经下线的业务，删减冗余代码。
    * 对于一些与UI展示无关的业务，如微博认证过期检查、图片最大缓存空间设置等做延迟加载。
    * 对实现了+load()方法的类进行分析，尽量将load里的代码延后调用。
    * 上面统计数据显示展示feed的导航控制器页面(NewsListViewController)比较耗时，对于viewDidLoad以及viewWillAppear方法中尽量去尝试少做，晚做，不做。

### 4.如何对 `APP` 进行内存、电量、网络流量的优化
### 5.如何有效降低 `APP` 包的大小？
- 可执行文件
    * 编译器优化
        * Strip Linked Product、Make Strings Read-Only、Symbols Hidden by Default 设置为 YES
        * 去掉异常支持，Enable C++ Exceptions、Enable Objective-C Exceptions 设置为 NO， Other C Flags 添加 -fno-exceptions
    * 利用 AppCode 检测未使用的代码：菜单栏 -> Code -> Inspect Code
    * 编写LLVM插件检测出重复代码、未被调用的代码
- 资源
    * 资源包括 图片、音频、视频 等
    * 优化的方式可以对资源进行无损的压缩
    * 去除没有用到的资源

### 6.日常如何检查内存泄露？
- 目前我知道的方式有以下几种
    * Memory Leaks
    * Alloctions
    * Analyse
    * Debug Memory Graph
    * MLeaksFinder
- 泄露的内存主要有以下两种
    * Laek Memory这种是忘记Release操作所泄露的内存。
    * Abandon Memory这种是循环引用，无法释放掉的内存。

### 7.能不能说一下物理屏幕显示的原理？
### 8.解释一下什么是屏幕卡顿、掉帧？该如何避免？
### 9.什么是 `离屏渲染`？什么情况下会触发？该如何应对？
- 离屏渲染就是在当前屏幕缓冲区以外，新开辟一个缓冲区进行操作。
- 离屏渲染出发的场景
    * 圆角 （maskToBounds并用才会触发）
    * 图层蒙版
    * 阴影
    * 光栅化
- 为什么要避免离屏渲染？
    * CPU、GPU在绘制渲染视图时做了大量的工作。离屏渲染发生在GPU层面上，会创建新的渲染缓冲区，会触发 OpenGL的多通道渲染管线，图形上下文的切换会造成额外的开销，增加 GPU 工作量。如果 CPU GPU 累计耗时16.67毫秒还没有完成，就会造成卡顿掉帧。
    * 圆角属性、蒙层遮罩都会触发离屏渲染。指定了以上属性，标记了它在新的图形上下文中，在未愈合之前，不可以用于显示的时候就出发了离屏渲染。
- 在OpenGL中，GPU有2种渲染方式
    * On-Screen Rendering：当前屏幕渲染，在当前用于显示的屏幕缓冲区进行渲染操作
    * Off-Screen Rendering：离屏渲染，在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作
- 离屏渲染消耗性能的原因
    * 需要创建新的缓冲区
    * 离屏渲染的整个过程，需要多次切换上下文环境，先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕
- 哪些操作会触发离屏渲染？
    * 光栅化，layer.shouldRasterize = YES
    * 遮罩，layer.mask
    * 圆角，同时设置 layer.masksToBounds = YES、layer.cornerRadius大于0
    * 考虑通过 CoreGraphics 绘制裁剪圆角，或者叫美工提供圆角图片
    * 阴影，layer.shadowXXX，如果设置了 layer.shadowPath 就不会产生离屏渲染；

### 补充：如何检测离屏渲染？
- 模拟器debug-选中color Offscreen - Renderd离屏渲染的图层高亮成黄 可能存在性能问题
- 真机Instrument-选中Core Animation-勾选Color Offscreen-Rendered Yellow
- 离屏渲染的触发方式
    * 设置了以下属性时，都会触发离屏绘制：
        * layer.shouldRasterize（光栅化）
            * 光栅化概念：将图转化为一个个栅格组成的图象。
            * 光栅化特点：每个元素对应帧缓冲区中的一像素。
        * masks（遮罩）
        * shadows（阴影）
        * edge antialiasing（抗锯齿）
        * group opacity（不透明）
        * 复杂形状设置圆角等
        * 渐变
        * drawRect
- 例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的离屏渲染,降低图形性能。
- 如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。
- 现在摆在我们面前得有三个选择：当前屏幕渲染、离屏渲染、CPU渲染，该用哪个呢？这需要根据具体的使用场景来决定。
- 尽量使用当前屏幕渲染，鉴于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，我们要尽量使用当前屏幕渲染。
- 由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作

### 10.如何高性能的画一个圆角？

```
label.layer.cornerRadius = 5
label.layer.masksToBounds = true
```
- 首先上面的方式是不可取的，会触发离屏渲染。
- 如果能够只用 cornerRadius解决问题，就不用优化。
- 如果必须设置masksToBounds，可以参考圆角视图的数量，如果数量较少（一页只有几个）也可以考虑不用优化。
- UIImageView的圆角通过直接截取图片实现，其它视图的圆角可以通过 Core Graphics 画出圆角矩形实现。

### 11.如何优化 APP 的内存？

### 12.如何优化 APP 的电量？
- 程序的耗电主要在以下四个方面：
    * CPU 处理
    * 定位
    * 网络
    * 图像
- 优化的途径主要体现在以下几个方面：
    * 尽可能降低 CPU、GPU 的功耗。
    * 尽量少用 定时器。
    * 优化 I/O 操作。
        * 不要频繁写入小数据，而是积攒到一定数量再写入
        * 读写大量的数据可以使用 Dispatch_io ，GCD 内部已经做了优化。
        * 数据量比较大时，建议使用数据库
    * 网络方面的优化
        * 减少压缩网络数据 （XML -> JSON -> ProtoBuf），如果可能建议使用 ProtoBuf。
        * 如果请求的返回数据相同，可以使用 NSCache 进行缓存
        * 使用断点续传，避免因网络失败后要重新下载。
        * 网络不可用的时候，不尝试进行网络请求
        * 长时间的网络请求，要提供可以取消的操作
        * 采取批量传输。下载视频流的时候，尽量一大块的进行下载，广告可以一次下载多个
    * 定位层面的优化
        * 如果只是需要快速确定用户位置，最好用 CLLocationManager 的 requestLocation 方法。定位完成后，会自动让定位硬件断电
        * 如果不是导航应用，尽量不要实时更新位置，定位完毕就关掉定位服务
        * 尽量降低定位精度，比如尽量不要使用精度最高的 kCLLocationAccuracyBest
        * 需要后台定位时，尽量设置 pausesLocationUpdatesAutomatically 为 YES，如果用户不太可能移动的时候系统会自动暂停位置更新
        * 尽量不要使用 startMonitoringSignificantLocationChanges，优先考虑 startMonitoringForRegion:
    * 硬件检测优化
        * 用户移动、摇晃、倾斜设备时，会产生动作(motion)事件，这些事件由加速度计、陀螺仪、磁力计等硬件检测。在不需要检测的场合，应该及时关闭这些硬件

### 补充：假如Controller太臃肿，如何优化？
- 将网络请求抽象到单独的类中
    * 方便在基类中处理公共逻辑；
    * 方便在基类中处理缓存逻辑，以及其它一些公共逻辑；
    * 方便做对象的持久化。
- 将界面的封装抽象到专门的类中
    * 构造专门的 UIView 的子类，来负责这些控件的拼装。这是最彻底和优雅的方式，不过稍微麻烦一些的是，你需要把这些控件的事件回调先接管，再都一一暴露回 Controller。
- 构造 ViewModel
    * 借鉴MVVM。具体做法就是将 ViewController 给 View 传递数据这个过程，抽象成构造 ViewModel 的过程。
- 专门构造存储类
    * 专门来处理本地数据的存取。
- 整合常量

## 调试技巧 & 软件使用
### 1.`LLDB` 调试。
### 2.断点调试- breakPoint。
### 3.`NSAssert` 的使用。
### 4.`Charles` 的使用。
    - 使用 Charles 下载过去任意版本的 App。
### 5.`Reveal` 的使用。
### 6.iOS 常见的崩溃类型有哪些？
### 7.当页面 AutoLayout 出现了问题，怎样快速调试？

## 扩展问题
### 1.无痕埋点
### 2.APM（应用程序性能监测）
### 3.Hot Patch（热修补）
### 4.崩溃的处理
### 补充：各个app之间是怎么相互切换的

## 其他问题
### 补充：面向对象的三个要素
- 封装
    * 封装，就是将客观事物抽象为逻辑实体，实体的属性和功能相结合，形成一个有机的整体。并对实体的属性和功能实现进行访问控制，向信任的实体开放，对不信任的实体隐藏。，通过开放的外部接口即可访问，无需知道功能如何实现。
    * 也就是说，封装主要有以下目的：
        * 可隐藏实体实现的细节
        * 提高安全性，设定访问控制，只允许具有特定权限的使用者调用。
        * 简化编程，调用方无需知道功能是怎么实现的，即可调用。
- 继承
    * 继承，在继承机制下形成有层级的类，使得低层级的类可以延用高层级类的特征和方法。继承的实现方式有两种：实现继承、接口继承。
    * 实现继承：直接使用基类公开的属性和方法，无需额外编码。
    * 接口继承：仅使用接口公开的属性和方法名称，需要子类实现。
    * 也就是说，继承有以下目的：
        * 复用代码，减少类的冗余代码，减少开发工作量。
        * 使得类与类之间产生关系，为多态的实现打下基础。
- 多态
    * 多态，是指一个类的同名方法，在不同情况下的实现细节不同。多态机制实现不同的内部实现结构共用同一个外部接口。
    * 也就是说，多态有以下目的：
        * 一个外部接口可被多个同类使用。
        * 不同对象调用同个方法，可有不同实现。

### 补充：多态？
- 多态实现的三个必要条件是：继承、重写（子类继承父类后，对继承的方法重新定义）、父类应用指向子类对象。所以，多态的实现是基于继承的。

### 补充：Java，python，OC运行效率孰高？
- OC最高，OC大于java大于python
- oc方法调用的需要经历查缓存，查方法表，查父类方法表，如果都差不多就会进行动态方法决议，如果还是不行，就执行消息转发机制，如果还是无法处理就crash。但是大部分在方法缓存的时候就能找到，苹果有函数缓存机制，当缓存生效时性能与c差不多。
- Java是静态语言静态编译的，直接执行，速度上要比Python快的很多。而Python动态类型语言，一边执行一边编译，所以要比Java慢。

### 补充：Property，其中copy如何？
- 用途：
    * NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；
    * lock 也经常使用 copy 关键字
- block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。
- 下面做下解释：
    * copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。
    * 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。
    * 用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

### 补充：Property(nonatomatic, copy) NSMutableArray有什么问题？
- 两个问题：
    * 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变 NSArray 的对象；
    * 使用了 atomic 属性会严重影响性能 ；
- 第一个问题：
    * 因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.
- 第二个问题：
    * 该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销。
    * 在默认情况下，由编译器所合成的方法会通过锁定机制确保其原子性(atomicity)。如果属性具备 nonatomic 特质，则不使用同步锁。请注意，尽管没有名为“atomic”的特质(如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic))。
    * 在iOS开发中，你会发现，几乎所有属性都声明为 nonatomic。
    * 一般情况下并不要求属性必须是“原子的”，因为这并不能保证“线程安全” ( thread safety)，若要实现“线程安全”的操作，还需采用更为深层的锁定机制才行。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。
    * 因此，开发iOS程序时一般都会使用 nonatomic 属性。但是在开发 Mac OS X 程序时，使用atomic 属性通常都不会有性能瓶颈。

### 补充：Copy和MutableCopy的区别？
#### 对非集合类对象的 copy 与 mutableCopy 操作；
- 在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：
    * [immutableObject copy] // 浅复制
    * [immutableObject mutableCopy] //深复制
    * [mutableObject copy] //深复制
    * [mutableObject mutableCopy] //深复制
- 用 @property声明NSString、NSArray、NSDictionary 经常使用 copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。

#### 对集合类对象的 copy 与 mutableCopy 操作。
- 集合类对象是指 NSArray、NSDictionary、NSSet ... 之类的对象。
- 集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。

### 补充：解释下类别的原理
### 补充：解释下封装，重载
### 补充：OC存在多重继承吗？
### 补充：了解表视图吗，解释一下复用原理
### 补充：说明一下表视图的滑动卡顿的优化方法
### 补充：viewDidLoad和viewDidAppear的调用时机（一次和多次的区别）；
### 补充：页面间的传值方式有哪些（公有属性，公有方法和协议，block传值，通知，extern全局变量传值，NSUserDefault简单数据存储传值）；
### 补充：
### 补充：在OC中对象方法的几种访问权限，分别是什么？
### 补充：列出 #import 和 #include 的区别，另外什么时候使用@class？
### 1.`load` 和 `Initialize` 的区别?
### 2.`Designated Initializer`的规则？
### 3.`App` 编译过程有了解吗？
### 补充：介绍下App启动的完成过程？
- 先加载Main函数
- 在Main函数里的 UIApplicationMain方法中，创建Application对象 创建Application的Delegate对象
- 创建主循环，代理对象开始监听事件
- 启动完毕会调用 didFinishLaunching方法，并在这个方法中创建UIWindow
- 设置UIWindow的根控制器是谁
- 如果有storyboard，会根据info.plist中找到应用程序的入口storyboard并加载箭头所指的控制器
- 显示窗口
- 其中在didFinishLaunching方法到窗口显示其中有AppDelegate,ViewController,MainView（控制器的View）,ChildView（子控件的View）的18个方法：
    * AppDelegate中的：
        * application:didFinishLaunchingWithOptions:
        * applicationDidBecomeActive:
    * ViewController中的：
        * loadView
        * viewDidLoad
        * load
        * initialize
        * viewWillAppear
        * viewWillLayoutSubviews
        * viewDidLayoutSubviews
        * viewDidAppear
    * MainView（控制器的View）中的
        * initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
        * awakeFromNib
        * layoutSubviews
        * drawRect
    * ChildView（子控件View）中的：
        * initWithCoder（如果没有storyboard就会调用initWithFrame，这里两种方法视为一种）
        * awakeFromNib
        * layoutSubviews
        * drawRect
- 十八个方法排个顺序

```
+ (void)load; //这是应用程序启动就会调用的方法，在这个方法里写的代码最先调用

+ (void)initialize; //这个是需要用到本类时才调用，这个方法里一般写设置导航控制器的主题啊之类的，
//如果在后面的方法设置导航栏主题就晚了！（当然在上面的方法里也能写）

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions;
//这个方法里面会创建UIWindow，设置根控制器并展现，
//比如某些应用程序要加载授权页面也是在这加，也可以设置观察者，监听到通知切换根控制器

ChildView - (instancetype)initWithCoder:(NSCoder *)aDecoder;
//这里反正我是万万没想到，childView的initwithcoder会在MainView的方法之前调用，
//父的都还没出来，就先整子控件？ 有了解比较透彻的博友恳请告诉我谢谢。

MainView - (instancetype)initWithCoder:(NSCoder *)aDecoder;
// 就是关于应用程序的数据存储后的解档操作。

MainView - (void)awakeFromNib;
//在这个方法里设置view的背景等一系列普通操作，不要写关于frame的还不准，
//在使用IB的时候才会涉及到此方法的使用，当.nib文件被加载的时候，
//会发送一个awakeFromNib的消息到.nib文件中的每个对象，
//每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。

ChildView - (void)awakeFromNib
//子控件也有本方法，重写父类的方法。基本用法同上

- (void)loadView; 
//创建视图的层次结构，这里需要注意，
//在没有创建控制器的view的情况下不能直接写 self.view 因为self.view的底层是：
    if（_view == nil）{
　   　_view = [self loadView]
    }
//所以这么写会直接造成死循环。
//如果重写这个loadView方法里面什么都不写，会显示黑屏

- (void)viewDidLoad;
//卧槽，这个方法是用的最多的方法，但是在之后的开发中就会发现越来越不靠谱，
//很多东西都还没加载完毕，各种取值都不准确，很少在这里面写东西了。 
//这里只是把视图元件加载完成

- (void)viewWillAppear:(BOOL)animated;
//视图将要出现，这个方法用的非常多，比如如果要设置导航栏的setNavigationBarHiden:animate: 
//就必须要在这里写，才能完美契合，不卡跳。 还有很多比如监听屏幕旋转啦，
 
//viewWillTransitionToSize:可能要在本方法里再调一次，
//或者就是新到这个界面要reloadData或是自动下拉刷新等 都是写在本方法里

- (void)viewWillLayoutSubviews;
//视图将要布局子视图，苹果建议的设置界面布局属性的方法，
//这个方法和viewWillAppear里，系统的底层都是没有写任何代码的，也就是说这里面不写super 也是可以的

MainView  - (void)layoutSubviews;
//在这个方法里一般设置子控件的frame，因为这里相当于是布局基本完成了，
//设置时取到的frame或者是self.bounds才最准，如果在awakeFromeNib里写会不准确 。
//还有这里要切记千万不能把super layoutSubviews忘了，可能最后都很难找到这个bug

- (void)viewDidLayoutSubviews;
//这个方法我也是玩玩没想到，控制器的view的子控件还没有布局好呢，怎么这个控制器就已经说布局全部完成了？
//那后边的布局就不等了？ 有独到见解的也恳请你告诉我，这其中苹果的意思到底是什么。

ChildView - (void)layoutSubviews;
//控制器的子控件里的子控件的布局就在这里写了。

MainView - (void)drawRect:(CGRect)rect;
//因为默认所有额UI控件都是画上去的，在这一步就是把所有的东西画上去，
//有时候需要用到Quartz2D的知识的时候都是在这个方法里话，但也是要注意别忘了写super，
//不然系统原本的东西就都画不上来了，这里要建议尽可能使用贝塞尔路径画图形，
//因为系统默认的那个上下文画法有时可能会内存泄露。drawRect方法只能在加载时调用一次，
//如果后面还需要调用，比如下载进度的圆弧，需要一直刷帧，
//就要使用setNeedsDisplay来定时多次调用本方法

ChildView - (void)drawRect:(CGRect)rect;
//view的子控件内部的画图方法，有时可以自己自定义label 中间带个删除线的（用来写打折前的原价） 就是在这里画根线 。

- (void)viewDidAppear:(BOOL)animated;
//把上面的画图都画完了，这里就会显示，视图完全加载完成。
//在这里的操作可能就是设置页面的一些动画,或者是设置tableView，collectionView，
//QQ聊天页面啥的滚动到底部scrollToIndexPath之类的代码操作

- (void)applicationDidBecomeActive:(UIApplication *)application;
//最后这是AppDelegate的应用程序获取焦点方法，真正到了这里，才是所有东西全部加载完毕，应用程序整装待发保持最佳状态等待用户操作。
//这个方法中一般会写关于弹出键盘的方法，比如有的用户登录界面为了更好的用户体验，
//就让你在刚打开程序来到登录界面的时候，光标的焦点就自动在账号的文本框里闪烁，
//也就是设置账号文本框为第一响应者。键盘在页面加载完毕后从下方弹出，这种代码一般就在本方法写。

```

### 4.`JS` 和 `Native` 交互。
### 5.`LoadView`方法了解吗？
### 6.说一下对 `APNS` 的认识？
### 7.`UIButton` 的父类是什么？`UILabel` 的父类又是什么？
### 8.实现一个控件，可以浮在任意界面的上层并支持拖动？
### 9.解释一下 `copy` 关键字涉及的方方面面，说的越全越好。
### 10.说一下控制器 `View` 的生命周期，一旦收到内存警告会如何处理？
### 11.简述事件传递、事件响应机制。
### 12.说一下对 `Super` 关键字的理解。
### 13.`@synthesize` 和 `@dynamic` 分别有什么作用？
### 补充：简述Xcode7和Xcode8的异同
### 补充：描述iOS 10的一些新特性（包括系统和开发环境）
### 14.App 上有一数据列表，客户端和服务端均没有任何缓存，当服务端有数据更新时，该列表在 wifi 下能获取到数据，在 4G 下刷新不到，但是在 4g 环境下其他 App 都可以正常打开，分析其产生的原因？
### 15.是否了解链式编程？
### 补充：dSYM你是如何分析的
- 我们在iOS开发过程中一定会跟符号表（dSYM文件）打交道，它是我们不可或缺的定位bug的小帮手。我们都知道，每次编译都会生成一个dSYM文件，当我们的应用程序出现奔溃时，dSYM文件能帮我们定位到应用程序的代码奔溃到哪里了。
- 符号表是内存地址与函数名、文件名、行号的映射表。符号表元素如下所示：

```
<起始地址> <结束地址> <函数> [<文件名:行号>]
```
- dSYM是如何分析的
    * 方法1 使用XCode，这种方法可能是最容易的方法了。
        * 要使用Xcode符号化 crash log，你需要下面所列的3个文件：crash报告（.crash文件），符号文件(.dsymb文件)，应用程序文件(appName.app文件，把IPA文件后缀改为zip，然后解压，Payload目录下的appName.app文件),这里的appName是你的应用程序的名称。把这3个文件放到同一个目录下，打开Xcode的Window菜单下的organizer，然后点击Devices tab，然后选中左边的Device Logs。然后把.crash文件拖到Device Logs或者选择下面的import导入.crash文件。这样你就可以看到crash的详细log了。
        * 方法2 使用命令行工具symbolicatecrash，有时候Xcode不能够很好的符号化crash文件。我们这里介绍如何通过symbolicatecrash来手动符号化crash log。在处理之前，请依然将“.app“, “.dSYM”和 ".crash"文件放到同一个目录下。现在打开终端(Terminal)然后输入如下的命令：export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer，然后输入命令：/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/PrivateFrameworks/DTDeviceKitBase.framework/Versions/A/Resources/symbolicatecrash appName.crash appName.app > appName.log；现在，符号化的crash log就保存在appName.log中了。
        * 方法3 使用命令行工具atos，如果你有多个“.ipa”文件，多个".dSYMB"文件，你并不太确定到底“dSYMB”文件对应哪个".ipa"文件，那么，这个方法就非常适合你。特别当你的应用发布到多个渠道的时候，你需要对不同渠道的crash文件，写一个自动化的分析脚本的时候，这个方法就极其有用。
            